<?php
/**
 * V2serversserverNamevhostsApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.14
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * V2serversserverNamevhostsApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class V2serversserverNamevhostsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation deletePublisherVhostConfig
     *
     * Deletes the specified Publisher configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deletePublisherVhostConfig($server_name, $vhost_name, $publisher_name)
    {
        $this->deletePublisherVhostConfigWithHttpInfo($server_name, $vhost_name, $publisher_name);
    }

    /**
     * Operation deletePublisherVhostConfigWithHttpInfo
     *
     * Deletes the specified Publisher configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePublisherVhostConfigWithHttpInfo($server_name, $vhost_name, $publisher_name)
    {
        $returnType = '';
        $request = $this->deletePublisherVhostConfigRequest($server_name, $vhost_name, $publisher_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deletePublisherVhostConfigAsync
     *
     * Deletes the specified Publisher configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePublisherVhostConfigAsync($server_name, $vhost_name, $publisher_name)
    {
        return $this->deletePublisherVhostConfigAsyncWithHttpInfo($server_name, $vhost_name, $publisher_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePublisherVhostConfigAsyncWithHttpInfo
     *
     * Deletes the specified Publisher configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePublisherVhostConfigAsyncWithHttpInfo($server_name, $vhost_name, $publisher_name)
    {
        $returnType = '';
        $request = $this->deletePublisherVhostConfigRequest($server_name, $vhost_name, $publisher_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePublisherVhostConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePublisherVhostConfigRequest($server_name, $vhost_name, $publisher_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling deletePublisherVhostConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling deletePublisherVhostConfig'
            );
        }
        // verify the required parameter 'publisher_name' is set
        if ($publisher_name === null || (is_array($publisher_name) && count($publisher_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $publisher_name when calling deletePublisherVhostConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/publishers/{publisherName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($publisher_name !== null) {
            $resourcePath = str_replace(
                '{' . 'publisherName' . '}',
                ObjectSerializer::toPathValue($publisher_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteSDPFileConfig
     *
     * Deletes the specified SDP file
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $sdpfile_name The SDP file name without the extension (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteSDPFileConfig($server_name, $vhost_name, $sdpfile_name)
    {
        $this->deleteSDPFileConfigWithHttpInfo($server_name, $vhost_name, $sdpfile_name);
    }

    /**
     * Operation deleteSDPFileConfigWithHttpInfo
     *
     * Deletes the specified SDP file
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $sdpfile_name The SDP file name without the extension (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteSDPFileConfigWithHttpInfo($server_name, $vhost_name, $sdpfile_name)
    {
        $returnType = '';
        $request = $this->deleteSDPFileConfigRequest($server_name, $vhost_name, $sdpfile_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteSDPFileConfigAsync
     *
     * Deletes the specified SDP file
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $sdpfile_name The SDP file name without the extension (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSDPFileConfigAsync($server_name, $vhost_name, $sdpfile_name)
    {
        return $this->deleteSDPFileConfigAsyncWithHttpInfo($server_name, $vhost_name, $sdpfile_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteSDPFileConfigAsyncWithHttpInfo
     *
     * Deletes the specified SDP file
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $sdpfile_name The SDP file name without the extension (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSDPFileConfigAsyncWithHttpInfo($server_name, $vhost_name, $sdpfile_name)
    {
        $returnType = '';
        $request = $this->deleteSDPFileConfigRequest($server_name, $vhost_name, $sdpfile_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteSDPFileConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $sdpfile_name The SDP file name without the extension (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteSDPFileConfigRequest($server_name, $vhost_name, $sdpfile_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling deleteSDPFileConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling deleteSDPFileConfig'
            );
        }
        // verify the required parameter 'sdpfile_name' is set
        if ($sdpfile_name === null || (is_array($sdpfile_name) && count($sdpfile_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sdpfile_name when calling deleteSDPFileConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/sdpfiles/{sdpfileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($sdpfile_name !== null) {
            $resourcePath = str_replace(
                '{' . 'sdpfileName' . '}',
                ObjectSerializer::toPathValue($sdpfile_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteSMILFileConfig
     *
     * Deletes the specified SMIL File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteSMILFileConfig($server_name, $vhost_name, $smilfile_name)
    {
        $this->deleteSMILFileConfigWithHttpInfo($server_name, $vhost_name, $smilfile_name);
    }

    /**
     * Operation deleteSMILFileConfigWithHttpInfo
     *
     * Deletes the specified SMIL File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteSMILFileConfigWithHttpInfo($server_name, $vhost_name, $smilfile_name)
    {
        $returnType = '';
        $request = $this->deleteSMILFileConfigRequest($server_name, $vhost_name, $smilfile_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteSMILFileConfigAsync
     *
     * Deletes the specified SMIL File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSMILFileConfigAsync($server_name, $vhost_name, $smilfile_name)
    {
        return $this->deleteSMILFileConfigAsyncWithHttpInfo($server_name, $vhost_name, $smilfile_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteSMILFileConfigAsyncWithHttpInfo
     *
     * Deletes the specified SMIL File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSMILFileConfigAsyncWithHttpInfo($server_name, $vhost_name, $smilfile_name)
    {
        $returnType = '';
        $request = $this->deleteSMILFileConfigRequest($server_name, $vhost_name, $smilfile_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteSMILFileConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteSMILFileConfigRequest($server_name, $vhost_name, $smilfile_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling deleteSMILFileConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling deleteSMILFileConfig'
            );
        }
        // verify the required parameter 'smilfile_name' is set
        if ($smilfile_name === null || (is_array($smilfile_name) && count($smilfile_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $smilfile_name when calling deleteSMILFileConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/smilfiles/{smilfileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($smilfile_name !== null) {
            $resourcePath = str_replace(
                '{' . 'smilfileName' . '}',
                ObjectSerializer::toPathValue($smilfile_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteStartupStreamConfig
     *
     * Deletes the specified Startup Stream configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $stream_name stream_name (required)
     * @param  string $app_name app_name (required)
     * @param  string $instance_name instance_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteStartupStreamConfig($server_name, $vhost_name, $stream_name, $app_name, $instance_name)
    {
        $this->deleteStartupStreamConfigWithHttpInfo($server_name, $vhost_name, $stream_name, $app_name, $instance_name);
    }

    /**
     * Operation deleteStartupStreamConfigWithHttpInfo
     *
     * Deletes the specified Startup Stream configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $stream_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteStartupStreamConfigWithHttpInfo($server_name, $vhost_name, $stream_name, $app_name, $instance_name)
    {
        $returnType = '';
        $request = $this->deleteStartupStreamConfigRequest($server_name, $vhost_name, $stream_name, $app_name, $instance_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteStartupStreamConfigAsync
     *
     * Deletes the specified Startup Stream configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $stream_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteStartupStreamConfigAsync($server_name, $vhost_name, $stream_name, $app_name, $instance_name)
    {
        return $this->deleteStartupStreamConfigAsyncWithHttpInfo($server_name, $vhost_name, $stream_name, $app_name, $instance_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteStartupStreamConfigAsyncWithHttpInfo
     *
     * Deletes the specified Startup Stream configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $stream_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteStartupStreamConfigAsyncWithHttpInfo($server_name, $vhost_name, $stream_name, $app_name, $instance_name)
    {
        $returnType = '';
        $request = $this->deleteStartupStreamConfigRequest($server_name, $vhost_name, $stream_name, $app_name, $instance_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteStartupStreamConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $stream_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteStartupStreamConfigRequest($server_name, $vhost_name, $stream_name, $app_name, $instance_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling deleteStartupStreamConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling deleteStartupStreamConfig'
            );
        }
        // verify the required parameter 'stream_name' is set
        if ($stream_name === null || (is_array($stream_name) && count($stream_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stream_name when calling deleteStartupStreamConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling deleteStartupStreamConfig'
            );
        }
        // verify the required parameter 'instance_name' is set
        if ($instance_name === null || (is_array($instance_name) && count($instance_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_name when calling deleteStartupStreamConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/startupstreams/applications/{appName}/instances/{instanceName}/streams/{streamName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($stream_name !== null) {
            $resourcePath = str_replace(
                '{' . 'streamName' . '}',
                ObjectSerializer::toPathValue($stream_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($instance_name !== null) {
            $resourcePath = str_replace(
                '{' . 'instanceName' . '}',
                ObjectSerializer::toPathValue($instance_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteStreamFileConfig
     *
     * Deletes the specified Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteStreamFileConfig($server_name, $vhost_name, $streamfile_name)
    {
        $this->deleteStreamFileConfigWithHttpInfo($server_name, $vhost_name, $streamfile_name);
    }

    /**
     * Operation deleteStreamFileConfigWithHttpInfo
     *
     * Deletes the specified Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteStreamFileConfigWithHttpInfo($server_name, $vhost_name, $streamfile_name)
    {
        $returnType = '';
        $request = $this->deleteStreamFileConfigRequest($server_name, $vhost_name, $streamfile_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteStreamFileConfigAsync
     *
     * Deletes the specified Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteStreamFileConfigAsync($server_name, $vhost_name, $streamfile_name)
    {
        return $this->deleteStreamFileConfigAsyncWithHttpInfo($server_name, $vhost_name, $streamfile_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteStreamFileConfigAsyncWithHttpInfo
     *
     * Deletes the specified Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteStreamFileConfigAsyncWithHttpInfo($server_name, $vhost_name, $streamfile_name)
    {
        $returnType = '';
        $request = $this->deleteStreamFileConfigRequest($server_name, $vhost_name, $streamfile_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteStreamFileConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteStreamFileConfigRequest($server_name, $vhost_name, $streamfile_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling deleteStreamFileConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling deleteStreamFileConfig'
            );
        }
        // verify the required parameter 'streamfile_name' is set
        if ($streamfile_name === null || (is_array($streamfile_name) && count($streamfile_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $streamfile_name when calling deleteStreamFileConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/streamfiles/{streamfileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($streamfile_name !== null) {
            $resourcePath = str_replace(
                '{' . 'streamfileName' . '}',
                ObjectSerializer::toPathValue($streamfile_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTranscoderEncodeConfig
     *
     * Deletes the specified Trancoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $encode_name encode_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteTranscoderEncodeConfig($server_name, $vhost_name, $template_name, $encode_name)
    {
        $this->deleteTranscoderEncodeConfigWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name);
    }

    /**
     * Operation deleteTranscoderEncodeConfigWithHttpInfo
     *
     * Deletes the specified Trancoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTranscoderEncodeConfigWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name)
    {
        $returnType = '';
        $request = $this->deleteTranscoderEncodeConfigRequest($server_name, $vhost_name, $template_name, $encode_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteTranscoderEncodeConfigAsync
     *
     * Deletes the specified Trancoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTranscoderEncodeConfigAsync($server_name, $vhost_name, $template_name, $encode_name)
    {
        return $this->deleteTranscoderEncodeConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTranscoderEncodeConfigAsyncWithHttpInfo
     *
     * Deletes the specified Trancoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTranscoderEncodeConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name)
    {
        $returnType = '';
        $request = $this->deleteTranscoderEncodeConfigRequest($server_name, $vhost_name, $template_name, $encode_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTranscoderEncodeConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteTranscoderEncodeConfigRequest($server_name, $vhost_name, $template_name, $encode_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling deleteTranscoderEncodeConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling deleteTranscoderEncodeConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling deleteTranscoderEncodeConfig'
            );
        }
        // verify the required parameter 'encode_name' is set
        if ($encode_name === null || (is_array($encode_name) && count($encode_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $encode_name when calling deleteTranscoderEncodeConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/transcoder/templates/{templateName}/encodes/{encodeName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($encode_name !== null) {
            $resourcePath = str_replace(
                '{' . 'encodeName' . '}',
                ObjectSerializer::toPathValue($encode_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTranscoderOverlayDecodeConfig
     *
     * Deletes the specified Trancoder Overlay Decode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $overlay_name overlay_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteTranscoderOverlayDecodeConfig($server_name, $vhost_name, $template_name, $overlay_name)
    {
        $this->deleteTranscoderOverlayDecodeConfigWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name);
    }

    /**
     * Operation deleteTranscoderOverlayDecodeConfigWithHttpInfo
     *
     * Deletes the specified Trancoder Overlay Decode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTranscoderOverlayDecodeConfigWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name)
    {
        $returnType = '';
        $request = $this->deleteTranscoderOverlayDecodeConfigRequest($server_name, $vhost_name, $template_name, $overlay_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteTranscoderOverlayDecodeConfigAsync
     *
     * Deletes the specified Trancoder Overlay Decode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTranscoderOverlayDecodeConfigAsync($server_name, $vhost_name, $template_name, $overlay_name)
    {
        return $this->deleteTranscoderOverlayDecodeConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTranscoderOverlayDecodeConfigAsyncWithHttpInfo
     *
     * Deletes the specified Trancoder Overlay Decode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTranscoderOverlayDecodeConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name)
    {
        $returnType = '';
        $request = $this->deleteTranscoderOverlayDecodeConfigRequest($server_name, $vhost_name, $template_name, $overlay_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTranscoderOverlayDecodeConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteTranscoderOverlayDecodeConfigRequest($server_name, $vhost_name, $template_name, $overlay_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling deleteTranscoderOverlayDecodeConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling deleteTranscoderOverlayDecodeConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling deleteTranscoderOverlayDecodeConfig'
            );
        }
        // verify the required parameter 'overlay_name' is set
        if ($overlay_name === null || (is_array($overlay_name) && count($overlay_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $overlay_name when calling deleteTranscoderOverlayDecodeConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/transcoder/templates/{templateName}/decode/overlays/{overlayName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($overlay_name !== null) {
            $resourcePath = str_replace(
                '{' . 'overlayName' . '}',
                ObjectSerializer::toPathValue($overlay_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTranscoderOverlayEncodeConfig
     *
     * Deletes the specified Trancoder Overlay Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $overlay_name overlay_name (required)
     * @param  string $encode_name encode_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteTranscoderOverlayEncodeConfig($server_name, $vhost_name, $template_name, $overlay_name, $encode_name)
    {
        $this->deleteTranscoderOverlayEncodeConfigWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $encode_name);
    }

    /**
     * Operation deleteTranscoderOverlayEncodeConfigWithHttpInfo
     *
     * Deletes the specified Trancoder Overlay Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $encode_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTranscoderOverlayEncodeConfigWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $encode_name)
    {
        $returnType = '';
        $request = $this->deleteTranscoderOverlayEncodeConfigRequest($server_name, $vhost_name, $template_name, $overlay_name, $encode_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteTranscoderOverlayEncodeConfigAsync
     *
     * Deletes the specified Trancoder Overlay Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $encode_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTranscoderOverlayEncodeConfigAsync($server_name, $vhost_name, $template_name, $overlay_name, $encode_name)
    {
        return $this->deleteTranscoderOverlayEncodeConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $encode_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTranscoderOverlayEncodeConfigAsyncWithHttpInfo
     *
     * Deletes the specified Trancoder Overlay Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $encode_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTranscoderOverlayEncodeConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $encode_name)
    {
        $returnType = '';
        $request = $this->deleteTranscoderOverlayEncodeConfigRequest($server_name, $vhost_name, $template_name, $overlay_name, $encode_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTranscoderOverlayEncodeConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $encode_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteTranscoderOverlayEncodeConfigRequest($server_name, $vhost_name, $template_name, $overlay_name, $encode_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling deleteTranscoderOverlayEncodeConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling deleteTranscoderOverlayEncodeConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling deleteTranscoderOverlayEncodeConfig'
            );
        }
        // verify the required parameter 'overlay_name' is set
        if ($overlay_name === null || (is_array($overlay_name) && count($overlay_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $overlay_name when calling deleteTranscoderOverlayEncodeConfig'
            );
        }
        // verify the required parameter 'encode_name' is set
        if ($encode_name === null || (is_array($encode_name) && count($encode_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $encode_name when calling deleteTranscoderOverlayEncodeConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/transcoder/templates/{templateName}/encodes/{encodeName}/overlays/{overlayName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($overlay_name !== null) {
            $resourcePath = str_replace(
                '{' . 'overlayName' . '}',
                ObjectSerializer::toPathValue($overlay_name),
                $resourcePath
            );
        }
        // path params
        if ($encode_name !== null) {
            $resourcePath = str_replace(
                '{' . 'encodeName' . '}',
                ObjectSerializer::toPathValue($encode_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTranscoderStreamNameGroupConfig
     *
     * Deletes the specified Trancoder StreamNameGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $group_name group_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteTranscoderStreamNameGroupConfig($server_name, $vhost_name, $template_name, $group_name)
    {
        $this->deleteTranscoderStreamNameGroupConfigWithHttpInfo($server_name, $vhost_name, $template_name, $group_name);
    }

    /**
     * Operation deleteTranscoderStreamNameGroupConfigWithHttpInfo
     *
     * Deletes the specified Trancoder StreamNameGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $group_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTranscoderStreamNameGroupConfigWithHttpInfo($server_name, $vhost_name, $template_name, $group_name)
    {
        $returnType = '';
        $request = $this->deleteTranscoderStreamNameGroupConfigRequest($server_name, $vhost_name, $template_name, $group_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteTranscoderStreamNameGroupConfigAsync
     *
     * Deletes the specified Trancoder StreamNameGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $group_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTranscoderStreamNameGroupConfigAsync($server_name, $vhost_name, $template_name, $group_name)
    {
        return $this->deleteTranscoderStreamNameGroupConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $group_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTranscoderStreamNameGroupConfigAsyncWithHttpInfo
     *
     * Deletes the specified Trancoder StreamNameGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $group_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTranscoderStreamNameGroupConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $group_name)
    {
        $returnType = '';
        $request = $this->deleteTranscoderStreamNameGroupConfigRequest($server_name, $vhost_name, $template_name, $group_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTranscoderStreamNameGroupConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $group_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteTranscoderStreamNameGroupConfigRequest($server_name, $vhost_name, $template_name, $group_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling deleteTranscoderStreamNameGroupConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling deleteTranscoderStreamNameGroupConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling deleteTranscoderStreamNameGroupConfig'
            );
        }
        // verify the required parameter 'group_name' is set
        if ($group_name === null || (is_array($group_name) && count($group_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_name when calling deleteTranscoderStreamNameGroupConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/transcoder/templates/{templateName}/streamnamegroups/{groupName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($group_name !== null) {
            $resourcePath = str_replace(
                '{' . 'groupName' . '}',
                ObjectSerializer::toPathValue($group_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTranscoderTemplateConfig
     *
     * Deletes the specified Trancoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteTranscoderTemplateConfig($server_name, $vhost_name, $template_name)
    {
        $this->deleteTranscoderTemplateConfigWithHttpInfo($server_name, $vhost_name, $template_name);
    }

    /**
     * Operation deleteTranscoderTemplateConfigWithHttpInfo
     *
     * Deletes the specified Trancoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTranscoderTemplateConfigWithHttpInfo($server_name, $vhost_name, $template_name)
    {
        $returnType = '';
        $request = $this->deleteTranscoderTemplateConfigRequest($server_name, $vhost_name, $template_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteTranscoderTemplateConfigAsync
     *
     * Deletes the specified Trancoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTranscoderTemplateConfigAsync($server_name, $vhost_name, $template_name)
    {
        return $this->deleteTranscoderTemplateConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTranscoderTemplateConfigAsyncWithHttpInfo
     *
     * Deletes the specified Trancoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTranscoderTemplateConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name)
    {
        $returnType = '';
        $request = $this->deleteTranscoderTemplateConfigRequest($server_name, $vhost_name, $template_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTranscoderTemplateConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteTranscoderTemplateConfigRequest($server_name, $vhost_name, $template_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling deleteTranscoderTemplateConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling deleteTranscoderTemplateConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling deleteTranscoderTemplateConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/transcoder/templates/{templateName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCurrentVHostStatistics
     *
     * Retrieves the current VHost statistics
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\CurrentVHostStatistics
     */
    public function getCurrentVHostStatistics($server_name, $vhost_name)
    {
        list($response) = $this->getCurrentVHostStatisticsWithHttpInfo($server_name, $vhost_name);
        return $response;
    }

    /**
     * Operation getCurrentVHostStatisticsWithHttpInfo
     *
     * Retrieves the current VHost statistics
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\CurrentVHostStatistics, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCurrentVHostStatisticsWithHttpInfo($server_name, $vhost_name)
    {
        $returnType = '\Swagger\Client\Model\CurrentVHostStatistics';
        $request = $this->getCurrentVHostStatisticsRequest($server_name, $vhost_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\CurrentVHostStatistics',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCurrentVHostStatisticsAsync
     *
     * Retrieves the current VHost statistics
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrentVHostStatisticsAsync($server_name, $vhost_name)
    {
        return $this->getCurrentVHostStatisticsAsyncWithHttpInfo($server_name, $vhost_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCurrentVHostStatisticsAsyncWithHttpInfo
     *
     * Retrieves the current VHost statistics
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrentVHostStatisticsAsyncWithHttpInfo($server_name, $vhost_name)
    {
        $returnType = '\Swagger\Client\Model\CurrentVHostStatistics';
        $request = $this->getCurrentVHostStatisticsRequest($server_name, $vhost_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCurrentVHostStatistics'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCurrentVHostStatisticsRequest($server_name, $vhost_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getCurrentVHostStatistics'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getCurrentVHostStatistics'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/monitoring/current';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getHistoricVHostStatistics
     *
     * Retrieves the historic VHost statistics
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\HistoricVHostStatistics
     */
    public function getHistoricVHostStatistics($server_name, $vhost_name)
    {
        list($response) = $this->getHistoricVHostStatisticsWithHttpInfo($server_name, $vhost_name);
        return $response;
    }

    /**
     * Operation getHistoricVHostStatisticsWithHttpInfo
     *
     * Retrieves the historic VHost statistics
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\HistoricVHostStatistics, HTTP status code, HTTP response headers (array of strings)
     */
    public function getHistoricVHostStatisticsWithHttpInfo($server_name, $vhost_name)
    {
        $returnType = '\Swagger\Client\Model\HistoricVHostStatistics';
        $request = $this->getHistoricVHostStatisticsRequest($server_name, $vhost_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\HistoricVHostStatistics',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getHistoricVHostStatisticsAsync
     *
     * Retrieves the historic VHost statistics
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoricVHostStatisticsAsync($server_name, $vhost_name)
    {
        return $this->getHistoricVHostStatisticsAsyncWithHttpInfo($server_name, $vhost_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getHistoricVHostStatisticsAsyncWithHttpInfo
     *
     * Retrieves the historic VHost statistics
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoricVHostStatisticsAsyncWithHttpInfo($server_name, $vhost_name)
    {
        $returnType = '\Swagger\Client\Model\HistoricVHostStatistics';
        $request = $this->getHistoricVHostStatisticsRequest($server_name, $vhost_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getHistoricVHostStatistics'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getHistoricVHostStatisticsRequest($server_name, $vhost_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getHistoricVHostStatistics'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getHistoricVHostStatistics'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/monitoring/historic';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getHostPortConfig
     *
     * Retrieves the HostPort for the specifed vhost and port
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $portname The port name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\HostPortConfig
     */
    public function getHostPortConfig($server_name, $vhost_name, $portname)
    {
        list($response) = $this->getHostPortConfigWithHttpInfo($server_name, $vhost_name, $portname);
        return $response;
    }

    /**
     * Operation getHostPortConfigWithHttpInfo
     *
     * Retrieves the HostPort for the specifed vhost and port
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $portname The port name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\HostPortConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getHostPortConfigWithHttpInfo($server_name, $vhost_name, $portname)
    {
        $returnType = '\Swagger\Client\Model\HostPortConfig';
        $request = $this->getHostPortConfigRequest($server_name, $vhost_name, $portname);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\HostPortConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getHostPortConfigAsync
     *
     * Retrieves the HostPort for the specifed vhost and port
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $portname The port name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHostPortConfigAsync($server_name, $vhost_name, $portname)
    {
        return $this->getHostPortConfigAsyncWithHttpInfo($server_name, $vhost_name, $portname)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getHostPortConfigAsyncWithHttpInfo
     *
     * Retrieves the HostPort for the specifed vhost and port
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $portname The port name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHostPortConfigAsyncWithHttpInfo($server_name, $vhost_name, $portname)
    {
        $returnType = '\Swagger\Client\Model\HostPortConfig';
        $request = $this->getHostPortConfigRequest($server_name, $vhost_name, $portname);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getHostPortConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $portname The port name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getHostPortConfigRequest($server_name, $vhost_name, $portname)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getHostPortConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getHostPortConfig'
            );
        }
        // verify the required parameter 'portname' is set
        if ($portname === null || (is_array($portname) && count($portname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $portname when calling getHostPortConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/hostports/{portname}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($portname !== null) {
            $resourcePath = str_replace(
                '{' . 'portname' . '}',
                ObjectSerializer::toPathValue($portname),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getHostPortConfigAdv
     *
     * Retrieves the advanced HostPort configuration for the specified vhost and port
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $portname The port name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\HostPortConfigAdv
     */
    public function getHostPortConfigAdv($server_name, $vhost_name, $portname)
    {
        list($response) = $this->getHostPortConfigAdvWithHttpInfo($server_name, $vhost_name, $portname);
        return $response;
    }

    /**
     * Operation getHostPortConfigAdvWithHttpInfo
     *
     * Retrieves the advanced HostPort configuration for the specified vhost and port
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $portname The port name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\HostPortConfigAdv, HTTP status code, HTTP response headers (array of strings)
     */
    public function getHostPortConfigAdvWithHttpInfo($server_name, $vhost_name, $portname)
    {
        $returnType = '\Swagger\Client\Model\HostPortConfigAdv';
        $request = $this->getHostPortConfigAdvRequest($server_name, $vhost_name, $portname);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\HostPortConfigAdv',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getHostPortConfigAdvAsync
     *
     * Retrieves the advanced HostPort configuration for the specified vhost and port
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $portname The port name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHostPortConfigAdvAsync($server_name, $vhost_name, $portname)
    {
        return $this->getHostPortConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $portname)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getHostPortConfigAdvAsyncWithHttpInfo
     *
     * Retrieves the advanced HostPort configuration for the specified vhost and port
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $portname The port name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHostPortConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $portname)
    {
        $returnType = '\Swagger\Client\Model\HostPortConfigAdv';
        $request = $this->getHostPortConfigAdvRequest($server_name, $vhost_name, $portname);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getHostPortConfigAdv'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $portname The port name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getHostPortConfigAdvRequest($server_name, $vhost_name, $portname)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getHostPortConfigAdv'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getHostPortConfigAdv'
            );
        }
        // verify the required parameter 'portname' is set
        if ($portname === null || (is_array($portname) && count($portname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $portname when calling getHostPortConfigAdv'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/hostports/{portname}/adv';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($portname !== null) {
            $resourcePath = str_replace(
                '{' . 'portname' . '}',
                ObjectSerializer::toPathValue($portname),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getHostPortsConfig
     *
     * Retrieves the list of server HostPorts for the specified vhost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\HostPortsConfig
     */
    public function getHostPortsConfig($server_name, $vhost_name)
    {
        list($response) = $this->getHostPortsConfigWithHttpInfo($server_name, $vhost_name);
        return $response;
    }

    /**
     * Operation getHostPortsConfigWithHttpInfo
     *
     * Retrieves the list of server HostPorts for the specified vhost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\HostPortsConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getHostPortsConfigWithHttpInfo($server_name, $vhost_name)
    {
        $returnType = '\Swagger\Client\Model\HostPortsConfig';
        $request = $this->getHostPortsConfigRequest($server_name, $vhost_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\HostPortsConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getHostPortsConfigAsync
     *
     * Retrieves the list of server HostPorts for the specified vhost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHostPortsConfigAsync($server_name, $vhost_name)
    {
        return $this->getHostPortsConfigAsyncWithHttpInfo($server_name, $vhost_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getHostPortsConfigAsyncWithHttpInfo
     *
     * Retrieves the list of server HostPorts for the specified vhost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHostPortsConfigAsyncWithHttpInfo($server_name, $vhost_name)
    {
        $returnType = '\Swagger\Client\Model\HostPortsConfig';
        $request = $this->getHostPortsConfigRequest($server_name, $vhost_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getHostPortsConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getHostPortsConfigRequest($server_name, $vhost_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getHostPortsConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getHostPortsConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/hostports';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getHostportsTuneConfig
     *
     * Retrieves the host port configuration used for server tuning for the specified vhost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\HostportsTuneConfig
     */
    public function getHostportsTuneConfig($server_name, $vhost_name)
    {
        list($response) = $this->getHostportsTuneConfigWithHttpInfo($server_name, $vhost_name);
        return $response;
    }

    /**
     * Operation getHostportsTuneConfigWithHttpInfo
     *
     * Retrieves the host port configuration used for server tuning for the specified vhost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\HostportsTuneConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getHostportsTuneConfigWithHttpInfo($server_name, $vhost_name)
    {
        $returnType = '\Swagger\Client\Model\HostportsTuneConfig';
        $request = $this->getHostportsTuneConfigRequest($server_name, $vhost_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\HostportsTuneConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getHostportsTuneConfigAsync
     *
     * Retrieves the host port configuration used for server tuning for the specified vhost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHostportsTuneConfigAsync($server_name, $vhost_name)
    {
        return $this->getHostportsTuneConfigAsyncWithHttpInfo($server_name, $vhost_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getHostportsTuneConfigAsyncWithHttpInfo
     *
     * Retrieves the host port configuration used for server tuning for the specified vhost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHostportsTuneConfigAsyncWithHttpInfo($server_name, $vhost_name)
    {
        $returnType = '\Swagger\Client\Model\HostportsTuneConfig';
        $request = $this->getHostportsTuneConfigRequest($server_name, $vhost_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getHostportsTuneConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getHostportsTuneConfigRequest($server_name, $vhost_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getHostportsTuneConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getHostportsTuneConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/tunehostports';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMediaCacheStoreList
     *
     * Retrieves all entries in the MediaCache system
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\MediaCacheStoreList
     */
    public function getMediaCacheStoreList($server_name, $vhost_name)
    {
        list($response) = $this->getMediaCacheStoreListWithHttpInfo($server_name, $vhost_name);
        return $response;
    }

    /**
     * Operation getMediaCacheStoreListWithHttpInfo
     *
     * Retrieves all entries in the MediaCache system
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\MediaCacheStoreList, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMediaCacheStoreListWithHttpInfo($server_name, $vhost_name)
    {
        $returnType = '\Swagger\Client\Model\MediaCacheStoreList';
        $request = $this->getMediaCacheStoreListRequest($server_name, $vhost_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\MediaCacheStoreList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMediaCacheStoreListAsync
     *
     * Retrieves all entries in the MediaCache system
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMediaCacheStoreListAsync($server_name, $vhost_name)
    {
        return $this->getMediaCacheStoreListAsyncWithHttpInfo($server_name, $vhost_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMediaCacheStoreListAsyncWithHttpInfo
     *
     * Retrieves all entries in the MediaCache system
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMediaCacheStoreListAsyncWithHttpInfo($server_name, $vhost_name)
    {
        $returnType = '\Swagger\Client\Model\MediaCacheStoreList';
        $request = $this->getMediaCacheStoreListRequest($server_name, $vhost_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMediaCacheStoreList'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMediaCacheStoreListRequest($server_name, $vhost_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getMediaCacheStoreList'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getMediaCacheStoreList'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/mediacache/stores';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPublisherVhostConfig
     *
     * Retrieves the specified Publisher configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PublisherVhostConfig
     */
    public function getPublisherVhostConfig($server_name, $vhost_name, $publisher_name)
    {
        list($response) = $this->getPublisherVhostConfigWithHttpInfo($server_name, $vhost_name, $publisher_name);
        return $response;
    }

    /**
     * Operation getPublisherVhostConfigWithHttpInfo
     *
     * Retrieves the specified Publisher configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PublisherVhostConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPublisherVhostConfigWithHttpInfo($server_name, $vhost_name, $publisher_name)
    {
        $returnType = '\Swagger\Client\Model\PublisherVhostConfig';
        $request = $this->getPublisherVhostConfigRequest($server_name, $vhost_name, $publisher_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PublisherVhostConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPublisherVhostConfigAsync
     *
     * Retrieves the specified Publisher configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPublisherVhostConfigAsync($server_name, $vhost_name, $publisher_name)
    {
        return $this->getPublisherVhostConfigAsyncWithHttpInfo($server_name, $vhost_name, $publisher_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPublisherVhostConfigAsyncWithHttpInfo
     *
     * Retrieves the specified Publisher configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPublisherVhostConfigAsyncWithHttpInfo($server_name, $vhost_name, $publisher_name)
    {
        $returnType = '\Swagger\Client\Model\PublisherVhostConfig';
        $request = $this->getPublisherVhostConfigRequest($server_name, $vhost_name, $publisher_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPublisherVhostConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPublisherVhostConfigRequest($server_name, $vhost_name, $publisher_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getPublisherVhostConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getPublisherVhostConfig'
            );
        }
        // verify the required parameter 'publisher_name' is set
        if ($publisher_name === null || (is_array($publisher_name) && count($publisher_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $publisher_name when calling getPublisherVhostConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/publishers/{publisherName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($publisher_name !== null) {
            $resourcePath = str_replace(
                '{' . 'publisherName' . '}',
                ObjectSerializer::toPathValue($publisher_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPublishersVhostConfig
     *
     * Retrieves the list of Publishers for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PublishersVhostConfig
     */
    public function getPublishersVhostConfig($server_name, $vhost_name)
    {
        list($response) = $this->getPublishersVhostConfigWithHttpInfo($server_name, $vhost_name);
        return $response;
    }

    /**
     * Operation getPublishersVhostConfigWithHttpInfo
     *
     * Retrieves the list of Publishers for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PublishersVhostConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPublishersVhostConfigWithHttpInfo($server_name, $vhost_name)
    {
        $returnType = '\Swagger\Client\Model\PublishersVhostConfig';
        $request = $this->getPublishersVhostConfigRequest($server_name, $vhost_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PublishersVhostConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPublishersVhostConfigAsync
     *
     * Retrieves the list of Publishers for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPublishersVhostConfigAsync($server_name, $vhost_name)
    {
        return $this->getPublishersVhostConfigAsyncWithHttpInfo($server_name, $vhost_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPublishersVhostConfigAsyncWithHttpInfo
     *
     * Retrieves the list of Publishers for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPublishersVhostConfigAsyncWithHttpInfo($server_name, $vhost_name)
    {
        $returnType = '\Swagger\Client\Model\PublishersVhostConfig';
        $request = $this->getPublishersVhostConfigRequest($server_name, $vhost_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPublishersVhostConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPublishersVhostConfigRequest($server_name, $vhost_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getPublishersVhostConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getPublishersVhostConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/publishers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSDPFilesConfig
     *
     * Retrieves the list of SDP Files for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\SDPFilesConfig
     */
    public function getSDPFilesConfig($server_name, $vhost_name)
    {
        list($response) = $this->getSDPFilesConfigWithHttpInfo($server_name, $vhost_name);
        return $response;
    }

    /**
     * Operation getSDPFilesConfigWithHttpInfo
     *
     * Retrieves the list of SDP Files for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\SDPFilesConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSDPFilesConfigWithHttpInfo($server_name, $vhost_name)
    {
        $returnType = '\Swagger\Client\Model\SDPFilesConfig';
        $request = $this->getSDPFilesConfigRequest($server_name, $vhost_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\SDPFilesConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSDPFilesConfigAsync
     *
     * Retrieves the list of SDP Files for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSDPFilesConfigAsync($server_name, $vhost_name)
    {
        return $this->getSDPFilesConfigAsyncWithHttpInfo($server_name, $vhost_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSDPFilesConfigAsyncWithHttpInfo
     *
     * Retrieves the list of SDP Files for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSDPFilesConfigAsyncWithHttpInfo($server_name, $vhost_name)
    {
        $returnType = '\Swagger\Client\Model\SDPFilesConfig';
        $request = $this->getSDPFilesConfigRequest($server_name, $vhost_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSDPFilesConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSDPFilesConfigRequest($server_name, $vhost_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getSDPFilesConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getSDPFilesConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/sdpfiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSMILFileConfig
     *
     * Retrieves the specified SMIL File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\SMILFileConfig
     */
    public function getSMILFileConfig($server_name, $vhost_name, $smilfile_name)
    {
        list($response) = $this->getSMILFileConfigWithHttpInfo($server_name, $vhost_name, $smilfile_name);
        return $response;
    }

    /**
     * Operation getSMILFileConfigWithHttpInfo
     *
     * Retrieves the specified SMIL File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\SMILFileConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSMILFileConfigWithHttpInfo($server_name, $vhost_name, $smilfile_name)
    {
        $returnType = '\Swagger\Client\Model\SMILFileConfig';
        $request = $this->getSMILFileConfigRequest($server_name, $vhost_name, $smilfile_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\SMILFileConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSMILFileConfigAsync
     *
     * Retrieves the specified SMIL File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSMILFileConfigAsync($server_name, $vhost_name, $smilfile_name)
    {
        return $this->getSMILFileConfigAsyncWithHttpInfo($server_name, $vhost_name, $smilfile_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSMILFileConfigAsyncWithHttpInfo
     *
     * Retrieves the specified SMIL File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSMILFileConfigAsyncWithHttpInfo($server_name, $vhost_name, $smilfile_name)
    {
        $returnType = '\Swagger\Client\Model\SMILFileConfig';
        $request = $this->getSMILFileConfigRequest($server_name, $vhost_name, $smilfile_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSMILFileConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSMILFileConfigRequest($server_name, $vhost_name, $smilfile_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getSMILFileConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getSMILFileConfig'
            );
        }
        // verify the required parameter 'smilfile_name' is set
        if ($smilfile_name === null || (is_array($smilfile_name) && count($smilfile_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $smilfile_name when calling getSMILFileConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/smilfiles/{smilfileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($smilfile_name !== null) {
            $resourcePath = str_replace(
                '{' . 'smilfileName' . '}',
                ObjectSerializer::toPathValue($smilfile_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSMILFilesConfig
     *
     * Retrieves the list of SMIL Files for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\SMILFilesConfig
     */
    public function getSMILFilesConfig($server_name, $vhost_name)
    {
        list($response) = $this->getSMILFilesConfigWithHttpInfo($server_name, $vhost_name);
        return $response;
    }

    /**
     * Operation getSMILFilesConfigWithHttpInfo
     *
     * Retrieves the list of SMIL Files for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\SMILFilesConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSMILFilesConfigWithHttpInfo($server_name, $vhost_name)
    {
        $returnType = '\Swagger\Client\Model\SMILFilesConfig';
        $request = $this->getSMILFilesConfigRequest($server_name, $vhost_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\SMILFilesConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSMILFilesConfigAsync
     *
     * Retrieves the list of SMIL Files for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSMILFilesConfigAsync($server_name, $vhost_name)
    {
        return $this->getSMILFilesConfigAsyncWithHttpInfo($server_name, $vhost_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSMILFilesConfigAsyncWithHttpInfo
     *
     * Retrieves the list of SMIL Files for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSMILFilesConfigAsyncWithHttpInfo($server_name, $vhost_name)
    {
        $returnType = '\Swagger\Client\Model\SMILFilesConfig';
        $request = $this->getSMILFilesConfigRequest($server_name, $vhost_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSMILFilesConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSMILFilesConfigRequest($server_name, $vhost_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getSMILFilesConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getSMILFilesConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/smilfiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSSLConfig
     *
     * Retrieves the SSL configuration for the specified vhost and port
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $portname The port name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\SSLConfig
     */
    public function getSSLConfig($server_name, $vhost_name, $portname)
    {
        list($response) = $this->getSSLConfigWithHttpInfo($server_name, $vhost_name, $portname);
        return $response;
    }

    /**
     * Operation getSSLConfigWithHttpInfo
     *
     * Retrieves the SSL configuration for the specified vhost and port
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $portname The port name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\SSLConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSSLConfigWithHttpInfo($server_name, $vhost_name, $portname)
    {
        $returnType = '\Swagger\Client\Model\SSLConfig';
        $request = $this->getSSLConfigRequest($server_name, $vhost_name, $portname);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\SSLConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSSLConfigAsync
     *
     * Retrieves the SSL configuration for the specified vhost and port
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $portname The port name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSSLConfigAsync($server_name, $vhost_name, $portname)
    {
        return $this->getSSLConfigAsyncWithHttpInfo($server_name, $vhost_name, $portname)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSSLConfigAsyncWithHttpInfo
     *
     * Retrieves the SSL configuration for the specified vhost and port
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $portname The port name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSSLConfigAsyncWithHttpInfo($server_name, $vhost_name, $portname)
    {
        $returnType = '\Swagger\Client\Model\SSLConfig';
        $request = $this->getSSLConfigRequest($server_name, $vhost_name, $portname);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSSLConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $portname The port name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSSLConfigRequest($server_name, $vhost_name, $portname)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getSSLConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getSSLConfig'
            );
        }
        // verify the required parameter 'portname' is set
        if ($portname === null || (is_array($portname) && count($portname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $portname when calling getSSLConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/hostports/{portname}/ssl';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($portname !== null) {
            $resourcePath = str_replace(
                '{' . 'portname' . '}',
                ObjectSerializer::toPathValue($portname),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStartupStreamConfig
     *
     * Retrieves the specified Startup Stream configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $stream_name stream_name (required)
     * @param  string $app_name app_name (required)
     * @param  string $instance_name instance_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\StartupStreamConfig
     */
    public function getStartupStreamConfig($server_name, $vhost_name, $stream_name, $app_name, $instance_name)
    {
        list($response) = $this->getStartupStreamConfigWithHttpInfo($server_name, $vhost_name, $stream_name, $app_name, $instance_name);
        return $response;
    }

    /**
     * Operation getStartupStreamConfigWithHttpInfo
     *
     * Retrieves the specified Startup Stream configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $stream_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\StartupStreamConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStartupStreamConfigWithHttpInfo($server_name, $vhost_name, $stream_name, $app_name, $instance_name)
    {
        $returnType = '\Swagger\Client\Model\StartupStreamConfig';
        $request = $this->getStartupStreamConfigRequest($server_name, $vhost_name, $stream_name, $app_name, $instance_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\StartupStreamConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStartupStreamConfigAsync
     *
     * Retrieves the specified Startup Stream configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $stream_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStartupStreamConfigAsync($server_name, $vhost_name, $stream_name, $app_name, $instance_name)
    {
        return $this->getStartupStreamConfigAsyncWithHttpInfo($server_name, $vhost_name, $stream_name, $app_name, $instance_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStartupStreamConfigAsyncWithHttpInfo
     *
     * Retrieves the specified Startup Stream configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $stream_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStartupStreamConfigAsyncWithHttpInfo($server_name, $vhost_name, $stream_name, $app_name, $instance_name)
    {
        $returnType = '\Swagger\Client\Model\StartupStreamConfig';
        $request = $this->getStartupStreamConfigRequest($server_name, $vhost_name, $stream_name, $app_name, $instance_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStartupStreamConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $stream_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStartupStreamConfigRequest($server_name, $vhost_name, $stream_name, $app_name, $instance_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getStartupStreamConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getStartupStreamConfig'
            );
        }
        // verify the required parameter 'stream_name' is set
        if ($stream_name === null || (is_array($stream_name) && count($stream_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stream_name when calling getStartupStreamConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getStartupStreamConfig'
            );
        }
        // verify the required parameter 'instance_name' is set
        if ($instance_name === null || (is_array($instance_name) && count($instance_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_name when calling getStartupStreamConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/startupstreams/applications/{appName}/instances/{instanceName}/streams/{streamName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($stream_name !== null) {
            $resourcePath = str_replace(
                '{' . 'streamName' . '}',
                ObjectSerializer::toPathValue($stream_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($instance_name !== null) {
            $resourcePath = str_replace(
                '{' . 'instanceName' . '}',
                ObjectSerializer::toPathValue($instance_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStartupStreamsConfig
     *
     * Retrieves the list of Startup Streams for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\StartupStreamsConfig
     */
    public function getStartupStreamsConfig($server_name, $vhost_name)
    {
        list($response) = $this->getStartupStreamsConfigWithHttpInfo($server_name, $vhost_name);
        return $response;
    }

    /**
     * Operation getStartupStreamsConfigWithHttpInfo
     *
     * Retrieves the list of Startup Streams for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\StartupStreamsConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStartupStreamsConfigWithHttpInfo($server_name, $vhost_name)
    {
        $returnType = '\Swagger\Client\Model\StartupStreamsConfig';
        $request = $this->getStartupStreamsConfigRequest($server_name, $vhost_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\StartupStreamsConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStartupStreamsConfigAsync
     *
     * Retrieves the list of Startup Streams for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStartupStreamsConfigAsync($server_name, $vhost_name)
    {
        return $this->getStartupStreamsConfigAsyncWithHttpInfo($server_name, $vhost_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStartupStreamsConfigAsyncWithHttpInfo
     *
     * Retrieves the list of Startup Streams for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStartupStreamsConfigAsyncWithHttpInfo($server_name, $vhost_name)
    {
        $returnType = '\Swagger\Client\Model\StartupStreamsConfig';
        $request = $this->getStartupStreamsConfigRequest($server_name, $vhost_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStartupStreamsConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStartupStreamsConfigRequest($server_name, $vhost_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getStartupStreamsConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getStartupStreamsConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/startupstreams';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStreamFileConfig
     *
     * Retrieves the specified Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\StreamFileConfig
     */
    public function getStreamFileConfig($server_name, $vhost_name, $streamfile_name)
    {
        list($response) = $this->getStreamFileConfigWithHttpInfo($server_name, $vhost_name, $streamfile_name);
        return $response;
    }

    /**
     * Operation getStreamFileConfigWithHttpInfo
     *
     * Retrieves the specified Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\StreamFileConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStreamFileConfigWithHttpInfo($server_name, $vhost_name, $streamfile_name)
    {
        $returnType = '\Swagger\Client\Model\StreamFileConfig';
        $request = $this->getStreamFileConfigRequest($server_name, $vhost_name, $streamfile_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\StreamFileConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStreamFileConfigAsync
     *
     * Retrieves the specified Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStreamFileConfigAsync($server_name, $vhost_name, $streamfile_name)
    {
        return $this->getStreamFileConfigAsyncWithHttpInfo($server_name, $vhost_name, $streamfile_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStreamFileConfigAsyncWithHttpInfo
     *
     * Retrieves the specified Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStreamFileConfigAsyncWithHttpInfo($server_name, $vhost_name, $streamfile_name)
    {
        $returnType = '\Swagger\Client\Model\StreamFileConfig';
        $request = $this->getStreamFileConfigRequest($server_name, $vhost_name, $streamfile_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStreamFileConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStreamFileConfigRequest($server_name, $vhost_name, $streamfile_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getStreamFileConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getStreamFileConfig'
            );
        }
        // verify the required parameter 'streamfile_name' is set
        if ($streamfile_name === null || (is_array($streamfile_name) && count($streamfile_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $streamfile_name when calling getStreamFileConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/streamfiles/{streamfileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($streamfile_name !== null) {
            $resourcePath = str_replace(
                '{' . 'streamfileName' . '}',
                ObjectSerializer::toPathValue($streamfile_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStreamFileConfigAdv
     *
     * Retrieves the Advanced Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $streamfile_name The stream file name without the .stream extension (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\StreamFileConfigAdv
     */
    public function getStreamFileConfigAdv($server_name, $vhost_name, $streamfile_name)
    {
        list($response) = $this->getStreamFileConfigAdvWithHttpInfo($server_name, $vhost_name, $streamfile_name);
        return $response;
    }

    /**
     * Operation getStreamFileConfigAdvWithHttpInfo
     *
     * Retrieves the Advanced Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the .stream extension (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\StreamFileConfigAdv, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStreamFileConfigAdvWithHttpInfo($server_name, $vhost_name, $streamfile_name)
    {
        $returnType = '\Swagger\Client\Model\StreamFileConfigAdv';
        $request = $this->getStreamFileConfigAdvRequest($server_name, $vhost_name, $streamfile_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\StreamFileConfigAdv',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStreamFileConfigAdvAsync
     *
     * Retrieves the Advanced Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the .stream extension (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStreamFileConfigAdvAsync($server_name, $vhost_name, $streamfile_name)
    {
        return $this->getStreamFileConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $streamfile_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStreamFileConfigAdvAsyncWithHttpInfo
     *
     * Retrieves the Advanced Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the .stream extension (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStreamFileConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $streamfile_name)
    {
        $returnType = '\Swagger\Client\Model\StreamFileConfigAdv';
        $request = $this->getStreamFileConfigAdvRequest($server_name, $vhost_name, $streamfile_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStreamFileConfigAdv'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the .stream extension (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStreamFileConfigAdvRequest($server_name, $vhost_name, $streamfile_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getStreamFileConfigAdv'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getStreamFileConfigAdv'
            );
        }
        // verify the required parameter 'streamfile_name' is set
        if ($streamfile_name === null || (is_array($streamfile_name) && count($streamfile_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $streamfile_name when calling getStreamFileConfigAdv'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/streamfiles/{streamfileName}/adv';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($streamfile_name !== null) {
            $resourcePath = str_replace(
                '{' . 'streamfileName' . '}',
                ObjectSerializer::toPathValue($streamfile_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStreamFilesConfig
     *
     * Retrieves the list of Stream Files for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\StreamFilesConfig
     */
    public function getStreamFilesConfig($server_name, $vhost_name)
    {
        list($response) = $this->getStreamFilesConfigWithHttpInfo($server_name, $vhost_name);
        return $response;
    }

    /**
     * Operation getStreamFilesConfigWithHttpInfo
     *
     * Retrieves the list of Stream Files for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\StreamFilesConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStreamFilesConfigWithHttpInfo($server_name, $vhost_name)
    {
        $returnType = '\Swagger\Client\Model\StreamFilesConfig';
        $request = $this->getStreamFilesConfigRequest($server_name, $vhost_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\StreamFilesConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStreamFilesConfigAsync
     *
     * Retrieves the list of Stream Files for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStreamFilesConfigAsync($server_name, $vhost_name)
    {
        return $this->getStreamFilesConfigAsyncWithHttpInfo($server_name, $vhost_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStreamFilesConfigAsyncWithHttpInfo
     *
     * Retrieves the list of Stream Files for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStreamFilesConfigAsyncWithHttpInfo($server_name, $vhost_name)
    {
        $returnType = '\Swagger\Client\Model\StreamFilesConfig';
        $request = $this->getStreamFilesConfigRequest($server_name, $vhost_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStreamFilesConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStreamFilesConfigRequest($server_name, $vhost_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getStreamFilesConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getStreamFilesConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/streamfiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTranscoderConfig
     *
     * Retrieves the Transcoder configuration for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TranscoderConfig
     */
    public function getTranscoderConfig($server_name, $vhost_name)
    {
        list($response) = $this->getTranscoderConfigWithHttpInfo($server_name, $vhost_name);
        return $response;
    }

    /**
     * Operation getTranscoderConfigWithHttpInfo
     *
     * Retrieves the Transcoder configuration for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TranscoderConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTranscoderConfigWithHttpInfo($server_name, $vhost_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderConfig';
        $request = $this->getTranscoderConfigRequest($server_name, $vhost_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TranscoderConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTranscoderConfigAsync
     *
     * Retrieves the Transcoder configuration for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderConfigAsync($server_name, $vhost_name)
    {
        return $this->getTranscoderConfigAsyncWithHttpInfo($server_name, $vhost_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTranscoderConfigAsyncWithHttpInfo
     *
     * Retrieves the Transcoder configuration for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderConfigAsyncWithHttpInfo($server_name, $vhost_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderConfig';
        $request = $this->getTranscoderConfigRequest($server_name, $vhost_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTranscoderConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTranscoderConfigRequest($server_name, $vhost_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getTranscoderConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getTranscoderConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/transcoder';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTranscoderEncodeConfig
     *
     * Retrieves the specified Trancoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $encode_name encode_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TranscoderEncodeConfig
     */
    public function getTranscoderEncodeConfig($server_name, $vhost_name, $template_name, $encode_name)
    {
        list($response) = $this->getTranscoderEncodeConfigWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name);
        return $response;
    }

    /**
     * Operation getTranscoderEncodeConfigWithHttpInfo
     *
     * Retrieves the specified Trancoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TranscoderEncodeConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTranscoderEncodeConfigWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderEncodeConfig';
        $request = $this->getTranscoderEncodeConfigRequest($server_name, $vhost_name, $template_name, $encode_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TranscoderEncodeConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTranscoderEncodeConfigAsync
     *
     * Retrieves the specified Trancoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderEncodeConfigAsync($server_name, $vhost_name, $template_name, $encode_name)
    {
        return $this->getTranscoderEncodeConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTranscoderEncodeConfigAsyncWithHttpInfo
     *
     * Retrieves the specified Trancoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderEncodeConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderEncodeConfig';
        $request = $this->getTranscoderEncodeConfigRequest($server_name, $vhost_name, $template_name, $encode_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTranscoderEncodeConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTranscoderEncodeConfigRequest($server_name, $vhost_name, $template_name, $encode_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getTranscoderEncodeConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getTranscoderEncodeConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling getTranscoderEncodeConfig'
            );
        }
        // verify the required parameter 'encode_name' is set
        if ($encode_name === null || (is_array($encode_name) && count($encode_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $encode_name when calling getTranscoderEncodeConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/transcoder/templates/{templateName}/encodes/{encodeName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($encode_name !== null) {
            $resourcePath = str_replace(
                '{' . 'encodeName' . '}',
                ObjectSerializer::toPathValue($encode_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTranscoderEncodeConfigAdv
     *
     * Retrieves the Advanced Transcoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $encode_name encode_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TranscoderEncodeConfigAdv
     */
    public function getTranscoderEncodeConfigAdv($server_name, $vhost_name, $template_name, $encode_name)
    {
        list($response) = $this->getTranscoderEncodeConfigAdvWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name);
        return $response;
    }

    /**
     * Operation getTranscoderEncodeConfigAdvWithHttpInfo
     *
     * Retrieves the Advanced Transcoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TranscoderEncodeConfigAdv, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTranscoderEncodeConfigAdvWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderEncodeConfigAdv';
        $request = $this->getTranscoderEncodeConfigAdvRequest($server_name, $vhost_name, $template_name, $encode_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TranscoderEncodeConfigAdv',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTranscoderEncodeConfigAdvAsync
     *
     * Retrieves the Advanced Transcoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderEncodeConfigAdvAsync($server_name, $vhost_name, $template_name, $encode_name)
    {
        return $this->getTranscoderEncodeConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTranscoderEncodeConfigAdvAsyncWithHttpInfo
     *
     * Retrieves the Advanced Transcoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderEncodeConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderEncodeConfigAdv';
        $request = $this->getTranscoderEncodeConfigAdvRequest($server_name, $vhost_name, $template_name, $encode_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTranscoderEncodeConfigAdv'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTranscoderEncodeConfigAdvRequest($server_name, $vhost_name, $template_name, $encode_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getTranscoderEncodeConfigAdv'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getTranscoderEncodeConfigAdv'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling getTranscoderEncodeConfigAdv'
            );
        }
        // verify the required parameter 'encode_name' is set
        if ($encode_name === null || (is_array($encode_name) && count($encode_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $encode_name when calling getTranscoderEncodeConfigAdv'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/transcoder/templates/{templateName}/encodes/{encodeName}/adv';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($encode_name !== null) {
            $resourcePath = str_replace(
                '{' . 'encodeName' . '}',
                ObjectSerializer::toPathValue($encode_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTranscoderEncodesConfig
     *
     * Retrieves the list of Transcoder Encode Configurations for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TranscoderEncodesConfig
     */
    public function getTranscoderEncodesConfig($server_name, $vhost_name, $template_name)
    {
        list($response) = $this->getTranscoderEncodesConfigWithHttpInfo($server_name, $vhost_name, $template_name);
        return $response;
    }

    /**
     * Operation getTranscoderEncodesConfigWithHttpInfo
     *
     * Retrieves the list of Transcoder Encode Configurations for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TranscoderEncodesConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTranscoderEncodesConfigWithHttpInfo($server_name, $vhost_name, $template_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderEncodesConfig';
        $request = $this->getTranscoderEncodesConfigRequest($server_name, $vhost_name, $template_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TranscoderEncodesConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTranscoderEncodesConfigAsync
     *
     * Retrieves the list of Transcoder Encode Configurations for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderEncodesConfigAsync($server_name, $vhost_name, $template_name)
    {
        return $this->getTranscoderEncodesConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTranscoderEncodesConfigAsyncWithHttpInfo
     *
     * Retrieves the list of Transcoder Encode Configurations for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderEncodesConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderEncodesConfig';
        $request = $this->getTranscoderEncodesConfigRequest($server_name, $vhost_name, $template_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTranscoderEncodesConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTranscoderEncodesConfigRequest($server_name, $vhost_name, $template_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getTranscoderEncodesConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getTranscoderEncodesConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling getTranscoderEncodesConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/transcoder/templates/{templateName}/encodes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTranscoderOverlayDecodeConfig
     *
     * Retrieves the specified Trancoder Overlay Decode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $overlay_name overlay_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TranscoderOverlayDecodeConfig
     */
    public function getTranscoderOverlayDecodeConfig($server_name, $vhost_name, $template_name, $overlay_name)
    {
        list($response) = $this->getTranscoderOverlayDecodeConfigWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name);
        return $response;
    }

    /**
     * Operation getTranscoderOverlayDecodeConfigWithHttpInfo
     *
     * Retrieves the specified Trancoder Overlay Decode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TranscoderOverlayDecodeConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTranscoderOverlayDecodeConfigWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderOverlayDecodeConfig';
        $request = $this->getTranscoderOverlayDecodeConfigRequest($server_name, $vhost_name, $template_name, $overlay_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TranscoderOverlayDecodeConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTranscoderOverlayDecodeConfigAsync
     *
     * Retrieves the specified Trancoder Overlay Decode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderOverlayDecodeConfigAsync($server_name, $vhost_name, $template_name, $overlay_name)
    {
        return $this->getTranscoderOverlayDecodeConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTranscoderOverlayDecodeConfigAsyncWithHttpInfo
     *
     * Retrieves the specified Trancoder Overlay Decode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderOverlayDecodeConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderOverlayDecodeConfig';
        $request = $this->getTranscoderOverlayDecodeConfigRequest($server_name, $vhost_name, $template_name, $overlay_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTranscoderOverlayDecodeConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTranscoderOverlayDecodeConfigRequest($server_name, $vhost_name, $template_name, $overlay_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getTranscoderOverlayDecodeConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getTranscoderOverlayDecodeConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling getTranscoderOverlayDecodeConfig'
            );
        }
        // verify the required parameter 'overlay_name' is set
        if ($overlay_name === null || (is_array($overlay_name) && count($overlay_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $overlay_name when calling getTranscoderOverlayDecodeConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/transcoder/templates/{templateName}/decode/overlays/{overlayName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($overlay_name !== null) {
            $resourcePath = str_replace(
                '{' . 'overlayName' . '}',
                ObjectSerializer::toPathValue($overlay_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTranscoderOverlayEncodeConfig
     *
     * Retrieves the specified Trancoder Overlay Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $overlay_name overlay_name (required)
     * @param  string $encode_name encode_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TranscoderOverlayEncodeConfig
     */
    public function getTranscoderOverlayEncodeConfig($server_name, $vhost_name, $template_name, $overlay_name, $encode_name)
    {
        list($response) = $this->getTranscoderOverlayEncodeConfigWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $encode_name);
        return $response;
    }

    /**
     * Operation getTranscoderOverlayEncodeConfigWithHttpInfo
     *
     * Retrieves the specified Trancoder Overlay Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $encode_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TranscoderOverlayEncodeConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTranscoderOverlayEncodeConfigWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $encode_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderOverlayEncodeConfig';
        $request = $this->getTranscoderOverlayEncodeConfigRequest($server_name, $vhost_name, $template_name, $overlay_name, $encode_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TranscoderOverlayEncodeConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTranscoderOverlayEncodeConfigAsync
     *
     * Retrieves the specified Trancoder Overlay Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $encode_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderOverlayEncodeConfigAsync($server_name, $vhost_name, $template_name, $overlay_name, $encode_name)
    {
        return $this->getTranscoderOverlayEncodeConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $encode_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTranscoderOverlayEncodeConfigAsyncWithHttpInfo
     *
     * Retrieves the specified Trancoder Overlay Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $encode_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderOverlayEncodeConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $encode_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderOverlayEncodeConfig';
        $request = $this->getTranscoderOverlayEncodeConfigRequest($server_name, $vhost_name, $template_name, $overlay_name, $encode_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTranscoderOverlayEncodeConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $encode_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTranscoderOverlayEncodeConfigRequest($server_name, $vhost_name, $template_name, $overlay_name, $encode_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getTranscoderOverlayEncodeConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getTranscoderOverlayEncodeConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling getTranscoderOverlayEncodeConfig'
            );
        }
        // verify the required parameter 'overlay_name' is set
        if ($overlay_name === null || (is_array($overlay_name) && count($overlay_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $overlay_name when calling getTranscoderOverlayEncodeConfig'
            );
        }
        // verify the required parameter 'encode_name' is set
        if ($encode_name === null || (is_array($encode_name) && count($encode_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $encode_name when calling getTranscoderOverlayEncodeConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/transcoder/templates/{templateName}/encodes/{encodeName}/overlays/{overlayName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($overlay_name !== null) {
            $resourcePath = str_replace(
                '{' . 'overlayName' . '}',
                ObjectSerializer::toPathValue($overlay_name),
                $resourcePath
            );
        }
        // path params
        if ($encode_name !== null) {
            $resourcePath = str_replace(
                '{' . 'encodeName' . '}',
                ObjectSerializer::toPathValue($encode_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTranscoderStreamNameGroupConfig
     *
     * Retrieves the specified Trancoder StreamNameGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $group_name group_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TranscoderStreamNameGroupConfig
     */
    public function getTranscoderStreamNameGroupConfig($server_name, $vhost_name, $template_name, $group_name)
    {
        list($response) = $this->getTranscoderStreamNameGroupConfigWithHttpInfo($server_name, $vhost_name, $template_name, $group_name);
        return $response;
    }

    /**
     * Operation getTranscoderStreamNameGroupConfigWithHttpInfo
     *
     * Retrieves the specified Trancoder StreamNameGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $group_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TranscoderStreamNameGroupConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTranscoderStreamNameGroupConfigWithHttpInfo($server_name, $vhost_name, $template_name, $group_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderStreamNameGroupConfig';
        $request = $this->getTranscoderStreamNameGroupConfigRequest($server_name, $vhost_name, $template_name, $group_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TranscoderStreamNameGroupConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTranscoderStreamNameGroupConfigAsync
     *
     * Retrieves the specified Trancoder StreamNameGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $group_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderStreamNameGroupConfigAsync($server_name, $vhost_name, $template_name, $group_name)
    {
        return $this->getTranscoderStreamNameGroupConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $group_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTranscoderStreamNameGroupConfigAsyncWithHttpInfo
     *
     * Retrieves the specified Trancoder StreamNameGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $group_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderStreamNameGroupConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $group_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderStreamNameGroupConfig';
        $request = $this->getTranscoderStreamNameGroupConfigRequest($server_name, $vhost_name, $template_name, $group_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTranscoderStreamNameGroupConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $group_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTranscoderStreamNameGroupConfigRequest($server_name, $vhost_name, $template_name, $group_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getTranscoderStreamNameGroupConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getTranscoderStreamNameGroupConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling getTranscoderStreamNameGroupConfig'
            );
        }
        // verify the required parameter 'group_name' is set
        if ($group_name === null || (is_array($group_name) && count($group_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_name when calling getTranscoderStreamNameGroupConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/transcoder/templates/{templateName}/streamnamegroups/{groupName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($group_name !== null) {
            $resourcePath = str_replace(
                '{' . 'groupName' . '}',
                ObjectSerializer::toPathValue($group_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTranscoderStreamNameGroupsConfig
     *
     * Retrieves the list of Transcoder Stream Name Groups for the specified Template
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TranscoderStreamNameGroupsConfig
     */
    public function getTranscoderStreamNameGroupsConfig($server_name, $vhost_name, $template_name)
    {
        list($response) = $this->getTranscoderStreamNameGroupsConfigWithHttpInfo($server_name, $vhost_name, $template_name);
        return $response;
    }

    /**
     * Operation getTranscoderStreamNameGroupsConfigWithHttpInfo
     *
     * Retrieves the list of Transcoder Stream Name Groups for the specified Template
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TranscoderStreamNameGroupsConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTranscoderStreamNameGroupsConfigWithHttpInfo($server_name, $vhost_name, $template_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderStreamNameGroupsConfig';
        $request = $this->getTranscoderStreamNameGroupsConfigRequest($server_name, $vhost_name, $template_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TranscoderStreamNameGroupsConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTranscoderStreamNameGroupsConfigAsync
     *
     * Retrieves the list of Transcoder Stream Name Groups for the specified Template
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderStreamNameGroupsConfigAsync($server_name, $vhost_name, $template_name)
    {
        return $this->getTranscoderStreamNameGroupsConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTranscoderStreamNameGroupsConfigAsyncWithHttpInfo
     *
     * Retrieves the list of Transcoder Stream Name Groups for the specified Template
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderStreamNameGroupsConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderStreamNameGroupsConfig';
        $request = $this->getTranscoderStreamNameGroupsConfigRequest($server_name, $vhost_name, $template_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTranscoderStreamNameGroupsConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTranscoderStreamNameGroupsConfigRequest($server_name, $vhost_name, $template_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getTranscoderStreamNameGroupsConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getTranscoderStreamNameGroupsConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling getTranscoderStreamNameGroupsConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/transcoder/templates/{templateName}/streamnamegroups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTranscoderTemplateConfig
     *
     * Retrieves the specified Trancoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TranscoderTemplateConfig
     */
    public function getTranscoderTemplateConfig($server_name, $vhost_name, $template_name)
    {
        list($response) = $this->getTranscoderTemplateConfigWithHttpInfo($server_name, $vhost_name, $template_name);
        return $response;
    }

    /**
     * Operation getTranscoderTemplateConfigWithHttpInfo
     *
     * Retrieves the specified Trancoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TranscoderTemplateConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTranscoderTemplateConfigWithHttpInfo($server_name, $vhost_name, $template_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderTemplateConfig';
        $request = $this->getTranscoderTemplateConfigRequest($server_name, $vhost_name, $template_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TranscoderTemplateConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTranscoderTemplateConfigAsync
     *
     * Retrieves the specified Trancoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderTemplateConfigAsync($server_name, $vhost_name, $template_name)
    {
        return $this->getTranscoderTemplateConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTranscoderTemplateConfigAsyncWithHttpInfo
     *
     * Retrieves the specified Trancoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderTemplateConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderTemplateConfig';
        $request = $this->getTranscoderTemplateConfigRequest($server_name, $vhost_name, $template_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTranscoderTemplateConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTranscoderTemplateConfigRequest($server_name, $vhost_name, $template_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getTranscoderTemplateConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getTranscoderTemplateConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling getTranscoderTemplateConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/transcoder/templates/{templateName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTranscoderTemplateConfigAdv
     *
     * Retrieves the Advanced Transcoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TranscoderTemplateConfigAdv
     */
    public function getTranscoderTemplateConfigAdv($server_name, $vhost_name, $template_name)
    {
        list($response) = $this->getTranscoderTemplateConfigAdvWithHttpInfo($server_name, $vhost_name, $template_name);
        return $response;
    }

    /**
     * Operation getTranscoderTemplateConfigAdvWithHttpInfo
     *
     * Retrieves the Advanced Transcoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TranscoderTemplateConfigAdv, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTranscoderTemplateConfigAdvWithHttpInfo($server_name, $vhost_name, $template_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderTemplateConfigAdv';
        $request = $this->getTranscoderTemplateConfigAdvRequest($server_name, $vhost_name, $template_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TranscoderTemplateConfigAdv',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTranscoderTemplateConfigAdvAsync
     *
     * Retrieves the Advanced Transcoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderTemplateConfigAdvAsync($server_name, $vhost_name, $template_name)
    {
        return $this->getTranscoderTemplateConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $template_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTranscoderTemplateConfigAdvAsyncWithHttpInfo
     *
     * Retrieves the Advanced Transcoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderTemplateConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $template_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderTemplateConfigAdv';
        $request = $this->getTranscoderTemplateConfigAdvRequest($server_name, $vhost_name, $template_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTranscoderTemplateConfigAdv'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTranscoderTemplateConfigAdvRequest($server_name, $vhost_name, $template_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getTranscoderTemplateConfigAdv'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getTranscoderTemplateConfigAdv'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling getTranscoderTemplateConfigAdv'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/transcoder/templates/{templateName}/adv';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTranscoderTemplatesConfig
     *
     * Retrieves the list of Transcoder Template Configurations for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TranscoderTemplatesConfig
     */
    public function getTranscoderTemplatesConfig($server_name, $vhost_name)
    {
        list($response) = $this->getTranscoderTemplatesConfigWithHttpInfo($server_name, $vhost_name);
        return $response;
    }

    /**
     * Operation getTranscoderTemplatesConfigWithHttpInfo
     *
     * Retrieves the list of Transcoder Template Configurations for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TranscoderTemplatesConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTranscoderTemplatesConfigWithHttpInfo($server_name, $vhost_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderTemplatesConfig';
        $request = $this->getTranscoderTemplatesConfigRequest($server_name, $vhost_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TranscoderTemplatesConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTranscoderTemplatesConfigAsync
     *
     * Retrieves the list of Transcoder Template Configurations for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderTemplatesConfigAsync($server_name, $vhost_name)
    {
        return $this->getTranscoderTemplatesConfigAsyncWithHttpInfo($server_name, $vhost_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTranscoderTemplatesConfigAsyncWithHttpInfo
     *
     * Retrieves the list of Transcoder Template Configurations for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderTemplatesConfigAsyncWithHttpInfo($server_name, $vhost_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderTemplatesConfig';
        $request = $this->getTranscoderTemplatesConfigRequest($server_name, $vhost_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTranscoderTemplatesConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTranscoderTemplatesConfigRequest($server_name, $vhost_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getTranscoderTemplatesConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getTranscoderTemplatesConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/transcoder/templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVHostConfig
     *
     * Retrieves the specified VHost configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\VHostConfig
     */
    public function getVHostConfig($server_name, $vhost_name)
    {
        list($response) = $this->getVHostConfigWithHttpInfo($server_name, $vhost_name);
        return $response;
    }

    /**
     * Operation getVHostConfigWithHttpInfo
     *
     * Retrieves the specified VHost configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\VHostConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVHostConfigWithHttpInfo($server_name, $vhost_name)
    {
        $returnType = '\Swagger\Client\Model\VHostConfig';
        $request = $this->getVHostConfigRequest($server_name, $vhost_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\VHostConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVHostConfigAsync
     *
     * Retrieves the specified VHost configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVHostConfigAsync($server_name, $vhost_name)
    {
        return $this->getVHostConfigAsyncWithHttpInfo($server_name, $vhost_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVHostConfigAsyncWithHttpInfo
     *
     * Retrieves the specified VHost configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVHostConfigAsyncWithHttpInfo($server_name, $vhost_name)
    {
        $returnType = '\Swagger\Client\Model\VHostConfig';
        $request = $this->getVHostConfigRequest($server_name, $vhost_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVHostConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVHostConfigRequest($server_name, $vhost_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getVHostConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getVHostConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVHostConfigAdv
     *
     * Retrieves the specified advanced VHost configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\VHostConfigAdv
     */
    public function getVHostConfigAdv($server_name, $vhost_name)
    {
        list($response) = $this->getVHostConfigAdvWithHttpInfo($server_name, $vhost_name);
        return $response;
    }

    /**
     * Operation getVHostConfigAdvWithHttpInfo
     *
     * Retrieves the specified advanced VHost configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\VHostConfigAdv, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVHostConfigAdvWithHttpInfo($server_name, $vhost_name)
    {
        $returnType = '\Swagger\Client\Model\VHostConfigAdv';
        $request = $this->getVHostConfigAdvRequest($server_name, $vhost_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\VHostConfigAdv',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVHostConfigAdvAsync
     *
     * Retrieves the specified advanced VHost configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVHostConfigAdvAsync($server_name, $vhost_name)
    {
        return $this->getVHostConfigAdvAsyncWithHttpInfo($server_name, $vhost_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVHostConfigAdvAsyncWithHttpInfo
     *
     * Retrieves the specified advanced VHost configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVHostConfigAdvAsyncWithHttpInfo($server_name, $vhost_name)
    {
        $returnType = '\Swagger\Client\Model\VHostConfigAdv';
        $request = $this->getVHostConfigAdvRequest($server_name, $vhost_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVHostConfigAdv'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVHostConfigAdvRequest($server_name, $vhost_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getVHostConfigAdv'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getVHostConfigAdv'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/adv';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVHostTuneConfig
     *
     * Retrieves the Tuning configuration for the specifed vhost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\VHostTuneConfig
     */
    public function getVHostTuneConfig($server_name, $vhost_name)
    {
        list($response) = $this->getVHostTuneConfigWithHttpInfo($server_name, $vhost_name);
        return $response;
    }

    /**
     * Operation getVHostTuneConfigWithHttpInfo
     *
     * Retrieves the Tuning configuration for the specifed vhost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\VHostTuneConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVHostTuneConfigWithHttpInfo($server_name, $vhost_name)
    {
        $returnType = '\Swagger\Client\Model\VHostTuneConfig';
        $request = $this->getVHostTuneConfigRequest($server_name, $vhost_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\VHostTuneConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVHostTuneConfigAsync
     *
     * Retrieves the Tuning configuration for the specifed vhost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVHostTuneConfigAsync($server_name, $vhost_name)
    {
        return $this->getVHostTuneConfigAsyncWithHttpInfo($server_name, $vhost_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVHostTuneConfigAsyncWithHttpInfo
     *
     * Retrieves the Tuning configuration for the specifed vhost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVHostTuneConfigAsyncWithHttpInfo($server_name, $vhost_name)
    {
        $returnType = '\Swagger\Client\Model\VHostTuneConfig';
        $request = $this->getVHostTuneConfigRequest($server_name, $vhost_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVHostTuneConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVHostTuneConfigRequest($server_name, $vhost_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getVHostTuneConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getVHostTuneConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/tune';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVHostsConfig
     *
     * Retrieves the list of VHosts
     *
     * @param  string $server_name Reserved for future use (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\VHostsConfig
     */
    public function getVHostsConfig($server_name)
    {
        list($response) = $this->getVHostsConfigWithHttpInfo($server_name);
        return $response;
    }

    /**
     * Operation getVHostsConfigWithHttpInfo
     *
     * Retrieves the list of VHosts
     *
     * @param  string $server_name Reserved for future use (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\VHostsConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVHostsConfigWithHttpInfo($server_name)
    {
        $returnType = '\Swagger\Client\Model\VHostsConfig';
        $request = $this->getVHostsConfigRequest($server_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\VHostsConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVHostsConfigAsync
     *
     * Retrieves the list of VHosts
     *
     * @param  string $server_name Reserved for future use (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVHostsConfigAsync($server_name)
    {
        return $this->getVHostsConfigAsyncWithHttpInfo($server_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVHostsConfigAsyncWithHttpInfo
     *
     * Retrieves the list of VHosts
     *
     * @param  string $server_name Reserved for future use (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVHostsConfigAsyncWithHttpInfo($server_name)
    {
        $returnType = '\Swagger\Client\Model\VHostsConfig';
        $request = $this->getVHostsConfigRequest($server_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVHostsConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVHostsConfigRequest($server_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getVHostsConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPublisherVhostConfig
     *
     * Adds the specified Publisher configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     * @param  \Swagger\Client\Model\PublisherVhostConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postPublisherVhostConfig($server_name, $vhost_name, $publisher_name, $body)
    {
        $this->postPublisherVhostConfigWithHttpInfo($server_name, $vhost_name, $publisher_name, $body);
    }

    /**
     * Operation postPublisherVhostConfigWithHttpInfo
     *
     * Adds the specified Publisher configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     * @param  \Swagger\Client\Model\PublisherVhostConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPublisherVhostConfigWithHttpInfo($server_name, $vhost_name, $publisher_name, $body)
    {
        $returnType = '';
        $request = $this->postPublisherVhostConfigRequest($server_name, $vhost_name, $publisher_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postPublisherVhostConfigAsync
     *
     * Adds the specified Publisher configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     * @param  \Swagger\Client\Model\PublisherVhostConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPublisherVhostConfigAsync($server_name, $vhost_name, $publisher_name, $body)
    {
        return $this->postPublisherVhostConfigAsyncWithHttpInfo($server_name, $vhost_name, $publisher_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPublisherVhostConfigAsyncWithHttpInfo
     *
     * Adds the specified Publisher configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     * @param  \Swagger\Client\Model\PublisherVhostConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPublisherVhostConfigAsyncWithHttpInfo($server_name, $vhost_name, $publisher_name, $body)
    {
        $returnType = '';
        $request = $this->postPublisherVhostConfigRequest($server_name, $vhost_name, $publisher_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPublisherVhostConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     * @param  \Swagger\Client\Model\PublisherVhostConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPublisherVhostConfigRequest($server_name, $vhost_name, $publisher_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling postPublisherVhostConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling postPublisherVhostConfig'
            );
        }
        // verify the required parameter 'publisher_name' is set
        if ($publisher_name === null || (is_array($publisher_name) && count($publisher_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $publisher_name when calling postPublisherVhostConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postPublisherVhostConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/publishers/{publisherName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($publisher_name !== null) {
            $resourcePath = str_replace(
                '{' . 'publisherName' . '}',
                ObjectSerializer::toPathValue($publisher_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPublishersVhostConfig
     *
     * Add a Publisher to list of Publishers for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  \Swagger\Client\Model\PublisherVhostConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postPublishersVhostConfig($server_name, $vhost_name, $body)
    {
        $this->postPublishersVhostConfigWithHttpInfo($server_name, $vhost_name, $body);
    }

    /**
     * Operation postPublishersVhostConfigWithHttpInfo
     *
     * Add a Publisher to list of Publishers for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  \Swagger\Client\Model\PublisherVhostConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPublishersVhostConfigWithHttpInfo($server_name, $vhost_name, $body)
    {
        $returnType = '';
        $request = $this->postPublishersVhostConfigRequest($server_name, $vhost_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postPublishersVhostConfigAsync
     *
     * Add a Publisher to list of Publishers for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  \Swagger\Client\Model\PublisherVhostConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPublishersVhostConfigAsync($server_name, $vhost_name, $body)
    {
        return $this->postPublishersVhostConfigAsyncWithHttpInfo($server_name, $vhost_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPublishersVhostConfigAsyncWithHttpInfo
     *
     * Add a Publisher to list of Publishers for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  \Swagger\Client\Model\PublisherVhostConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPublishersVhostConfigAsyncWithHttpInfo($server_name, $vhost_name, $body)
    {
        $returnType = '';
        $request = $this->postPublishersVhostConfigRequest($server_name, $vhost_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPublishersVhostConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  \Swagger\Client\Model\PublisherVhostConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPublishersVhostConfigRequest($server_name, $vhost_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling postPublishersVhostConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling postPublishersVhostConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postPublishersVhostConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/publishers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postSMILFileConfig
     *
     * Adds the specified SMIL File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     * @param  \Swagger\Client\Model\SMILFileConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postSMILFileConfig($server_name, $vhost_name, $smilfile_name, $body)
    {
        $this->postSMILFileConfigWithHttpInfo($server_name, $vhost_name, $smilfile_name, $body);
    }

    /**
     * Operation postSMILFileConfigWithHttpInfo
     *
     * Adds the specified SMIL File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     * @param  \Swagger\Client\Model\SMILFileConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postSMILFileConfigWithHttpInfo($server_name, $vhost_name, $smilfile_name, $body)
    {
        $returnType = '';
        $request = $this->postSMILFileConfigRequest($server_name, $vhost_name, $smilfile_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postSMILFileConfigAsync
     *
     * Adds the specified SMIL File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     * @param  \Swagger\Client\Model\SMILFileConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSMILFileConfigAsync($server_name, $vhost_name, $smilfile_name, $body)
    {
        return $this->postSMILFileConfigAsyncWithHttpInfo($server_name, $vhost_name, $smilfile_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postSMILFileConfigAsyncWithHttpInfo
     *
     * Adds the specified SMIL File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     * @param  \Swagger\Client\Model\SMILFileConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSMILFileConfigAsyncWithHttpInfo($server_name, $vhost_name, $smilfile_name, $body)
    {
        $returnType = '';
        $request = $this->postSMILFileConfigRequest($server_name, $vhost_name, $smilfile_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postSMILFileConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     * @param  \Swagger\Client\Model\SMILFileConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postSMILFileConfigRequest($server_name, $vhost_name, $smilfile_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling postSMILFileConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling postSMILFileConfig'
            );
        }
        // verify the required parameter 'smilfile_name' is set
        if ($smilfile_name === null || (is_array($smilfile_name) && count($smilfile_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $smilfile_name when calling postSMILFileConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postSMILFileConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/smilfiles/{smilfileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($smilfile_name !== null) {
            $resourcePath = str_replace(
                '{' . 'smilfileName' . '}',
                ObjectSerializer::toPathValue($smilfile_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postSMILFilesConfig
     *
     * Adds a SMIL File to the list of SMIL Files for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  \Swagger\Client\Model\SMILFileConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postSMILFilesConfig($server_name, $vhost_name, $body)
    {
        $this->postSMILFilesConfigWithHttpInfo($server_name, $vhost_name, $body);
    }

    /**
     * Operation postSMILFilesConfigWithHttpInfo
     *
     * Adds a SMIL File to the list of SMIL Files for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  \Swagger\Client\Model\SMILFileConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postSMILFilesConfigWithHttpInfo($server_name, $vhost_name, $body)
    {
        $returnType = '';
        $request = $this->postSMILFilesConfigRequest($server_name, $vhost_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postSMILFilesConfigAsync
     *
     * Adds a SMIL File to the list of SMIL Files for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  \Swagger\Client\Model\SMILFileConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSMILFilesConfigAsync($server_name, $vhost_name, $body)
    {
        return $this->postSMILFilesConfigAsyncWithHttpInfo($server_name, $vhost_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postSMILFilesConfigAsyncWithHttpInfo
     *
     * Adds a SMIL File to the list of SMIL Files for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  \Swagger\Client\Model\SMILFileConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSMILFilesConfigAsyncWithHttpInfo($server_name, $vhost_name, $body)
    {
        $returnType = '';
        $request = $this->postSMILFilesConfigRequest($server_name, $vhost_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postSMILFilesConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  \Swagger\Client\Model\SMILFileConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postSMILFilesConfigRequest($server_name, $vhost_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling postSMILFilesConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling postSMILFilesConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postSMILFilesConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/smilfiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postStartupStreamConfig
     *
     * Adds the specified Startup Stream configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $stream_name stream_name (required)
     * @param  string $app_name app_name (required)
     * @param  string $instance_name instance_name (required)
     * @param  \Swagger\Client\Model\StartupStreamConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postStartupStreamConfig($server_name, $vhost_name, $stream_name, $app_name, $instance_name, $body)
    {
        $this->postStartupStreamConfigWithHttpInfo($server_name, $vhost_name, $stream_name, $app_name, $instance_name, $body);
    }

    /**
     * Operation postStartupStreamConfigWithHttpInfo
     *
     * Adds the specified Startup Stream configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $stream_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  \Swagger\Client\Model\StartupStreamConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postStartupStreamConfigWithHttpInfo($server_name, $vhost_name, $stream_name, $app_name, $instance_name, $body)
    {
        $returnType = '';
        $request = $this->postStartupStreamConfigRequest($server_name, $vhost_name, $stream_name, $app_name, $instance_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postStartupStreamConfigAsync
     *
     * Adds the specified Startup Stream configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $stream_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  \Swagger\Client\Model\StartupStreamConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postStartupStreamConfigAsync($server_name, $vhost_name, $stream_name, $app_name, $instance_name, $body)
    {
        return $this->postStartupStreamConfigAsyncWithHttpInfo($server_name, $vhost_name, $stream_name, $app_name, $instance_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postStartupStreamConfigAsyncWithHttpInfo
     *
     * Adds the specified Startup Stream configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $stream_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  \Swagger\Client\Model\StartupStreamConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postStartupStreamConfigAsyncWithHttpInfo($server_name, $vhost_name, $stream_name, $app_name, $instance_name, $body)
    {
        $returnType = '';
        $request = $this->postStartupStreamConfigRequest($server_name, $vhost_name, $stream_name, $app_name, $instance_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postStartupStreamConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $stream_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  \Swagger\Client\Model\StartupStreamConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postStartupStreamConfigRequest($server_name, $vhost_name, $stream_name, $app_name, $instance_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling postStartupStreamConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling postStartupStreamConfig'
            );
        }
        // verify the required parameter 'stream_name' is set
        if ($stream_name === null || (is_array($stream_name) && count($stream_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stream_name when calling postStartupStreamConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling postStartupStreamConfig'
            );
        }
        // verify the required parameter 'instance_name' is set
        if ($instance_name === null || (is_array($instance_name) && count($instance_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_name when calling postStartupStreamConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postStartupStreamConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/startupstreams/applications/{appName}/instances/{instanceName}/streams/{streamName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($stream_name !== null) {
            $resourcePath = str_replace(
                '{' . 'streamName' . '}',
                ObjectSerializer::toPathValue($stream_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($instance_name !== null) {
            $resourcePath = str_replace(
                '{' . 'instanceName' . '}',
                ObjectSerializer::toPathValue($instance_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postStartupStreamsConfig
     *
     * Adds a Startup Stream to the list of Startup Streams for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  \Swagger\Client\Model\StartupStreamConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postStartupStreamsConfig($server_name, $vhost_name, $body)
    {
        $this->postStartupStreamsConfigWithHttpInfo($server_name, $vhost_name, $body);
    }

    /**
     * Operation postStartupStreamsConfigWithHttpInfo
     *
     * Adds a Startup Stream to the list of Startup Streams for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  \Swagger\Client\Model\StartupStreamConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postStartupStreamsConfigWithHttpInfo($server_name, $vhost_name, $body)
    {
        $returnType = '';
        $request = $this->postStartupStreamsConfigRequest($server_name, $vhost_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postStartupStreamsConfigAsync
     *
     * Adds a Startup Stream to the list of Startup Streams for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  \Swagger\Client\Model\StartupStreamConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postStartupStreamsConfigAsync($server_name, $vhost_name, $body)
    {
        return $this->postStartupStreamsConfigAsyncWithHttpInfo($server_name, $vhost_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postStartupStreamsConfigAsyncWithHttpInfo
     *
     * Adds a Startup Stream to the list of Startup Streams for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  \Swagger\Client\Model\StartupStreamConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postStartupStreamsConfigAsyncWithHttpInfo($server_name, $vhost_name, $body)
    {
        $returnType = '';
        $request = $this->postStartupStreamsConfigRequest($server_name, $vhost_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postStartupStreamsConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  \Swagger\Client\Model\StartupStreamConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postStartupStreamsConfigRequest($server_name, $vhost_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling postStartupStreamsConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling postStartupStreamsConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postStartupStreamsConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/startupstreams';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postStreamFileConfig
     *
     * Adds the specified Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     * @param  \Swagger\Client\Model\StreamFileConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postStreamFileConfig($server_name, $vhost_name, $streamfile_name, $body)
    {
        $this->postStreamFileConfigWithHttpInfo($server_name, $vhost_name, $streamfile_name, $body);
    }

    /**
     * Operation postStreamFileConfigWithHttpInfo
     *
     * Adds the specified Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     * @param  \Swagger\Client\Model\StreamFileConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postStreamFileConfigWithHttpInfo($server_name, $vhost_name, $streamfile_name, $body)
    {
        $returnType = '';
        $request = $this->postStreamFileConfigRequest($server_name, $vhost_name, $streamfile_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postStreamFileConfigAsync
     *
     * Adds the specified Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     * @param  \Swagger\Client\Model\StreamFileConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postStreamFileConfigAsync($server_name, $vhost_name, $streamfile_name, $body)
    {
        return $this->postStreamFileConfigAsyncWithHttpInfo($server_name, $vhost_name, $streamfile_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postStreamFileConfigAsyncWithHttpInfo
     *
     * Adds the specified Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     * @param  \Swagger\Client\Model\StreamFileConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postStreamFileConfigAsyncWithHttpInfo($server_name, $vhost_name, $streamfile_name, $body)
    {
        $returnType = '';
        $request = $this->postStreamFileConfigRequest($server_name, $vhost_name, $streamfile_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postStreamFileConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     * @param  \Swagger\Client\Model\StreamFileConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postStreamFileConfigRequest($server_name, $vhost_name, $streamfile_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling postStreamFileConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling postStreamFileConfig'
            );
        }
        // verify the required parameter 'streamfile_name' is set
        if ($streamfile_name === null || (is_array($streamfile_name) && count($streamfile_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $streamfile_name when calling postStreamFileConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postStreamFileConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/streamfiles/{streamfileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($streamfile_name !== null) {
            $resourcePath = str_replace(
                '{' . 'streamfileName' . '}',
                ObjectSerializer::toPathValue($streamfile_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postStreamFilesConfig
     *
     * Adds a Stream File to the list of Stream Files for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  \Swagger\Client\Model\StreamFileConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postStreamFilesConfig($server_name, $vhost_name, $body)
    {
        $this->postStreamFilesConfigWithHttpInfo($server_name, $vhost_name, $body);
    }

    /**
     * Operation postStreamFilesConfigWithHttpInfo
     *
     * Adds a Stream File to the list of Stream Files for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  \Swagger\Client\Model\StreamFileConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postStreamFilesConfigWithHttpInfo($server_name, $vhost_name, $body)
    {
        $returnType = '';
        $request = $this->postStreamFilesConfigRequest($server_name, $vhost_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postStreamFilesConfigAsync
     *
     * Adds a Stream File to the list of Stream Files for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  \Swagger\Client\Model\StreamFileConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postStreamFilesConfigAsync($server_name, $vhost_name, $body)
    {
        return $this->postStreamFilesConfigAsyncWithHttpInfo($server_name, $vhost_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postStreamFilesConfigAsyncWithHttpInfo
     *
     * Adds a Stream File to the list of Stream Files for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  \Swagger\Client\Model\StreamFileConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postStreamFilesConfigAsyncWithHttpInfo($server_name, $vhost_name, $body)
    {
        $returnType = '';
        $request = $this->postStreamFilesConfigRequest($server_name, $vhost_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postStreamFilesConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  \Swagger\Client\Model\StreamFileConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postStreamFilesConfigRequest($server_name, $vhost_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling postStreamFilesConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling postStreamFilesConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postStreamFilesConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/streamfiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postTranscoderEncodeConfig
     *
     * Adds the specified Trancoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $encode_name encode_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postTranscoderEncodeConfig($server_name, $vhost_name, $template_name, $encode_name, $body)
    {
        $this->postTranscoderEncodeConfigWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $body);
    }

    /**
     * Operation postTranscoderEncodeConfigWithHttpInfo
     *
     * Adds the specified Trancoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postTranscoderEncodeConfigWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $body)
    {
        $returnType = '';
        $request = $this->postTranscoderEncodeConfigRequest($server_name, $vhost_name, $template_name, $encode_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postTranscoderEncodeConfigAsync
     *
     * Adds the specified Trancoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTranscoderEncodeConfigAsync($server_name, $vhost_name, $template_name, $encode_name, $body)
    {
        return $this->postTranscoderEncodeConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postTranscoderEncodeConfigAsyncWithHttpInfo
     *
     * Adds the specified Trancoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTranscoderEncodeConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $body)
    {
        $returnType = '';
        $request = $this->postTranscoderEncodeConfigRequest($server_name, $vhost_name, $template_name, $encode_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postTranscoderEncodeConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postTranscoderEncodeConfigRequest($server_name, $vhost_name, $template_name, $encode_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling postTranscoderEncodeConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling postTranscoderEncodeConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling postTranscoderEncodeConfig'
            );
        }
        // verify the required parameter 'encode_name' is set
        if ($encode_name === null || (is_array($encode_name) && count($encode_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $encode_name when calling postTranscoderEncodeConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postTranscoderEncodeConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/transcoder/templates/{templateName}/encodes/{encodeName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($encode_name !== null) {
            $resourcePath = str_replace(
                '{' . 'encodeName' . '}',
                ObjectSerializer::toPathValue($encode_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postTranscoderEncodesConfig
     *
     * Adds a Transcoder Encode Configuration to the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postTranscoderEncodesConfig($server_name, $vhost_name, $template_name, $body)
    {
        $this->postTranscoderEncodesConfigWithHttpInfo($server_name, $vhost_name, $template_name, $body);
    }

    /**
     * Operation postTranscoderEncodesConfigWithHttpInfo
     *
     * Adds a Transcoder Encode Configuration to the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postTranscoderEncodesConfigWithHttpInfo($server_name, $vhost_name, $template_name, $body)
    {
        $returnType = '';
        $request = $this->postTranscoderEncodesConfigRequest($server_name, $vhost_name, $template_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postTranscoderEncodesConfigAsync
     *
     * Adds a Transcoder Encode Configuration to the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTranscoderEncodesConfigAsync($server_name, $vhost_name, $template_name, $body)
    {
        return $this->postTranscoderEncodesConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postTranscoderEncodesConfigAsyncWithHttpInfo
     *
     * Adds a Transcoder Encode Configuration to the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTranscoderEncodesConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $body)
    {
        $returnType = '';
        $request = $this->postTranscoderEncodesConfigRequest($server_name, $vhost_name, $template_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postTranscoderEncodesConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postTranscoderEncodesConfigRequest($server_name, $vhost_name, $template_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling postTranscoderEncodesConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling postTranscoderEncodesConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling postTranscoderEncodesConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postTranscoderEncodesConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/transcoder/templates/{templateName}/encodes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postTranscoderStreamNameGroupConfig
     *
     * Adds the specified Trancoder StreamNameGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $group_name group_name (required)
     * @param  \Swagger\Client\Model\TranscoderStreamNameGroupConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postTranscoderStreamNameGroupConfig($server_name, $vhost_name, $template_name, $group_name, $body)
    {
        $this->postTranscoderStreamNameGroupConfigWithHttpInfo($server_name, $vhost_name, $template_name, $group_name, $body);
    }

    /**
     * Operation postTranscoderStreamNameGroupConfigWithHttpInfo
     *
     * Adds the specified Trancoder StreamNameGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $group_name (required)
     * @param  \Swagger\Client\Model\TranscoderStreamNameGroupConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postTranscoderStreamNameGroupConfigWithHttpInfo($server_name, $vhost_name, $template_name, $group_name, $body)
    {
        $returnType = '';
        $request = $this->postTranscoderStreamNameGroupConfigRequest($server_name, $vhost_name, $template_name, $group_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postTranscoderStreamNameGroupConfigAsync
     *
     * Adds the specified Trancoder StreamNameGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $group_name (required)
     * @param  \Swagger\Client\Model\TranscoderStreamNameGroupConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTranscoderStreamNameGroupConfigAsync($server_name, $vhost_name, $template_name, $group_name, $body)
    {
        return $this->postTranscoderStreamNameGroupConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $group_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postTranscoderStreamNameGroupConfigAsyncWithHttpInfo
     *
     * Adds the specified Trancoder StreamNameGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $group_name (required)
     * @param  \Swagger\Client\Model\TranscoderStreamNameGroupConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTranscoderStreamNameGroupConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $group_name, $body)
    {
        $returnType = '';
        $request = $this->postTranscoderStreamNameGroupConfigRequest($server_name, $vhost_name, $template_name, $group_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postTranscoderStreamNameGroupConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $group_name (required)
     * @param  \Swagger\Client\Model\TranscoderStreamNameGroupConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postTranscoderStreamNameGroupConfigRequest($server_name, $vhost_name, $template_name, $group_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling postTranscoderStreamNameGroupConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling postTranscoderStreamNameGroupConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling postTranscoderStreamNameGroupConfig'
            );
        }
        // verify the required parameter 'group_name' is set
        if ($group_name === null || (is_array($group_name) && count($group_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_name when calling postTranscoderStreamNameGroupConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postTranscoderStreamNameGroupConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/transcoder/templates/{templateName}/streamnamegroups/{groupName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($group_name !== null) {
            $resourcePath = str_replace(
                '{' . 'groupName' . '}',
                ObjectSerializer::toPathValue($group_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postTranscoderStreamNameGroupsConfig
     *
     * Adds a Transcoder Stream Name Groups Configuration to the specified Template
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  \Swagger\Client\Model\TranscoderStreamNameGroupConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postTranscoderStreamNameGroupsConfig($server_name, $vhost_name, $template_name, $body)
    {
        $this->postTranscoderStreamNameGroupsConfigWithHttpInfo($server_name, $vhost_name, $template_name, $body);
    }

    /**
     * Operation postTranscoderStreamNameGroupsConfigWithHttpInfo
     *
     * Adds a Transcoder Stream Name Groups Configuration to the specified Template
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  \Swagger\Client\Model\TranscoderStreamNameGroupConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postTranscoderStreamNameGroupsConfigWithHttpInfo($server_name, $vhost_name, $template_name, $body)
    {
        $returnType = '';
        $request = $this->postTranscoderStreamNameGroupsConfigRequest($server_name, $vhost_name, $template_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postTranscoderStreamNameGroupsConfigAsync
     *
     * Adds a Transcoder Stream Name Groups Configuration to the specified Template
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  \Swagger\Client\Model\TranscoderStreamNameGroupConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTranscoderStreamNameGroupsConfigAsync($server_name, $vhost_name, $template_name, $body)
    {
        return $this->postTranscoderStreamNameGroupsConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postTranscoderStreamNameGroupsConfigAsyncWithHttpInfo
     *
     * Adds a Transcoder Stream Name Groups Configuration to the specified Template
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  \Swagger\Client\Model\TranscoderStreamNameGroupConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTranscoderStreamNameGroupsConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $body)
    {
        $returnType = '';
        $request = $this->postTranscoderStreamNameGroupsConfigRequest($server_name, $vhost_name, $template_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postTranscoderStreamNameGroupsConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  \Swagger\Client\Model\TranscoderStreamNameGroupConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postTranscoderStreamNameGroupsConfigRequest($server_name, $vhost_name, $template_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling postTranscoderStreamNameGroupsConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling postTranscoderStreamNameGroupsConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling postTranscoderStreamNameGroupsConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postTranscoderStreamNameGroupsConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/transcoder/templates/{templateName}/streamnamegroups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postTranscoderTemplateConfig
     *
     * Adds the specified Trancoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postTranscoderTemplateConfig($server_name, $vhost_name, $template_name, $body)
    {
        $this->postTranscoderTemplateConfigWithHttpInfo($server_name, $vhost_name, $template_name, $body);
    }

    /**
     * Operation postTranscoderTemplateConfigWithHttpInfo
     *
     * Adds the specified Trancoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postTranscoderTemplateConfigWithHttpInfo($server_name, $vhost_name, $template_name, $body)
    {
        $returnType = '';
        $request = $this->postTranscoderTemplateConfigRequest($server_name, $vhost_name, $template_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postTranscoderTemplateConfigAsync
     *
     * Adds the specified Trancoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTranscoderTemplateConfigAsync($server_name, $vhost_name, $template_name, $body)
    {
        return $this->postTranscoderTemplateConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postTranscoderTemplateConfigAsyncWithHttpInfo
     *
     * Adds the specified Trancoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTranscoderTemplateConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $body)
    {
        $returnType = '';
        $request = $this->postTranscoderTemplateConfigRequest($server_name, $vhost_name, $template_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postTranscoderTemplateConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postTranscoderTemplateConfigRequest($server_name, $vhost_name, $template_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling postTranscoderTemplateConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling postTranscoderTemplateConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling postTranscoderTemplateConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postTranscoderTemplateConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/transcoder/templates/{templateName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postTranscoderTemplatesConfig
     *
     * Adds a Transcoder Templates Configuration to the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postTranscoderTemplatesConfig($server_name, $vhost_name, $body)
    {
        $this->postTranscoderTemplatesConfigWithHttpInfo($server_name, $vhost_name, $body);
    }

    /**
     * Operation postTranscoderTemplatesConfigWithHttpInfo
     *
     * Adds a Transcoder Templates Configuration to the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postTranscoderTemplatesConfigWithHttpInfo($server_name, $vhost_name, $body)
    {
        $returnType = '';
        $request = $this->postTranscoderTemplatesConfigRequest($server_name, $vhost_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postTranscoderTemplatesConfigAsync
     *
     * Adds a Transcoder Templates Configuration to the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTranscoderTemplatesConfigAsync($server_name, $vhost_name, $body)
    {
        return $this->postTranscoderTemplatesConfigAsyncWithHttpInfo($server_name, $vhost_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postTranscoderTemplatesConfigAsyncWithHttpInfo
     *
     * Adds a Transcoder Templates Configuration to the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTranscoderTemplatesConfigAsyncWithHttpInfo($server_name, $vhost_name, $body)
    {
        $returnType = '';
        $request = $this->postTranscoderTemplatesConfigRequest($server_name, $vhost_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postTranscoderTemplatesConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postTranscoderTemplatesConfigRequest($server_name, $vhost_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling postTranscoderTemplatesConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling postTranscoderTemplatesConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postTranscoderTemplatesConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/transcoder/templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putHostPortConfigAdv
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $portname The port name (required)
     * @param  \Swagger\Client\Model\HostPortConfigAdv $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putHostPortConfigAdv($server_name, $vhost_name, $portname, $body)
    {
        $this->putHostPortConfigAdvWithHttpInfo($server_name, $vhost_name, $portname, $body);
    }

    /**
     * Operation putHostPortConfigAdvWithHttpInfo
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $portname The port name (required)
     * @param  \Swagger\Client\Model\HostPortConfigAdv $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putHostPortConfigAdvWithHttpInfo($server_name, $vhost_name, $portname, $body)
    {
        $returnType = '';
        $request = $this->putHostPortConfigAdvRequest($server_name, $vhost_name, $portname, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putHostPortConfigAdvAsync
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $portname The port name (required)
     * @param  \Swagger\Client\Model\HostPortConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putHostPortConfigAdvAsync($server_name, $vhost_name, $portname, $body)
    {
        return $this->putHostPortConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $portname, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putHostPortConfigAdvAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $portname The port name (required)
     * @param  \Swagger\Client\Model\HostPortConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putHostPortConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $portname, $body)
    {
        $returnType = '';
        $request = $this->putHostPortConfigAdvRequest($server_name, $vhost_name, $portname, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putHostPortConfigAdv'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $portname The port name (required)
     * @param  \Swagger\Client\Model\HostPortConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putHostPortConfigAdvRequest($server_name, $vhost_name, $portname, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putHostPortConfigAdv'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putHostPortConfigAdv'
            );
        }
        // verify the required parameter 'portname' is set
        if ($portname === null || (is_array($portname) && count($portname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $portname when calling putHostPortConfigAdv'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putHostPortConfigAdv'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/hostports/{portname}/adv';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($portname !== null) {
            $resourcePath = str_replace(
                '{' . 'portname' . '}',
                ObjectSerializer::toPathValue($portname),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putHostportsTuneConfig
     *
     * Updates the host port configuration used for server tuning for the specified vhost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  \Swagger\Client\Model\HostportsTuneConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putHostportsTuneConfig($server_name, $vhost_name, $body)
    {
        $this->putHostportsTuneConfigWithHttpInfo($server_name, $vhost_name, $body);
    }

    /**
     * Operation putHostportsTuneConfigWithHttpInfo
     *
     * Updates the host port configuration used for server tuning for the specified vhost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  \Swagger\Client\Model\HostportsTuneConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putHostportsTuneConfigWithHttpInfo($server_name, $vhost_name, $body)
    {
        $returnType = '';
        $request = $this->putHostportsTuneConfigRequest($server_name, $vhost_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putHostportsTuneConfigAsync
     *
     * Updates the host port configuration used for server tuning for the specified vhost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  \Swagger\Client\Model\HostportsTuneConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putHostportsTuneConfigAsync($server_name, $vhost_name, $body)
    {
        return $this->putHostportsTuneConfigAsyncWithHttpInfo($server_name, $vhost_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putHostportsTuneConfigAsyncWithHttpInfo
     *
     * Updates the host port configuration used for server tuning for the specified vhost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  \Swagger\Client\Model\HostportsTuneConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putHostportsTuneConfigAsyncWithHttpInfo($server_name, $vhost_name, $body)
    {
        $returnType = '';
        $request = $this->putHostportsTuneConfigRequest($server_name, $vhost_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putHostportsTuneConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  \Swagger\Client\Model\HostportsTuneConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putHostportsTuneConfigRequest($server_name, $vhost_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putHostportsTuneConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putHostportsTuneConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putHostportsTuneConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/tunehostports';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putMediaCacheStoreAction
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $filename The file or stream name item to be used in all rest action requests (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putMediaCacheStoreAction($server_name, $action, $vhost_name, $filename = null)
    {
        $this->putMediaCacheStoreActionWithHttpInfo($server_name, $action, $vhost_name, $filename);
    }

    /**
     * Operation putMediaCacheStoreActionWithHttpInfo
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $filename The file or stream name item to be used in all rest action requests (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putMediaCacheStoreActionWithHttpInfo($server_name, $action, $vhost_name, $filename = null)
    {
        $returnType = '';
        $request = $this->putMediaCacheStoreActionRequest($server_name, $action, $vhost_name, $filename);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putMediaCacheStoreActionAsync
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $filename The file or stream name item to be used in all rest action requests (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putMediaCacheStoreActionAsync($server_name, $action, $vhost_name, $filename = null)
    {
        return $this->putMediaCacheStoreActionAsyncWithHttpInfo($server_name, $action, $vhost_name, $filename)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putMediaCacheStoreActionAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $filename The file or stream name item to be used in all rest action requests (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putMediaCacheStoreActionAsyncWithHttpInfo($server_name, $action, $vhost_name, $filename = null)
    {
        $returnType = '';
        $request = $this->putMediaCacheStoreActionRequest($server_name, $action, $vhost_name, $filename);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putMediaCacheStoreAction'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $filename The file or stream name item to be used in all rest action requests (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putMediaCacheStoreActionRequest($server_name, $action, $vhost_name, $filename = null)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putMediaCacheStoreAction'
            );
        }
        // verify the required parameter 'action' is set
        if ($action === null || (is_array($action) && count($action) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $action when calling putMediaCacheStoreAction'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putMediaCacheStoreAction'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/mediacache/stores/actions/{action}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($filename !== null) {
            $queryParams['filename'] = ObjectSerializer::toQueryValue($filename);
        }

        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($action !== null) {
            $resourcePath = str_replace(
                '{' . 'action' . '}',
                ObjectSerializer::toPathValue($action),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPublisherVhostConfig
     *
     * Updates the specified Publisher configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     * @param  \Swagger\Client\Model\PublisherVhostConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putPublisherVhostConfig($server_name, $vhost_name, $publisher_name, $body)
    {
        $this->putPublisherVhostConfigWithHttpInfo($server_name, $vhost_name, $publisher_name, $body);
    }

    /**
     * Operation putPublisherVhostConfigWithHttpInfo
     *
     * Updates the specified Publisher configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     * @param  \Swagger\Client\Model\PublisherVhostConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPublisherVhostConfigWithHttpInfo($server_name, $vhost_name, $publisher_name, $body)
    {
        $returnType = '';
        $request = $this->putPublisherVhostConfigRequest($server_name, $vhost_name, $publisher_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putPublisherVhostConfigAsync
     *
     * Updates the specified Publisher configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     * @param  \Swagger\Client\Model\PublisherVhostConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPublisherVhostConfigAsync($server_name, $vhost_name, $publisher_name, $body)
    {
        return $this->putPublisherVhostConfigAsyncWithHttpInfo($server_name, $vhost_name, $publisher_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPublisherVhostConfigAsyncWithHttpInfo
     *
     * Updates the specified Publisher configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     * @param  \Swagger\Client\Model\PublisherVhostConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPublisherVhostConfigAsyncWithHttpInfo($server_name, $vhost_name, $publisher_name, $body)
    {
        $returnType = '';
        $request = $this->putPublisherVhostConfigRequest($server_name, $vhost_name, $publisher_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPublisherVhostConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     * @param  \Swagger\Client\Model\PublisherVhostConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPublisherVhostConfigRequest($server_name, $vhost_name, $publisher_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putPublisherVhostConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putPublisherVhostConfig'
            );
        }
        // verify the required parameter 'publisher_name' is set
        if ($publisher_name === null || (is_array($publisher_name) && count($publisher_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $publisher_name when calling putPublisherVhostConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putPublisherVhostConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/publishers/{publisherName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($publisher_name !== null) {
            $resourcePath = str_replace(
                '{' . 'publisherName' . '}',
                ObjectSerializer::toPathValue($publisher_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSDPFileAction
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $media_caster_type The MediaCasterType to use for the connection (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $sdpfile_name The SDP file name needed for this REST call (required)
     * @param  string $connect_app_name The name of the application to connect to (optional)
     * @param  string $app_nstance The name of the application instance to connect to (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putSDPFileAction($server_name, $action, $media_caster_type, $vhost_name, $sdpfile_name, $connect_app_name = null, $app_nstance = null)
    {
        $this->putSDPFileActionWithHttpInfo($server_name, $action, $media_caster_type, $vhost_name, $sdpfile_name, $connect_app_name, $app_nstance);
    }

    /**
     * Operation putSDPFileActionWithHttpInfo
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $media_caster_type The MediaCasterType to use for the connection (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $sdpfile_name The SDP file name needed for this REST call (required)
     * @param  string $connect_app_name The name of the application to connect to (optional)
     * @param  string $app_nstance The name of the application instance to connect to (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSDPFileActionWithHttpInfo($server_name, $action, $media_caster_type, $vhost_name, $sdpfile_name, $connect_app_name = null, $app_nstance = null)
    {
        $returnType = '';
        $request = $this->putSDPFileActionRequest($server_name, $action, $media_caster_type, $vhost_name, $sdpfile_name, $connect_app_name, $app_nstance);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putSDPFileActionAsync
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $media_caster_type The MediaCasterType to use for the connection (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $sdpfile_name The SDP file name needed for this REST call (required)
     * @param  string $connect_app_name The name of the application to connect to (optional)
     * @param  string $app_nstance The name of the application instance to connect to (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSDPFileActionAsync($server_name, $action, $media_caster_type, $vhost_name, $sdpfile_name, $connect_app_name = null, $app_nstance = null)
    {
        return $this->putSDPFileActionAsyncWithHttpInfo($server_name, $action, $media_caster_type, $vhost_name, $sdpfile_name, $connect_app_name, $app_nstance)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSDPFileActionAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $media_caster_type The MediaCasterType to use for the connection (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $sdpfile_name The SDP file name needed for this REST call (required)
     * @param  string $connect_app_name The name of the application to connect to (optional)
     * @param  string $app_nstance The name of the application instance to connect to (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSDPFileActionAsyncWithHttpInfo($server_name, $action, $media_caster_type, $vhost_name, $sdpfile_name, $connect_app_name = null, $app_nstance = null)
    {
        $returnType = '';
        $request = $this->putSDPFileActionRequest($server_name, $action, $media_caster_type, $vhost_name, $sdpfile_name, $connect_app_name, $app_nstance);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSDPFileAction'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $media_caster_type The MediaCasterType to use for the connection (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $sdpfile_name The SDP file name needed for this REST call (required)
     * @param  string $connect_app_name The name of the application to connect to (optional)
     * @param  string $app_nstance The name of the application instance to connect to (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putSDPFileActionRequest($server_name, $action, $media_caster_type, $vhost_name, $sdpfile_name, $connect_app_name = null, $app_nstance = null)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putSDPFileAction'
            );
        }
        // verify the required parameter 'action' is set
        if ($action === null || (is_array($action) && count($action) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $action when calling putSDPFileAction'
            );
        }
        // verify the required parameter 'media_caster_type' is set
        if ($media_caster_type === null || (is_array($media_caster_type) && count($media_caster_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $media_caster_type when calling putSDPFileAction'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putSDPFileAction'
            );
        }
        // verify the required parameter 'sdpfile_name' is set
        if ($sdpfile_name === null || (is_array($sdpfile_name) && count($sdpfile_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sdpfile_name when calling putSDPFileAction'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/sdpfiles/{sdpfileName}/actions/{action}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($connect_app_name !== null) {
            $queryParams['connectAppName'] = ObjectSerializer::toQueryValue($connect_app_name);
        }
        // query params
        if ($app_nstance !== null) {
            $queryParams['appInstance'] = ObjectSerializer::toQueryValue($app_nstance);
        }
        // query params
        if ($media_caster_type !== null) {
            $queryParams['mediaCasterType'] = ObjectSerializer::toQueryValue($media_caster_type);
        }

        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($action !== null) {
            $resourcePath = str_replace(
                '{' . 'action' . '}',
                ObjectSerializer::toPathValue($action),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($sdpfile_name !== null) {
            $resourcePath = str_replace(
                '{' . 'sdpfileName' . '}',
                ObjectSerializer::toPathValue($sdpfile_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSMILFileAction
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $media_caster_type The MediaCasterType to use for the connection (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $smilfile_name The SMIL file, file name needed for this REST call (required)
     * @param  string $connect_app_name The name of the application to connect to (optional)
     * @param  string $app_nstance The name of the application instance to connect to (optional)
     * @param  string $dst_entry_name The destination SMIL file name when copying (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putSMILFileAction($server_name, $action, $media_caster_type, $vhost_name, $smilfile_name, $connect_app_name = null, $app_nstance = null, $dst_entry_name = null)
    {
        $this->putSMILFileActionWithHttpInfo($server_name, $action, $media_caster_type, $vhost_name, $smilfile_name, $connect_app_name, $app_nstance, $dst_entry_name);
    }

    /**
     * Operation putSMILFileActionWithHttpInfo
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $media_caster_type The MediaCasterType to use for the connection (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $smilfile_name The SMIL file, file name needed for this REST call (required)
     * @param  string $connect_app_name The name of the application to connect to (optional)
     * @param  string $app_nstance The name of the application instance to connect to (optional)
     * @param  string $dst_entry_name The destination SMIL file name when copying (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSMILFileActionWithHttpInfo($server_name, $action, $media_caster_type, $vhost_name, $smilfile_name, $connect_app_name = null, $app_nstance = null, $dst_entry_name = null)
    {
        $returnType = '';
        $request = $this->putSMILFileActionRequest($server_name, $action, $media_caster_type, $vhost_name, $smilfile_name, $connect_app_name, $app_nstance, $dst_entry_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putSMILFileActionAsync
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $media_caster_type The MediaCasterType to use for the connection (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $smilfile_name The SMIL file, file name needed for this REST call (required)
     * @param  string $connect_app_name The name of the application to connect to (optional)
     * @param  string $app_nstance The name of the application instance to connect to (optional)
     * @param  string $dst_entry_name The destination SMIL file name when copying (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSMILFileActionAsync($server_name, $action, $media_caster_type, $vhost_name, $smilfile_name, $connect_app_name = null, $app_nstance = null, $dst_entry_name = null)
    {
        return $this->putSMILFileActionAsyncWithHttpInfo($server_name, $action, $media_caster_type, $vhost_name, $smilfile_name, $connect_app_name, $app_nstance, $dst_entry_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSMILFileActionAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $media_caster_type The MediaCasterType to use for the connection (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $smilfile_name The SMIL file, file name needed for this REST call (required)
     * @param  string $connect_app_name The name of the application to connect to (optional)
     * @param  string $app_nstance The name of the application instance to connect to (optional)
     * @param  string $dst_entry_name The destination SMIL file name when copying (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSMILFileActionAsyncWithHttpInfo($server_name, $action, $media_caster_type, $vhost_name, $smilfile_name, $connect_app_name = null, $app_nstance = null, $dst_entry_name = null)
    {
        $returnType = '';
        $request = $this->putSMILFileActionRequest($server_name, $action, $media_caster_type, $vhost_name, $smilfile_name, $connect_app_name, $app_nstance, $dst_entry_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSMILFileAction'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $media_caster_type The MediaCasterType to use for the connection (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $smilfile_name The SMIL file, file name needed for this REST call (required)
     * @param  string $connect_app_name The name of the application to connect to (optional)
     * @param  string $app_nstance The name of the application instance to connect to (optional)
     * @param  string $dst_entry_name The destination SMIL file name when copying (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putSMILFileActionRequest($server_name, $action, $media_caster_type, $vhost_name, $smilfile_name, $connect_app_name = null, $app_nstance = null, $dst_entry_name = null)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putSMILFileAction'
            );
        }
        // verify the required parameter 'action' is set
        if ($action === null || (is_array($action) && count($action) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $action when calling putSMILFileAction'
            );
        }
        // verify the required parameter 'media_caster_type' is set
        if ($media_caster_type === null || (is_array($media_caster_type) && count($media_caster_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $media_caster_type when calling putSMILFileAction'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putSMILFileAction'
            );
        }
        // verify the required parameter 'smilfile_name' is set
        if ($smilfile_name === null || (is_array($smilfile_name) && count($smilfile_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $smilfile_name when calling putSMILFileAction'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/smilfiles/{smilfileName}/actions/{action}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($connect_app_name !== null) {
            $queryParams['connectAppName'] = ObjectSerializer::toQueryValue($connect_app_name);
        }
        // query params
        if ($app_nstance !== null) {
            $queryParams['appInstance'] = ObjectSerializer::toQueryValue($app_nstance);
        }
        // query params
        if ($media_caster_type !== null) {
            $queryParams['mediaCasterType'] = ObjectSerializer::toQueryValue($media_caster_type);
        }
        // query params
        if ($dst_entry_name !== null) {
            $queryParams['dstEntryName'] = ObjectSerializer::toQueryValue($dst_entry_name);
        }

        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($action !== null) {
            $resourcePath = str_replace(
                '{' . 'action' . '}',
                ObjectSerializer::toPathValue($action),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($smilfile_name !== null) {
            $resourcePath = str_replace(
                '{' . 'smilfileName' . '}',
                ObjectSerializer::toPathValue($smilfile_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSMILFileConfig
     *
     * Updates the specified SMIL File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     * @param  \Swagger\Client\Model\SMILFileConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putSMILFileConfig($server_name, $vhost_name, $smilfile_name, $body)
    {
        $this->putSMILFileConfigWithHttpInfo($server_name, $vhost_name, $smilfile_name, $body);
    }

    /**
     * Operation putSMILFileConfigWithHttpInfo
     *
     * Updates the specified SMIL File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     * @param  \Swagger\Client\Model\SMILFileConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSMILFileConfigWithHttpInfo($server_name, $vhost_name, $smilfile_name, $body)
    {
        $returnType = '';
        $request = $this->putSMILFileConfigRequest($server_name, $vhost_name, $smilfile_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putSMILFileConfigAsync
     *
     * Updates the specified SMIL File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     * @param  \Swagger\Client\Model\SMILFileConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSMILFileConfigAsync($server_name, $vhost_name, $smilfile_name, $body)
    {
        return $this->putSMILFileConfigAsyncWithHttpInfo($server_name, $vhost_name, $smilfile_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSMILFileConfigAsyncWithHttpInfo
     *
     * Updates the specified SMIL File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     * @param  \Swagger\Client\Model\SMILFileConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSMILFileConfigAsyncWithHttpInfo($server_name, $vhost_name, $smilfile_name, $body)
    {
        $returnType = '';
        $request = $this->putSMILFileConfigRequest($server_name, $vhost_name, $smilfile_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSMILFileConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     * @param  \Swagger\Client\Model\SMILFileConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putSMILFileConfigRequest($server_name, $vhost_name, $smilfile_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putSMILFileConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putSMILFileConfig'
            );
        }
        // verify the required parameter 'smilfile_name' is set
        if ($smilfile_name === null || (is_array($smilfile_name) && count($smilfile_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $smilfile_name when calling putSMILFileConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putSMILFileConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/smilfiles/{smilfileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($smilfile_name !== null) {
            $resourcePath = str_replace(
                '{' . 'smilfileName' . '}',
                ObjectSerializer::toPathValue($smilfile_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSSLConfig
     *
     * Updates the SSL configuration for the specified vhost and port
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $portname The port name (required)
     * @param  \Swagger\Client\Model\SSLConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putSSLConfig($server_name, $vhost_name, $portname, $body)
    {
        $this->putSSLConfigWithHttpInfo($server_name, $vhost_name, $portname, $body);
    }

    /**
     * Operation putSSLConfigWithHttpInfo
     *
     * Updates the SSL configuration for the specified vhost and port
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $portname The port name (required)
     * @param  \Swagger\Client\Model\SSLConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSSLConfigWithHttpInfo($server_name, $vhost_name, $portname, $body)
    {
        $returnType = '';
        $request = $this->putSSLConfigRequest($server_name, $vhost_name, $portname, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putSSLConfigAsync
     *
     * Updates the SSL configuration for the specified vhost and port
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $portname The port name (required)
     * @param  \Swagger\Client\Model\SSLConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSSLConfigAsync($server_name, $vhost_name, $portname, $body)
    {
        return $this->putSSLConfigAsyncWithHttpInfo($server_name, $vhost_name, $portname, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSSLConfigAsyncWithHttpInfo
     *
     * Updates the SSL configuration for the specified vhost and port
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $portname The port name (required)
     * @param  \Swagger\Client\Model\SSLConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSSLConfigAsyncWithHttpInfo($server_name, $vhost_name, $portname, $body)
    {
        $returnType = '';
        $request = $this->putSSLConfigRequest($server_name, $vhost_name, $portname, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSSLConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $portname The port name (required)
     * @param  \Swagger\Client\Model\SSLConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putSSLConfigRequest($server_name, $vhost_name, $portname, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putSSLConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putSSLConfig'
            );
        }
        // verify the required parameter 'portname' is set
        if ($portname === null || (is_array($portname) && count($portname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $portname when calling putSSLConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putSSLConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/hostports/{portname}/ssl';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($portname !== null) {
            $resourcePath = str_replace(
                '{' . 'portname' . '}',
                ObjectSerializer::toPathValue($portname),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putStartupStreamConfig
     *
     * Updates the specified Startup Stream configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $stream_name stream_name (required)
     * @param  string $app_name app_name (required)
     * @param  string $instance_name instance_name (required)
     * @param  \Swagger\Client\Model\StartupStreamConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putStartupStreamConfig($server_name, $vhost_name, $stream_name, $app_name, $instance_name, $body)
    {
        $this->putStartupStreamConfigWithHttpInfo($server_name, $vhost_name, $stream_name, $app_name, $instance_name, $body);
    }

    /**
     * Operation putStartupStreamConfigWithHttpInfo
     *
     * Updates the specified Startup Stream configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $stream_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  \Swagger\Client\Model\StartupStreamConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putStartupStreamConfigWithHttpInfo($server_name, $vhost_name, $stream_name, $app_name, $instance_name, $body)
    {
        $returnType = '';
        $request = $this->putStartupStreamConfigRequest($server_name, $vhost_name, $stream_name, $app_name, $instance_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putStartupStreamConfigAsync
     *
     * Updates the specified Startup Stream configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $stream_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  \Swagger\Client\Model\StartupStreamConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putStartupStreamConfigAsync($server_name, $vhost_name, $stream_name, $app_name, $instance_name, $body)
    {
        return $this->putStartupStreamConfigAsyncWithHttpInfo($server_name, $vhost_name, $stream_name, $app_name, $instance_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putStartupStreamConfigAsyncWithHttpInfo
     *
     * Updates the specified Startup Stream configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $stream_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  \Swagger\Client\Model\StartupStreamConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putStartupStreamConfigAsyncWithHttpInfo($server_name, $vhost_name, $stream_name, $app_name, $instance_name, $body)
    {
        $returnType = '';
        $request = $this->putStartupStreamConfigRequest($server_name, $vhost_name, $stream_name, $app_name, $instance_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putStartupStreamConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $stream_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  \Swagger\Client\Model\StartupStreamConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putStartupStreamConfigRequest($server_name, $vhost_name, $stream_name, $app_name, $instance_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putStartupStreamConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putStartupStreamConfig'
            );
        }
        // verify the required parameter 'stream_name' is set
        if ($stream_name === null || (is_array($stream_name) && count($stream_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stream_name when calling putStartupStreamConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putStartupStreamConfig'
            );
        }
        // verify the required parameter 'instance_name' is set
        if ($instance_name === null || (is_array($instance_name) && count($instance_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_name when calling putStartupStreamConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putStartupStreamConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/startupstreams/applications/{appName}/instances/{instanceName}/streams/{streamName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($stream_name !== null) {
            $resourcePath = str_replace(
                '{' . 'streamName' . '}',
                ObjectSerializer::toPathValue($stream_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($instance_name !== null) {
            $resourcePath = str_replace(
                '{' . 'instanceName' . '}',
                ObjectSerializer::toPathValue($instance_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putStreamFileAction
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $media_caster_type The MediaCasterType to use for the connection (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $streamfile_name The stream file, file name needed for this REST call (required)
     * @param  string $connect_app_name The name of the application to connect to (optional)
     * @param  string $app_nstance The name of the application instance to connect to (optional)
     * @param  string $dst_entry_name The destination stream file name when copying (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putStreamFileAction($server_name, $action, $media_caster_type, $vhost_name, $streamfile_name, $connect_app_name = null, $app_nstance = null, $dst_entry_name = null)
    {
        $this->putStreamFileActionWithHttpInfo($server_name, $action, $media_caster_type, $vhost_name, $streamfile_name, $connect_app_name, $app_nstance, $dst_entry_name);
    }

    /**
     * Operation putStreamFileActionWithHttpInfo
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $media_caster_type The MediaCasterType to use for the connection (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $streamfile_name The stream file, file name needed for this REST call (required)
     * @param  string $connect_app_name The name of the application to connect to (optional)
     * @param  string $app_nstance The name of the application instance to connect to (optional)
     * @param  string $dst_entry_name The destination stream file name when copying (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putStreamFileActionWithHttpInfo($server_name, $action, $media_caster_type, $vhost_name, $streamfile_name, $connect_app_name = null, $app_nstance = null, $dst_entry_name = null)
    {
        $returnType = '';
        $request = $this->putStreamFileActionRequest($server_name, $action, $media_caster_type, $vhost_name, $streamfile_name, $connect_app_name, $app_nstance, $dst_entry_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putStreamFileActionAsync
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $media_caster_type The MediaCasterType to use for the connection (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $streamfile_name The stream file, file name needed for this REST call (required)
     * @param  string $connect_app_name The name of the application to connect to (optional)
     * @param  string $app_nstance The name of the application instance to connect to (optional)
     * @param  string $dst_entry_name The destination stream file name when copying (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putStreamFileActionAsync($server_name, $action, $media_caster_type, $vhost_name, $streamfile_name, $connect_app_name = null, $app_nstance = null, $dst_entry_name = null)
    {
        return $this->putStreamFileActionAsyncWithHttpInfo($server_name, $action, $media_caster_type, $vhost_name, $streamfile_name, $connect_app_name, $app_nstance, $dst_entry_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putStreamFileActionAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $media_caster_type The MediaCasterType to use for the connection (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $streamfile_name The stream file, file name needed for this REST call (required)
     * @param  string $connect_app_name The name of the application to connect to (optional)
     * @param  string $app_nstance The name of the application instance to connect to (optional)
     * @param  string $dst_entry_name The destination stream file name when copying (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putStreamFileActionAsyncWithHttpInfo($server_name, $action, $media_caster_type, $vhost_name, $streamfile_name, $connect_app_name = null, $app_nstance = null, $dst_entry_name = null)
    {
        $returnType = '';
        $request = $this->putStreamFileActionRequest($server_name, $action, $media_caster_type, $vhost_name, $streamfile_name, $connect_app_name, $app_nstance, $dst_entry_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putStreamFileAction'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $media_caster_type The MediaCasterType to use for the connection (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $streamfile_name The stream file, file name needed for this REST call (required)
     * @param  string $connect_app_name The name of the application to connect to (optional)
     * @param  string $app_nstance The name of the application instance to connect to (optional)
     * @param  string $dst_entry_name The destination stream file name when copying (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putStreamFileActionRequest($server_name, $action, $media_caster_type, $vhost_name, $streamfile_name, $connect_app_name = null, $app_nstance = null, $dst_entry_name = null)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putStreamFileAction'
            );
        }
        // verify the required parameter 'action' is set
        if ($action === null || (is_array($action) && count($action) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $action when calling putStreamFileAction'
            );
        }
        // verify the required parameter 'media_caster_type' is set
        if ($media_caster_type === null || (is_array($media_caster_type) && count($media_caster_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $media_caster_type when calling putStreamFileAction'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putStreamFileAction'
            );
        }
        // verify the required parameter 'streamfile_name' is set
        if ($streamfile_name === null || (is_array($streamfile_name) && count($streamfile_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $streamfile_name when calling putStreamFileAction'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/streamfiles/{streamfileName}/actions/{action}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($connect_app_name !== null) {
            $queryParams['connectAppName'] = ObjectSerializer::toQueryValue($connect_app_name);
        }
        // query params
        if ($app_nstance !== null) {
            $queryParams['appInstance'] = ObjectSerializer::toQueryValue($app_nstance);
        }
        // query params
        if ($media_caster_type !== null) {
            $queryParams['mediaCasterType'] = ObjectSerializer::toQueryValue($media_caster_type);
        }
        // query params
        if ($dst_entry_name !== null) {
            $queryParams['dstEntryName'] = ObjectSerializer::toQueryValue($dst_entry_name);
        }

        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($action !== null) {
            $resourcePath = str_replace(
                '{' . 'action' . '}',
                ObjectSerializer::toPathValue($action),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($streamfile_name !== null) {
            $resourcePath = str_replace(
                '{' . 'streamfileName' . '}',
                ObjectSerializer::toPathValue($streamfile_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putStreamFileConfig
     *
     * Updates the specified Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     * @param  \Swagger\Client\Model\StreamFileConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putStreamFileConfig($server_name, $vhost_name, $streamfile_name, $body)
    {
        $this->putStreamFileConfigWithHttpInfo($server_name, $vhost_name, $streamfile_name, $body);
    }

    /**
     * Operation putStreamFileConfigWithHttpInfo
     *
     * Updates the specified Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     * @param  \Swagger\Client\Model\StreamFileConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putStreamFileConfigWithHttpInfo($server_name, $vhost_name, $streamfile_name, $body)
    {
        $returnType = '';
        $request = $this->putStreamFileConfigRequest($server_name, $vhost_name, $streamfile_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putStreamFileConfigAsync
     *
     * Updates the specified Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     * @param  \Swagger\Client\Model\StreamFileConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putStreamFileConfigAsync($server_name, $vhost_name, $streamfile_name, $body)
    {
        return $this->putStreamFileConfigAsyncWithHttpInfo($server_name, $vhost_name, $streamfile_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putStreamFileConfigAsyncWithHttpInfo
     *
     * Updates the specified Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     * @param  \Swagger\Client\Model\StreamFileConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putStreamFileConfigAsyncWithHttpInfo($server_name, $vhost_name, $streamfile_name, $body)
    {
        $returnType = '';
        $request = $this->putStreamFileConfigRequest($server_name, $vhost_name, $streamfile_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putStreamFileConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     * @param  \Swagger\Client\Model\StreamFileConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putStreamFileConfigRequest($server_name, $vhost_name, $streamfile_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putStreamFileConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putStreamFileConfig'
            );
        }
        // verify the required parameter 'streamfile_name' is set
        if ($streamfile_name === null || (is_array($streamfile_name) && count($streamfile_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $streamfile_name when calling putStreamFileConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putStreamFileConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/streamfiles/{streamfileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($streamfile_name !== null) {
            $resourcePath = str_replace(
                '{' . 'streamfileName' . '}',
                ObjectSerializer::toPathValue($streamfile_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putStreamFileConfigAdv
     *
     * Updates the Advanced Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $streamfile_name The stream file name without the .stream extension (required)
     * @param  \Swagger\Client\Model\StreamFileConfigAdv $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putStreamFileConfigAdv($server_name, $vhost_name, $streamfile_name, $body)
    {
        $this->putStreamFileConfigAdvWithHttpInfo($server_name, $vhost_name, $streamfile_name, $body);
    }

    /**
     * Operation putStreamFileConfigAdvWithHttpInfo
     *
     * Updates the Advanced Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the .stream extension (required)
     * @param  \Swagger\Client\Model\StreamFileConfigAdv $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putStreamFileConfigAdvWithHttpInfo($server_name, $vhost_name, $streamfile_name, $body)
    {
        $returnType = '';
        $request = $this->putStreamFileConfigAdvRequest($server_name, $vhost_name, $streamfile_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putStreamFileConfigAdvAsync
     *
     * Updates the Advanced Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the .stream extension (required)
     * @param  \Swagger\Client\Model\StreamFileConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putStreamFileConfigAdvAsync($server_name, $vhost_name, $streamfile_name, $body)
    {
        return $this->putStreamFileConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $streamfile_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putStreamFileConfigAdvAsyncWithHttpInfo
     *
     * Updates the Advanced Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the .stream extension (required)
     * @param  \Swagger\Client\Model\StreamFileConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putStreamFileConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $streamfile_name, $body)
    {
        $returnType = '';
        $request = $this->putStreamFileConfigAdvRequest($server_name, $vhost_name, $streamfile_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putStreamFileConfigAdv'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the .stream extension (required)
     * @param  \Swagger\Client\Model\StreamFileConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putStreamFileConfigAdvRequest($server_name, $vhost_name, $streamfile_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putStreamFileConfigAdv'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putStreamFileConfigAdv'
            );
        }
        // verify the required parameter 'streamfile_name' is set
        if ($streamfile_name === null || (is_array($streamfile_name) && count($streamfile_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $streamfile_name when calling putStreamFileConfigAdv'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putStreamFileConfigAdv'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/streamfiles/{streamfileName}/adv';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($streamfile_name !== null) {
            $resourcePath = str_replace(
                '{' . 'streamfileName' . '}',
                ObjectSerializer::toPathValue($streamfile_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putTranscoderConfig
     *
     * Updates the Transcoder configuration for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  \Swagger\Client\Model\TranscoderConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putTranscoderConfig($server_name, $vhost_name, $body)
    {
        $this->putTranscoderConfigWithHttpInfo($server_name, $vhost_name, $body);
    }

    /**
     * Operation putTranscoderConfigWithHttpInfo
     *
     * Updates the Transcoder configuration for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  \Swagger\Client\Model\TranscoderConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putTranscoderConfigWithHttpInfo($server_name, $vhost_name, $body)
    {
        $returnType = '';
        $request = $this->putTranscoderConfigRequest($server_name, $vhost_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putTranscoderConfigAsync
     *
     * Updates the Transcoder configuration for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  \Swagger\Client\Model\TranscoderConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderConfigAsync($server_name, $vhost_name, $body)
    {
        return $this->putTranscoderConfigAsyncWithHttpInfo($server_name, $vhost_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putTranscoderConfigAsyncWithHttpInfo
     *
     * Updates the Transcoder configuration for the specified VHost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  \Swagger\Client\Model\TranscoderConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderConfigAsyncWithHttpInfo($server_name, $vhost_name, $body)
    {
        $returnType = '';
        $request = $this->putTranscoderConfigRequest($server_name, $vhost_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putTranscoderConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  \Swagger\Client\Model\TranscoderConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putTranscoderConfigRequest($server_name, $vhost_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putTranscoderConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putTranscoderConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putTranscoderConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/transcoder';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putTranscoderEncodeConfig
     *
     * Updates the specified Trancoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $encode_name encode_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putTranscoderEncodeConfig($server_name, $vhost_name, $template_name, $encode_name, $body)
    {
        $this->putTranscoderEncodeConfigWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $body);
    }

    /**
     * Operation putTranscoderEncodeConfigWithHttpInfo
     *
     * Updates the specified Trancoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putTranscoderEncodeConfigWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $body)
    {
        $returnType = '';
        $request = $this->putTranscoderEncodeConfigRequest($server_name, $vhost_name, $template_name, $encode_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putTranscoderEncodeConfigAsync
     *
     * Updates the specified Trancoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderEncodeConfigAsync($server_name, $vhost_name, $template_name, $encode_name, $body)
    {
        return $this->putTranscoderEncodeConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putTranscoderEncodeConfigAsyncWithHttpInfo
     *
     * Updates the specified Trancoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderEncodeConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $body)
    {
        $returnType = '';
        $request = $this->putTranscoderEncodeConfigRequest($server_name, $vhost_name, $template_name, $encode_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putTranscoderEncodeConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putTranscoderEncodeConfigRequest($server_name, $vhost_name, $template_name, $encode_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putTranscoderEncodeConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putTranscoderEncodeConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling putTranscoderEncodeConfig'
            );
        }
        // verify the required parameter 'encode_name' is set
        if ($encode_name === null || (is_array($encode_name) && count($encode_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $encode_name when calling putTranscoderEncodeConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putTranscoderEncodeConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/transcoder/templates/{templateName}/encodes/{encodeName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($encode_name !== null) {
            $resourcePath = str_replace(
                '{' . 'encodeName' . '}',
                ObjectSerializer::toPathValue($encode_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putTranscoderEncodeConfigAdv
     *
     * Updates the Advanced Transcoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $encode_name encode_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeConfigAdv $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putTranscoderEncodeConfigAdv($server_name, $vhost_name, $template_name, $encode_name, $body)
    {
        $this->putTranscoderEncodeConfigAdvWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $body);
    }

    /**
     * Operation putTranscoderEncodeConfigAdvWithHttpInfo
     *
     * Updates the Advanced Transcoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeConfigAdv $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putTranscoderEncodeConfigAdvWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $body)
    {
        $returnType = '';
        $request = $this->putTranscoderEncodeConfigAdvRequest($server_name, $vhost_name, $template_name, $encode_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putTranscoderEncodeConfigAdvAsync
     *
     * Updates the Advanced Transcoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderEncodeConfigAdvAsync($server_name, $vhost_name, $template_name, $encode_name, $body)
    {
        return $this->putTranscoderEncodeConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putTranscoderEncodeConfigAdvAsyncWithHttpInfo
     *
     * Updates the Advanced Transcoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderEncodeConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $body)
    {
        $returnType = '';
        $request = $this->putTranscoderEncodeConfigAdvRequest($server_name, $vhost_name, $template_name, $encode_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putTranscoderEncodeConfigAdv'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putTranscoderEncodeConfigAdvRequest($server_name, $vhost_name, $template_name, $encode_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putTranscoderEncodeConfigAdv'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putTranscoderEncodeConfigAdv'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling putTranscoderEncodeConfigAdv'
            );
        }
        // verify the required parameter 'encode_name' is set
        if ($encode_name === null || (is_array($encode_name) && count($encode_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $encode_name when calling putTranscoderEncodeConfigAdv'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putTranscoderEncodeConfigAdv'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/transcoder/templates/{templateName}/encodes/{encodeName}/adv';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($encode_name !== null) {
            $resourcePath = str_replace(
                '{' . 'encodeName' . '}',
                ObjectSerializer::toPathValue($encode_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putTranscoderOverlayDecodeConfig
     *
     * Updates the specified Trancoder Overlay Decode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $overlay_name overlay_name (required)
     * @param  \Swagger\Client\Model\TranscoderOverlayDecodeConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putTranscoderOverlayDecodeConfig($server_name, $vhost_name, $template_name, $overlay_name, $body)
    {
        $this->putTranscoderOverlayDecodeConfigWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $body);
    }

    /**
     * Operation putTranscoderOverlayDecodeConfigWithHttpInfo
     *
     * Updates the specified Trancoder Overlay Decode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  \Swagger\Client\Model\TranscoderOverlayDecodeConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putTranscoderOverlayDecodeConfigWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $body)
    {
        $returnType = '';
        $request = $this->putTranscoderOverlayDecodeConfigRequest($server_name, $vhost_name, $template_name, $overlay_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putTranscoderOverlayDecodeConfigAsync
     *
     * Updates the specified Trancoder Overlay Decode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  \Swagger\Client\Model\TranscoderOverlayDecodeConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderOverlayDecodeConfigAsync($server_name, $vhost_name, $template_name, $overlay_name, $body)
    {
        return $this->putTranscoderOverlayDecodeConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putTranscoderOverlayDecodeConfigAsyncWithHttpInfo
     *
     * Updates the specified Trancoder Overlay Decode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  \Swagger\Client\Model\TranscoderOverlayDecodeConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderOverlayDecodeConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $body)
    {
        $returnType = '';
        $request = $this->putTranscoderOverlayDecodeConfigRequest($server_name, $vhost_name, $template_name, $overlay_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putTranscoderOverlayDecodeConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  \Swagger\Client\Model\TranscoderOverlayDecodeConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putTranscoderOverlayDecodeConfigRequest($server_name, $vhost_name, $template_name, $overlay_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putTranscoderOverlayDecodeConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putTranscoderOverlayDecodeConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling putTranscoderOverlayDecodeConfig'
            );
        }
        // verify the required parameter 'overlay_name' is set
        if ($overlay_name === null || (is_array($overlay_name) && count($overlay_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $overlay_name when calling putTranscoderOverlayDecodeConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putTranscoderOverlayDecodeConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/transcoder/templates/{templateName}/decode/overlays/{overlayName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($overlay_name !== null) {
            $resourcePath = str_replace(
                '{' . 'overlayName' . '}',
                ObjectSerializer::toPathValue($overlay_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putTranscoderOverlayEncodeConfig
     *
     * Updates the specified Trancoder Overlay Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $overlay_name overlay_name (required)
     * @param  string $encode_name encode_name (required)
     * @param  \Swagger\Client\Model\TranscoderOverlayEncodeConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putTranscoderOverlayEncodeConfig($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $body)
    {
        $this->putTranscoderOverlayEncodeConfigWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $body);
    }

    /**
     * Operation putTranscoderOverlayEncodeConfigWithHttpInfo
     *
     * Updates the specified Trancoder Overlay Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $encode_name (required)
     * @param  \Swagger\Client\Model\TranscoderOverlayEncodeConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putTranscoderOverlayEncodeConfigWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $body)
    {
        $returnType = '';
        $request = $this->putTranscoderOverlayEncodeConfigRequest($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putTranscoderOverlayEncodeConfigAsync
     *
     * Updates the specified Trancoder Overlay Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $encode_name (required)
     * @param  \Swagger\Client\Model\TranscoderOverlayEncodeConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderOverlayEncodeConfigAsync($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $body)
    {
        return $this->putTranscoderOverlayEncodeConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putTranscoderOverlayEncodeConfigAsyncWithHttpInfo
     *
     * Updates the specified Trancoder Overlay Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $encode_name (required)
     * @param  \Swagger\Client\Model\TranscoderOverlayEncodeConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderOverlayEncodeConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $body)
    {
        $returnType = '';
        $request = $this->putTranscoderOverlayEncodeConfigRequest($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putTranscoderOverlayEncodeConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $encode_name (required)
     * @param  \Swagger\Client\Model\TranscoderOverlayEncodeConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putTranscoderOverlayEncodeConfigRequest($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putTranscoderOverlayEncodeConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putTranscoderOverlayEncodeConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling putTranscoderOverlayEncodeConfig'
            );
        }
        // verify the required parameter 'overlay_name' is set
        if ($overlay_name === null || (is_array($overlay_name) && count($overlay_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $overlay_name when calling putTranscoderOverlayEncodeConfig'
            );
        }
        // verify the required parameter 'encode_name' is set
        if ($encode_name === null || (is_array($encode_name) && count($encode_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $encode_name when calling putTranscoderOverlayEncodeConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putTranscoderOverlayEncodeConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/transcoder/templates/{templateName}/encodes/{encodeName}/overlays/{overlayName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($overlay_name !== null) {
            $resourcePath = str_replace(
                '{' . 'overlayName' . '}',
                ObjectSerializer::toPathValue($overlay_name),
                $resourcePath
            );
        }
        // path params
        if ($encode_name !== null) {
            $resourcePath = str_replace(
                '{' . 'encodeName' . '}',
                ObjectSerializer::toPathValue($encode_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putTranscoderStreamNameGroupConfig
     *
     * Updates the specified Trancoder StreamNameGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $group_name group_name (required)
     * @param  \Swagger\Client\Model\TranscoderStreamNameGroupConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putTranscoderStreamNameGroupConfig($server_name, $vhost_name, $template_name, $group_name, $body)
    {
        $this->putTranscoderStreamNameGroupConfigWithHttpInfo($server_name, $vhost_name, $template_name, $group_name, $body);
    }

    /**
     * Operation putTranscoderStreamNameGroupConfigWithHttpInfo
     *
     * Updates the specified Trancoder StreamNameGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $group_name (required)
     * @param  \Swagger\Client\Model\TranscoderStreamNameGroupConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putTranscoderStreamNameGroupConfigWithHttpInfo($server_name, $vhost_name, $template_name, $group_name, $body)
    {
        $returnType = '';
        $request = $this->putTranscoderStreamNameGroupConfigRequest($server_name, $vhost_name, $template_name, $group_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putTranscoderStreamNameGroupConfigAsync
     *
     * Updates the specified Trancoder StreamNameGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $group_name (required)
     * @param  \Swagger\Client\Model\TranscoderStreamNameGroupConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderStreamNameGroupConfigAsync($server_name, $vhost_name, $template_name, $group_name, $body)
    {
        return $this->putTranscoderStreamNameGroupConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $group_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putTranscoderStreamNameGroupConfigAsyncWithHttpInfo
     *
     * Updates the specified Trancoder StreamNameGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $group_name (required)
     * @param  \Swagger\Client\Model\TranscoderStreamNameGroupConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderStreamNameGroupConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $group_name, $body)
    {
        $returnType = '';
        $request = $this->putTranscoderStreamNameGroupConfigRequest($server_name, $vhost_name, $template_name, $group_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putTranscoderStreamNameGroupConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $group_name (required)
     * @param  \Swagger\Client\Model\TranscoderStreamNameGroupConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putTranscoderStreamNameGroupConfigRequest($server_name, $vhost_name, $template_name, $group_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putTranscoderStreamNameGroupConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putTranscoderStreamNameGroupConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling putTranscoderStreamNameGroupConfig'
            );
        }
        // verify the required parameter 'group_name' is set
        if ($group_name === null || (is_array($group_name) && count($group_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_name when calling putTranscoderStreamNameGroupConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putTranscoderStreamNameGroupConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/transcoder/templates/{templateName}/streamnamegroups/{groupName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($group_name !== null) {
            $resourcePath = str_replace(
                '{' . 'groupName' . '}',
                ObjectSerializer::toPathValue($group_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putTranscoderTemplateAction
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $template_name The template name needed for this REST call (required)
     * @param  string $dst_entry_name The destination transcoder template name when copying (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putTranscoderTemplateAction($server_name, $action, $vhost_name, $template_name, $dst_entry_name = null)
    {
        $this->putTranscoderTemplateActionWithHttpInfo($server_name, $action, $vhost_name, $template_name, $dst_entry_name);
    }

    /**
     * Operation putTranscoderTemplateActionWithHttpInfo
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $template_name The template name needed for this REST call (required)
     * @param  string $dst_entry_name The destination transcoder template name when copying (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putTranscoderTemplateActionWithHttpInfo($server_name, $action, $vhost_name, $template_name, $dst_entry_name = null)
    {
        $returnType = '';
        $request = $this->putTranscoderTemplateActionRequest($server_name, $action, $vhost_name, $template_name, $dst_entry_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putTranscoderTemplateActionAsync
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $template_name The template name needed for this REST call (required)
     * @param  string $dst_entry_name The destination transcoder template name when copying (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderTemplateActionAsync($server_name, $action, $vhost_name, $template_name, $dst_entry_name = null)
    {
        return $this->putTranscoderTemplateActionAsyncWithHttpInfo($server_name, $action, $vhost_name, $template_name, $dst_entry_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putTranscoderTemplateActionAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $template_name The template name needed for this REST call (required)
     * @param  string $dst_entry_name The destination transcoder template name when copying (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderTemplateActionAsyncWithHttpInfo($server_name, $action, $vhost_name, $template_name, $dst_entry_name = null)
    {
        $returnType = '';
        $request = $this->putTranscoderTemplateActionRequest($server_name, $action, $vhost_name, $template_name, $dst_entry_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putTranscoderTemplateAction'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $template_name The template name needed for this REST call (required)
     * @param  string $dst_entry_name The destination transcoder template name when copying (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putTranscoderTemplateActionRequest($server_name, $action, $vhost_name, $template_name, $dst_entry_name = null)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putTranscoderTemplateAction'
            );
        }
        // verify the required parameter 'action' is set
        if ($action === null || (is_array($action) && count($action) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $action when calling putTranscoderTemplateAction'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putTranscoderTemplateAction'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling putTranscoderTemplateAction'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/transcoder/templates/{templateName}/actions/{action}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($dst_entry_name !== null) {
            $queryParams['dstEntryName'] = ObjectSerializer::toQueryValue($dst_entry_name);
        }

        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($action !== null) {
            $resourcePath = str_replace(
                '{' . 'action' . '}',
                ObjectSerializer::toPathValue($action),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putTranscoderTemplateConfig
     *
     * Updates the specified Trancoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putTranscoderTemplateConfig($server_name, $vhost_name, $template_name, $body)
    {
        $this->putTranscoderTemplateConfigWithHttpInfo($server_name, $vhost_name, $template_name, $body);
    }

    /**
     * Operation putTranscoderTemplateConfigWithHttpInfo
     *
     * Updates the specified Trancoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putTranscoderTemplateConfigWithHttpInfo($server_name, $vhost_name, $template_name, $body)
    {
        $returnType = '';
        $request = $this->putTranscoderTemplateConfigRequest($server_name, $vhost_name, $template_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putTranscoderTemplateConfigAsync
     *
     * Updates the specified Trancoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderTemplateConfigAsync($server_name, $vhost_name, $template_name, $body)
    {
        return $this->putTranscoderTemplateConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putTranscoderTemplateConfigAsyncWithHttpInfo
     *
     * Updates the specified Trancoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderTemplateConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $body)
    {
        $returnType = '';
        $request = $this->putTranscoderTemplateConfigRequest($server_name, $vhost_name, $template_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putTranscoderTemplateConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putTranscoderTemplateConfigRequest($server_name, $vhost_name, $template_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putTranscoderTemplateConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putTranscoderTemplateConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling putTranscoderTemplateConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putTranscoderTemplateConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/transcoder/templates/{templateName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putTranscoderTemplateConfigAdv
     *
     * Updates the Advanced Transcoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateConfigAdv $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putTranscoderTemplateConfigAdv($server_name, $vhost_name, $template_name, $body)
    {
        $this->putTranscoderTemplateConfigAdvWithHttpInfo($server_name, $vhost_name, $template_name, $body);
    }

    /**
     * Operation putTranscoderTemplateConfigAdvWithHttpInfo
     *
     * Updates the Advanced Transcoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateConfigAdv $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putTranscoderTemplateConfigAdvWithHttpInfo($server_name, $vhost_name, $template_name, $body)
    {
        $returnType = '';
        $request = $this->putTranscoderTemplateConfigAdvRequest($server_name, $vhost_name, $template_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putTranscoderTemplateConfigAdvAsync
     *
     * Updates the Advanced Transcoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderTemplateConfigAdvAsync($server_name, $vhost_name, $template_name, $body)
    {
        return $this->putTranscoderTemplateConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putTranscoderTemplateConfigAdvAsyncWithHttpInfo
     *
     * Updates the Advanced Transcoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderTemplateConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $body)
    {
        $returnType = '';
        $request = $this->putTranscoderTemplateConfigAdvRequest($server_name, $vhost_name, $template_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putTranscoderTemplateConfigAdv'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putTranscoderTemplateConfigAdvRequest($server_name, $vhost_name, $template_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putTranscoderTemplateConfigAdv'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putTranscoderTemplateConfigAdv'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling putTranscoderTemplateConfigAdv'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putTranscoderTemplateConfigAdv'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/transcoder/templates/{templateName}/adv';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putVHostAction
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putVHostAction($server_name, $action, $vhost_name)
    {
        $this->putVHostActionWithHttpInfo($server_name, $action, $vhost_name);
    }

    /**
     * Operation putVHostActionWithHttpInfo
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putVHostActionWithHttpInfo($server_name, $action, $vhost_name)
    {
        $returnType = '';
        $request = $this->putVHostActionRequest($server_name, $action, $vhost_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putVHostActionAsync
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putVHostActionAsync($server_name, $action, $vhost_name)
    {
        return $this->putVHostActionAsyncWithHttpInfo($server_name, $action, $vhost_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putVHostActionAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putVHostActionAsyncWithHttpInfo($server_name, $action, $vhost_name)
    {
        $returnType = '';
        $request = $this->putVHostActionRequest($server_name, $action, $vhost_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putVHostAction'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putVHostActionRequest($server_name, $action, $vhost_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putVHostAction'
            );
        }
        // verify the required parameter 'action' is set
        if ($action === null || (is_array($action) && count($action) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $action when calling putVHostAction'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putVHostAction'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/actions/{action}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($action !== null) {
            $resourcePath = str_replace(
                '{' . 'action' . '}',
                ObjectSerializer::toPathValue($action),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putVHostConfig
     *
     * Updates the specified VHost configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  \Swagger\Client\Model\VHostConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putVHostConfig($server_name, $vhost_name, $body)
    {
        $this->putVHostConfigWithHttpInfo($server_name, $vhost_name, $body);
    }

    /**
     * Operation putVHostConfigWithHttpInfo
     *
     * Updates the specified VHost configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  \Swagger\Client\Model\VHostConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putVHostConfigWithHttpInfo($server_name, $vhost_name, $body)
    {
        $returnType = '';
        $request = $this->putVHostConfigRequest($server_name, $vhost_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putVHostConfigAsync
     *
     * Updates the specified VHost configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  \Swagger\Client\Model\VHostConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putVHostConfigAsync($server_name, $vhost_name, $body)
    {
        return $this->putVHostConfigAsyncWithHttpInfo($server_name, $vhost_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putVHostConfigAsyncWithHttpInfo
     *
     * Updates the specified VHost configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  \Swagger\Client\Model\VHostConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putVHostConfigAsyncWithHttpInfo($server_name, $vhost_name, $body)
    {
        $returnType = '';
        $request = $this->putVHostConfigRequest($server_name, $vhost_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putVHostConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  \Swagger\Client\Model\VHostConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putVHostConfigRequest($server_name, $vhost_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putVHostConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putVHostConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putVHostConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putVHostConfigAdv
     *
     * Updates the specified advanced VHost configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  \Swagger\Client\Model\VHostConfigAdv $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putVHostConfigAdv($server_name, $vhost_name, $body)
    {
        $this->putVHostConfigAdvWithHttpInfo($server_name, $vhost_name, $body);
    }

    /**
     * Operation putVHostConfigAdvWithHttpInfo
     *
     * Updates the specified advanced VHost configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  \Swagger\Client\Model\VHostConfigAdv $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putVHostConfigAdvWithHttpInfo($server_name, $vhost_name, $body)
    {
        $returnType = '';
        $request = $this->putVHostConfigAdvRequest($server_name, $vhost_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putVHostConfigAdvAsync
     *
     * Updates the specified advanced VHost configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  \Swagger\Client\Model\VHostConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putVHostConfigAdvAsync($server_name, $vhost_name, $body)
    {
        return $this->putVHostConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putVHostConfigAdvAsyncWithHttpInfo
     *
     * Updates the specified advanced VHost configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  \Swagger\Client\Model\VHostConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putVHostConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $body)
    {
        $returnType = '';
        $request = $this->putVHostConfigAdvRequest($server_name, $vhost_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putVHostConfigAdv'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  \Swagger\Client\Model\VHostConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putVHostConfigAdvRequest($server_name, $vhost_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putVHostConfigAdv'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putVHostConfigAdv'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putVHostConfigAdv'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/adv';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putVHostTuneConfig
     *
     * Updates the Tuning configuration for the specifed vhost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  \Swagger\Client\Model\VHostTuneConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putVHostTuneConfig($server_name, $vhost_name, $body)
    {
        $this->putVHostTuneConfigWithHttpInfo($server_name, $vhost_name, $body);
    }

    /**
     * Operation putVHostTuneConfigWithHttpInfo
     *
     * Updates the Tuning configuration for the specifed vhost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  \Swagger\Client\Model\VHostTuneConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putVHostTuneConfigWithHttpInfo($server_name, $vhost_name, $body)
    {
        $returnType = '';
        $request = $this->putVHostTuneConfigRequest($server_name, $vhost_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putVHostTuneConfigAsync
     *
     * Updates the Tuning configuration for the specifed vhost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  \Swagger\Client\Model\VHostTuneConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putVHostTuneConfigAsync($server_name, $vhost_name, $body)
    {
        return $this->putVHostTuneConfigAsyncWithHttpInfo($server_name, $vhost_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putVHostTuneConfigAsyncWithHttpInfo
     *
     * Updates the Tuning configuration for the specifed vhost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  \Swagger\Client\Model\VHostTuneConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putVHostTuneConfigAsyncWithHttpInfo($server_name, $vhost_name, $body)
    {
        $returnType = '';
        $request = $this->putVHostTuneConfigRequest($server_name, $vhost_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putVHostTuneConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  \Swagger\Client\Model\VHostTuneConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putVHostTuneConfigRequest($server_name, $vhost_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putVHostTuneConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putVHostTuneConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putVHostTuneConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/tune';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
