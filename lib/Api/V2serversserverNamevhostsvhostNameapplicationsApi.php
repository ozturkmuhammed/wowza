<?php
/**
 * V2serversserverNamevhostsvhostNameapplicationsApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.14
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * V2serversserverNamevhostsvhostNameapplicationsApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class V2serversserverNamevhostsvhostNameapplicationsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation deleteApplicationConfig
     *
     * Deletes the specified Application configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteApplicationConfig($server_name, $vhost_name, $app_name)
    {
        $this->deleteApplicationConfigWithHttpInfo($server_name, $vhost_name, $app_name);
    }

    /**
     * Operation deleteApplicationConfigWithHttpInfo
     *
     * Deletes the specified Application configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteApplicationConfigWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '';
        $request = $this->deleteApplicationConfigRequest($server_name, $vhost_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteApplicationConfigAsync
     *
     * Deletes the specified Application configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteApplicationConfigAsync($server_name, $vhost_name, $app_name)
    {
        return $this->deleteApplicationConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteApplicationConfigAsyncWithHttpInfo
     *
     * Deletes the specified Application configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteApplicationConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '';
        $request = $this->deleteApplicationConfigRequest($server_name, $vhost_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteApplicationConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteApplicationConfigRequest($server_name, $vhost_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling deleteApplicationConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling deleteApplicationConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling deleteApplicationConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePublisherAppConfig
     *
     * Deletes the specified Publisher configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deletePublisherAppConfig($server_name, $vhost_name, $publisher_name, $app_name)
    {
        $this->deletePublisherAppConfigWithHttpInfo($server_name, $vhost_name, $publisher_name, $app_name);
    }

    /**
     * Operation deletePublisherAppConfigWithHttpInfo
     *
     * Deletes the specified Publisher configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePublisherAppConfigWithHttpInfo($server_name, $vhost_name, $publisher_name, $app_name)
    {
        $returnType = '';
        $request = $this->deletePublisherAppConfigRequest($server_name, $vhost_name, $publisher_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deletePublisherAppConfigAsync
     *
     * Deletes the specified Publisher configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePublisherAppConfigAsync($server_name, $vhost_name, $publisher_name, $app_name)
    {
        return $this->deletePublisherAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $publisher_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePublisherAppConfigAsyncWithHttpInfo
     *
     * Deletes the specified Publisher configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePublisherAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $publisher_name, $app_name)
    {
        $returnType = '';
        $request = $this->deletePublisherAppConfigRequest($server_name, $vhost_name, $publisher_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePublisherAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePublisherAppConfigRequest($server_name, $vhost_name, $publisher_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling deletePublisherAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling deletePublisherAppConfig'
            );
        }
        // verify the required parameter 'publisher_name' is set
        if ($publisher_name === null || (is_array($publisher_name) && count($publisher_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $publisher_name when calling deletePublisherAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling deletePublisherAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/publishers/{publisherName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($publisher_name !== null) {
            $resourcePath = str_replace(
                '{' . 'publisherName' . '}',
                ObjectSerializer::toPathValue($publisher_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePushPublishStreamAppConfig
     *
     * Deletes the specified PushPublish map entry for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  string $entry_name The entry name needed for this REST call (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deletePushPublishStreamAppConfig($server_name, $vhost_name, $app_name, $entry_name)
    {
        $this->deletePushPublishStreamAppConfigWithHttpInfo($server_name, $vhost_name, $app_name, $entry_name);
    }

    /**
     * Operation deletePushPublishStreamAppConfigWithHttpInfo
     *
     * Deletes the specified PushPublish map entry for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $entry_name The entry name needed for this REST call (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePushPublishStreamAppConfigWithHttpInfo($server_name, $vhost_name, $app_name, $entry_name)
    {
        $returnType = '';
        $request = $this->deletePushPublishStreamAppConfigRequest($server_name, $vhost_name, $app_name, $entry_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deletePushPublishStreamAppConfigAsync
     *
     * Deletes the specified PushPublish map entry for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $entry_name The entry name needed for this REST call (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePushPublishStreamAppConfigAsync($server_name, $vhost_name, $app_name, $entry_name)
    {
        return $this->deletePushPublishStreamAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $entry_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePushPublishStreamAppConfigAsyncWithHttpInfo
     *
     * Deletes the specified PushPublish map entry for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $entry_name The entry name needed for this REST call (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePushPublishStreamAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $entry_name)
    {
        $returnType = '';
        $request = $this->deletePushPublishStreamAppConfigRequest($server_name, $vhost_name, $app_name, $entry_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePushPublishStreamAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $entry_name The entry name needed for this REST call (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePushPublishStreamAppConfigRequest($server_name, $vhost_name, $app_name, $entry_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling deletePushPublishStreamAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling deletePushPublishStreamAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling deletePushPublishStreamAppConfig'
            );
        }
        // verify the required parameter 'entry_name' is set
        if ($entry_name === null || (is_array($entry_name) && count($entry_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entry_name when calling deletePushPublishStreamAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/pushpublish/mapentries/{entryName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($entry_name !== null) {
            $resourcePath = str_replace(
                '{' . 'entryName' . '}',
                ObjectSerializer::toPathValue($entry_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteSDPFileAppConfig
     *
     * Deletes the specified SDP file
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $sdpfile_name The SDP file name without the extension (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteSDPFileAppConfig($server_name, $vhost_name, $sdpfile_name, $app_name)
    {
        $this->deleteSDPFileAppConfigWithHttpInfo($server_name, $vhost_name, $sdpfile_name, $app_name);
    }

    /**
     * Operation deleteSDPFileAppConfigWithHttpInfo
     *
     * Deletes the specified SDP file
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $sdpfile_name The SDP file name without the extension (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteSDPFileAppConfigWithHttpInfo($server_name, $vhost_name, $sdpfile_name, $app_name)
    {
        $returnType = '';
        $request = $this->deleteSDPFileAppConfigRequest($server_name, $vhost_name, $sdpfile_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteSDPFileAppConfigAsync
     *
     * Deletes the specified SDP file
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $sdpfile_name The SDP file name without the extension (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSDPFileAppConfigAsync($server_name, $vhost_name, $sdpfile_name, $app_name)
    {
        return $this->deleteSDPFileAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $sdpfile_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteSDPFileAppConfigAsyncWithHttpInfo
     *
     * Deletes the specified SDP file
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $sdpfile_name The SDP file name without the extension (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSDPFileAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $sdpfile_name, $app_name)
    {
        $returnType = '';
        $request = $this->deleteSDPFileAppConfigRequest($server_name, $vhost_name, $sdpfile_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteSDPFileAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $sdpfile_name The SDP file name without the extension (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteSDPFileAppConfigRequest($server_name, $vhost_name, $sdpfile_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling deleteSDPFileAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling deleteSDPFileAppConfig'
            );
        }
        // verify the required parameter 'sdpfile_name' is set
        if ($sdpfile_name === null || (is_array($sdpfile_name) && count($sdpfile_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sdpfile_name when calling deleteSDPFileAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling deleteSDPFileAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/sdpfiles/{sdpfileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($sdpfile_name !== null) {
            $resourcePath = str_replace(
                '{' . 'sdpfileName' . '}',
                ObjectSerializer::toPathValue($sdpfile_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteSMILFileAppConfig
     *
     * Deletes the specified SMIL File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteSMILFileAppConfig($server_name, $vhost_name, $smilfile_name, $app_name)
    {
        $this->deleteSMILFileAppConfigWithHttpInfo($server_name, $vhost_name, $smilfile_name, $app_name);
    }

    /**
     * Operation deleteSMILFileAppConfigWithHttpInfo
     *
     * Deletes the specified SMIL File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteSMILFileAppConfigWithHttpInfo($server_name, $vhost_name, $smilfile_name, $app_name)
    {
        $returnType = '';
        $request = $this->deleteSMILFileAppConfigRequest($server_name, $vhost_name, $smilfile_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteSMILFileAppConfigAsync
     *
     * Deletes the specified SMIL File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSMILFileAppConfigAsync($server_name, $vhost_name, $smilfile_name, $app_name)
    {
        return $this->deleteSMILFileAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $smilfile_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteSMILFileAppConfigAsyncWithHttpInfo
     *
     * Deletes the specified SMIL File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSMILFileAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $smilfile_name, $app_name)
    {
        $returnType = '';
        $request = $this->deleteSMILFileAppConfigRequest($server_name, $vhost_name, $smilfile_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteSMILFileAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteSMILFileAppConfigRequest($server_name, $vhost_name, $smilfile_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling deleteSMILFileAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling deleteSMILFileAppConfig'
            );
        }
        // verify the required parameter 'smilfile_name' is set
        if ($smilfile_name === null || (is_array($smilfile_name) && count($smilfile_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $smilfile_name when calling deleteSMILFileAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling deleteSMILFileAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/smilfiles/{smilfileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($smilfile_name !== null) {
            $resourcePath = str_replace(
                '{' . 'smilfileName' . '}',
                ObjectSerializer::toPathValue($smilfile_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteStreamFileAppConfig
     *
     * Deletes the specified Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteStreamFileAppConfig($server_name, $vhost_name, $streamfile_name, $app_name)
    {
        $this->deleteStreamFileAppConfigWithHttpInfo($server_name, $vhost_name, $streamfile_name, $app_name);
    }

    /**
     * Operation deleteStreamFileAppConfigWithHttpInfo
     *
     * Deletes the specified Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteStreamFileAppConfigWithHttpInfo($server_name, $vhost_name, $streamfile_name, $app_name)
    {
        $returnType = '';
        $request = $this->deleteStreamFileAppConfigRequest($server_name, $vhost_name, $streamfile_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteStreamFileAppConfigAsync
     *
     * Deletes the specified Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteStreamFileAppConfigAsync($server_name, $vhost_name, $streamfile_name, $app_name)
    {
        return $this->deleteStreamFileAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $streamfile_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteStreamFileAppConfigAsyncWithHttpInfo
     *
     * Deletes the specified Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteStreamFileAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $streamfile_name, $app_name)
    {
        $returnType = '';
        $request = $this->deleteStreamFileAppConfigRequest($server_name, $vhost_name, $streamfile_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteStreamFileAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteStreamFileAppConfigRequest($server_name, $vhost_name, $streamfile_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling deleteStreamFileAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling deleteStreamFileAppConfig'
            );
        }
        // verify the required parameter 'streamfile_name' is set
        if ($streamfile_name === null || (is_array($streamfile_name) && count($streamfile_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $streamfile_name when calling deleteStreamFileAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling deleteStreamFileAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/streamfiles/{streamfileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($streamfile_name !== null) {
            $resourcePath = str_replace(
                '{' . 'streamfileName' . '}',
                ObjectSerializer::toPathValue($streamfile_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTranscoderEncodeAppConfig
     *
     * Deletes the specified Trancoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $encode_name encode_name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteTranscoderEncodeAppConfig($server_name, $vhost_name, $template_name, $encode_name, $app_name)
    {
        $this->deleteTranscoderEncodeAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $app_name);
    }

    /**
     * Operation deleteTranscoderEncodeAppConfigWithHttpInfo
     *
     * Deletes the specified Trancoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTranscoderEncodeAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $app_name)
    {
        $returnType = '';
        $request = $this->deleteTranscoderEncodeAppConfigRequest($server_name, $vhost_name, $template_name, $encode_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteTranscoderEncodeAppConfigAsync
     *
     * Deletes the specified Trancoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTranscoderEncodeAppConfigAsync($server_name, $vhost_name, $template_name, $encode_name, $app_name)
    {
        return $this->deleteTranscoderEncodeAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTranscoderEncodeAppConfigAsyncWithHttpInfo
     *
     * Deletes the specified Trancoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTranscoderEncodeAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $app_name)
    {
        $returnType = '';
        $request = $this->deleteTranscoderEncodeAppConfigRequest($server_name, $vhost_name, $template_name, $encode_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTranscoderEncodeAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteTranscoderEncodeAppConfigRequest($server_name, $vhost_name, $template_name, $encode_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling deleteTranscoderEncodeAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling deleteTranscoderEncodeAppConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling deleteTranscoderEncodeAppConfig'
            );
        }
        // verify the required parameter 'encode_name' is set
        if ($encode_name === null || (is_array($encode_name) && count($encode_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $encode_name when calling deleteTranscoderEncodeAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling deleteTranscoderEncodeAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/transcoder/templates/{templateName}/encodes/{encodeName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($encode_name !== null) {
            $resourcePath = str_replace(
                '{' . 'encodeName' . '}',
                ObjectSerializer::toPathValue($encode_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTranscoderOverlayDecodeAppConfig
     *
     * Deletes the specified Trancoder Overlay Decode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $overlay_name overlay_name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteTranscoderOverlayDecodeAppConfig($server_name, $vhost_name, $template_name, $overlay_name, $app_name)
    {
        $this->deleteTranscoderOverlayDecodeAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $app_name);
    }

    /**
     * Operation deleteTranscoderOverlayDecodeAppConfigWithHttpInfo
     *
     * Deletes the specified Trancoder Overlay Decode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTranscoderOverlayDecodeAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $app_name)
    {
        $returnType = '';
        $request = $this->deleteTranscoderOverlayDecodeAppConfigRequest($server_name, $vhost_name, $template_name, $overlay_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteTranscoderOverlayDecodeAppConfigAsync
     *
     * Deletes the specified Trancoder Overlay Decode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTranscoderOverlayDecodeAppConfigAsync($server_name, $vhost_name, $template_name, $overlay_name, $app_name)
    {
        return $this->deleteTranscoderOverlayDecodeAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTranscoderOverlayDecodeAppConfigAsyncWithHttpInfo
     *
     * Deletes the specified Trancoder Overlay Decode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTranscoderOverlayDecodeAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $app_name)
    {
        $returnType = '';
        $request = $this->deleteTranscoderOverlayDecodeAppConfigRequest($server_name, $vhost_name, $template_name, $overlay_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTranscoderOverlayDecodeAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteTranscoderOverlayDecodeAppConfigRequest($server_name, $vhost_name, $template_name, $overlay_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling deleteTranscoderOverlayDecodeAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling deleteTranscoderOverlayDecodeAppConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling deleteTranscoderOverlayDecodeAppConfig'
            );
        }
        // verify the required parameter 'overlay_name' is set
        if ($overlay_name === null || (is_array($overlay_name) && count($overlay_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $overlay_name when calling deleteTranscoderOverlayDecodeAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling deleteTranscoderOverlayDecodeAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/transcoder/templates/{templateName}/decode/overlays/{overlayName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($overlay_name !== null) {
            $resourcePath = str_replace(
                '{' . 'overlayName' . '}',
                ObjectSerializer::toPathValue($overlay_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTranscoderOverlayEncodeAppConfig
     *
     * Deletes the specified Trancoder Overlay Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $overlay_name overlay_name (required)
     * @param  string $encode_name encode_name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteTranscoderOverlayEncodeAppConfig($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $app_name)
    {
        $this->deleteTranscoderOverlayEncodeAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $app_name);
    }

    /**
     * Operation deleteTranscoderOverlayEncodeAppConfigWithHttpInfo
     *
     * Deletes the specified Trancoder Overlay Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTranscoderOverlayEncodeAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $app_name)
    {
        $returnType = '';
        $request = $this->deleteTranscoderOverlayEncodeAppConfigRequest($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteTranscoderOverlayEncodeAppConfigAsync
     *
     * Deletes the specified Trancoder Overlay Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTranscoderOverlayEncodeAppConfigAsync($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $app_name)
    {
        return $this->deleteTranscoderOverlayEncodeAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTranscoderOverlayEncodeAppConfigAsyncWithHttpInfo
     *
     * Deletes the specified Trancoder Overlay Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTranscoderOverlayEncodeAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $app_name)
    {
        $returnType = '';
        $request = $this->deleteTranscoderOverlayEncodeAppConfigRequest($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTranscoderOverlayEncodeAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteTranscoderOverlayEncodeAppConfigRequest($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling deleteTranscoderOverlayEncodeAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling deleteTranscoderOverlayEncodeAppConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling deleteTranscoderOverlayEncodeAppConfig'
            );
        }
        // verify the required parameter 'overlay_name' is set
        if ($overlay_name === null || (is_array($overlay_name) && count($overlay_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $overlay_name when calling deleteTranscoderOverlayEncodeAppConfig'
            );
        }
        // verify the required parameter 'encode_name' is set
        if ($encode_name === null || (is_array($encode_name) && count($encode_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $encode_name when calling deleteTranscoderOverlayEncodeAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling deleteTranscoderOverlayEncodeAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/transcoder/templates/{templateName}/encodes/{encodeName}/overlays/{overlayName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($overlay_name !== null) {
            $resourcePath = str_replace(
                '{' . 'overlayName' . '}',
                ObjectSerializer::toPathValue($overlay_name),
                $resourcePath
            );
        }
        // path params
        if ($encode_name !== null) {
            $resourcePath = str_replace(
                '{' . 'encodeName' . '}',
                ObjectSerializer::toPathValue($encode_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTranscoderStreamNameGroupAppConfig
     *
     * Deletes the specified Trancoder StreamNameGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $group_name group_name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteTranscoderStreamNameGroupAppConfig($server_name, $vhost_name, $template_name, $group_name, $app_name)
    {
        $this->deleteTranscoderStreamNameGroupAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $group_name, $app_name);
    }

    /**
     * Operation deleteTranscoderStreamNameGroupAppConfigWithHttpInfo
     *
     * Deletes the specified Trancoder StreamNameGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $group_name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTranscoderStreamNameGroupAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $group_name, $app_name)
    {
        $returnType = '';
        $request = $this->deleteTranscoderStreamNameGroupAppConfigRequest($server_name, $vhost_name, $template_name, $group_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteTranscoderStreamNameGroupAppConfigAsync
     *
     * Deletes the specified Trancoder StreamNameGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $group_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTranscoderStreamNameGroupAppConfigAsync($server_name, $vhost_name, $template_name, $group_name, $app_name)
    {
        return $this->deleteTranscoderStreamNameGroupAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $group_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTranscoderStreamNameGroupAppConfigAsyncWithHttpInfo
     *
     * Deletes the specified Trancoder StreamNameGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $group_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTranscoderStreamNameGroupAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $group_name, $app_name)
    {
        $returnType = '';
        $request = $this->deleteTranscoderStreamNameGroupAppConfigRequest($server_name, $vhost_name, $template_name, $group_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTranscoderStreamNameGroupAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $group_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteTranscoderStreamNameGroupAppConfigRequest($server_name, $vhost_name, $template_name, $group_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling deleteTranscoderStreamNameGroupAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling deleteTranscoderStreamNameGroupAppConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling deleteTranscoderStreamNameGroupAppConfig'
            );
        }
        // verify the required parameter 'group_name' is set
        if ($group_name === null || (is_array($group_name) && count($group_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_name when calling deleteTranscoderStreamNameGroupAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling deleteTranscoderStreamNameGroupAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/transcoder/templates/{templateName}/streamnamegroups/{groupName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($group_name !== null) {
            $resourcePath = str_replace(
                '{' . 'groupName' . '}',
                ObjectSerializer::toPathValue($group_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTranscoderTemplateAppConfig
     *
     * Deletes the specified Trancoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteTranscoderTemplateAppConfig($server_name, $vhost_name, $template_name, $app_name)
    {
        $this->deleteTranscoderTemplateAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $app_name);
    }

    /**
     * Operation deleteTranscoderTemplateAppConfigWithHttpInfo
     *
     * Deletes the specified Trancoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTranscoderTemplateAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $app_name)
    {
        $returnType = '';
        $request = $this->deleteTranscoderTemplateAppConfigRequest($server_name, $vhost_name, $template_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteTranscoderTemplateAppConfigAsync
     *
     * Deletes the specified Trancoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTranscoderTemplateAppConfigAsync($server_name, $vhost_name, $template_name, $app_name)
    {
        return $this->deleteTranscoderTemplateAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTranscoderTemplateAppConfigAsyncWithHttpInfo
     *
     * Deletes the specified Trancoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTranscoderTemplateAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $app_name)
    {
        $returnType = '';
        $request = $this->deleteTranscoderTemplateAppConfigRequest($server_name, $vhost_name, $template_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTranscoderTemplateAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteTranscoderTemplateAppConfigRequest($server_name, $vhost_name, $template_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling deleteTranscoderTemplateAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling deleteTranscoderTemplateAppConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling deleteTranscoderTemplateAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling deleteTranscoderTemplateAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/transcoder/templates/{templateName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApplicationConfig
     *
     * Retrieves the specified Application configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ApplicationConfig
     */
    public function getApplicationConfig($server_name, $vhost_name, $app_name)
    {
        list($response) = $this->getApplicationConfigWithHttpInfo($server_name, $vhost_name, $app_name);
        return $response;
    }

    /**
     * Operation getApplicationConfigWithHttpInfo
     *
     * Retrieves the specified Application configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ApplicationConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApplicationConfigWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\ApplicationConfig';
        $request = $this->getApplicationConfigRequest($server_name, $vhost_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApplicationConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApplicationConfigAsync
     *
     * Retrieves the specified Application configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApplicationConfigAsync($server_name, $vhost_name, $app_name)
    {
        return $this->getApplicationConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApplicationConfigAsyncWithHttpInfo
     *
     * Retrieves the specified Application configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApplicationConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\ApplicationConfig';
        $request = $this->getApplicationConfigRequest($server_name, $vhost_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApplicationConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getApplicationConfigRequest($server_name, $vhost_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getApplicationConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getApplicationConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getApplicationConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApplicationConfigAdv
     *
     * Retrieves the specified advanced Application configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ApplicationConfigAdv
     */
    public function getApplicationConfigAdv($server_name, $vhost_name, $app_name)
    {
        list($response) = $this->getApplicationConfigAdvWithHttpInfo($server_name, $vhost_name, $app_name);
        return $response;
    }

    /**
     * Operation getApplicationConfigAdvWithHttpInfo
     *
     * Retrieves the specified advanced Application configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ApplicationConfigAdv, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApplicationConfigAdvWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\ApplicationConfigAdv';
        $request = $this->getApplicationConfigAdvRequest($server_name, $vhost_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApplicationConfigAdv',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApplicationConfigAdvAsync
     *
     * Retrieves the specified advanced Application configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApplicationConfigAdvAsync($server_name, $vhost_name, $app_name)
    {
        return $this->getApplicationConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApplicationConfigAdvAsyncWithHttpInfo
     *
     * Retrieves the specified advanced Application configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApplicationConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\ApplicationConfigAdv';
        $request = $this->getApplicationConfigAdvRequest($server_name, $vhost_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApplicationConfigAdv'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getApplicationConfigAdvRequest($server_name, $vhost_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getApplicationConfigAdv'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getApplicationConfigAdv'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getApplicationConfigAdv'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/adv';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApplicationsConfig
     *
     * Retrieves the list of Applications for the specifed vhost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ApplicationsConfig
     */
    public function getApplicationsConfig($server_name, $vhost_name)
    {
        list($response) = $this->getApplicationsConfigWithHttpInfo($server_name, $vhost_name);
        return $response;
    }

    /**
     * Operation getApplicationsConfigWithHttpInfo
     *
     * Retrieves the list of Applications for the specifed vhost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ApplicationsConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApplicationsConfigWithHttpInfo($server_name, $vhost_name)
    {
        $returnType = '\Swagger\Client\Model\ApplicationsConfig';
        $request = $this->getApplicationsConfigRequest($server_name, $vhost_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApplicationsConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getApplicationsConfigAsync
     *
     * Retrieves the list of Applications for the specifed vhost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApplicationsConfigAsync($server_name, $vhost_name)
    {
        return $this->getApplicationsConfigAsyncWithHttpInfo($server_name, $vhost_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApplicationsConfigAsyncWithHttpInfo
     *
     * Retrieves the list of Applications for the specifed vhost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getApplicationsConfigAsyncWithHttpInfo($server_name, $vhost_name)
    {
        $returnType = '\Swagger\Client\Model\ApplicationsConfig';
        $request = $this->getApplicationsConfigRequest($server_name, $vhost_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApplicationsConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getApplicationsConfigRequest($server_name, $vhost_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getApplicationsConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getApplicationsConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuyDRMStreamMapsConfig
     *
     * Retrieves the BuyDRM stream mapfile for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\BuyDRMStreamMapsConfig
     */
    public function getBuyDRMStreamMapsConfig($server_name, $vhost_name, $app_name)
    {
        list($response) = $this->getBuyDRMStreamMapsConfigWithHttpInfo($server_name, $vhost_name, $app_name);
        return $response;
    }

    /**
     * Operation getBuyDRMStreamMapsConfigWithHttpInfo
     *
     * Retrieves the BuyDRM stream mapfile for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\BuyDRMStreamMapsConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuyDRMStreamMapsConfigWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\BuyDRMStreamMapsConfig';
        $request = $this->getBuyDRMStreamMapsConfigRequest($server_name, $vhost_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\BuyDRMStreamMapsConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBuyDRMStreamMapsConfigAsync
     *
     * Retrieves the BuyDRM stream mapfile for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuyDRMStreamMapsConfigAsync($server_name, $vhost_name, $app_name)
    {
        return $this->getBuyDRMStreamMapsConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuyDRMStreamMapsConfigAsyncWithHttpInfo
     *
     * Retrieves the BuyDRM stream mapfile for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuyDRMStreamMapsConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\BuyDRMStreamMapsConfig';
        $request = $this->getBuyDRMStreamMapsConfigRequest($server_name, $vhost_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuyDRMStreamMapsConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuyDRMStreamMapsConfigRequest($server_name, $vhost_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getBuyDRMStreamMapsConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getBuyDRMStreamMapsConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getBuyDRMStreamMapsConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/drm/buydrmmapfile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCurrentApplicationStatistics
     *
     * Retrieves the current Application statistics
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\CurrentApplicationStatistics
     */
    public function getCurrentApplicationStatistics($server_name, $vhost_name, $app_name)
    {
        list($response) = $this->getCurrentApplicationStatisticsWithHttpInfo($server_name, $vhost_name, $app_name);
        return $response;
    }

    /**
     * Operation getCurrentApplicationStatisticsWithHttpInfo
     *
     * Retrieves the current Application statistics
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\CurrentApplicationStatistics, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCurrentApplicationStatisticsWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\CurrentApplicationStatistics';
        $request = $this->getCurrentApplicationStatisticsRequest($server_name, $vhost_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\CurrentApplicationStatistics',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCurrentApplicationStatisticsAsync
     *
     * Retrieves the current Application statistics
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrentApplicationStatisticsAsync($server_name, $vhost_name, $app_name)
    {
        return $this->getCurrentApplicationStatisticsAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCurrentApplicationStatisticsAsyncWithHttpInfo
     *
     * Retrieves the current Application statistics
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrentApplicationStatisticsAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\CurrentApplicationStatistics';
        $request = $this->getCurrentApplicationStatisticsRequest($server_name, $vhost_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCurrentApplicationStatistics'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCurrentApplicationStatisticsRequest($server_name, $vhost_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getCurrentApplicationStatistics'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getCurrentApplicationStatistics'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getCurrentApplicationStatistics'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/monitoring/current';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCurrentIncomingStreamStatistics
     *
     * Retrieves the Current Incoming Stream statistics for the specifed Incoming Stream
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  string $instance_name instance_name (required)
     * @param  string $stream_name stream_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\CurrentIncomingStreamStatistics
     */
    public function getCurrentIncomingStreamStatistics($server_name, $vhost_name, $app_name, $instance_name, $stream_name)
    {
        list($response) = $this->getCurrentIncomingStreamStatisticsWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name, $stream_name);
        return $response;
    }

    /**
     * Operation getCurrentIncomingStreamStatisticsWithHttpInfo
     *
     * Retrieves the Current Incoming Stream statistics for the specifed Incoming Stream
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  string $stream_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\CurrentIncomingStreamStatistics, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCurrentIncomingStreamStatisticsWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name, $stream_name)
    {
        $returnType = '\Swagger\Client\Model\CurrentIncomingStreamStatistics';
        $request = $this->getCurrentIncomingStreamStatisticsRequest($server_name, $vhost_name, $app_name, $instance_name, $stream_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\CurrentIncomingStreamStatistics',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCurrentIncomingStreamStatisticsAsync
     *
     * Retrieves the Current Incoming Stream statistics for the specifed Incoming Stream
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  string $stream_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrentIncomingStreamStatisticsAsync($server_name, $vhost_name, $app_name, $instance_name, $stream_name)
    {
        return $this->getCurrentIncomingStreamStatisticsAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name, $stream_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCurrentIncomingStreamStatisticsAsyncWithHttpInfo
     *
     * Retrieves the Current Incoming Stream statistics for the specifed Incoming Stream
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  string $stream_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrentIncomingStreamStatisticsAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name, $stream_name)
    {
        $returnType = '\Swagger\Client\Model\CurrentIncomingStreamStatistics';
        $request = $this->getCurrentIncomingStreamStatisticsRequest($server_name, $vhost_name, $app_name, $instance_name, $stream_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCurrentIncomingStreamStatistics'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  string $stream_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCurrentIncomingStreamStatisticsRequest($server_name, $vhost_name, $app_name, $instance_name, $stream_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getCurrentIncomingStreamStatistics'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getCurrentIncomingStreamStatistics'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getCurrentIncomingStreamStatistics'
            );
        }
        // verify the required parameter 'instance_name' is set
        if ($instance_name === null || (is_array($instance_name) && count($instance_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_name when calling getCurrentIncomingStreamStatistics'
            );
        }
        // verify the required parameter 'stream_name' is set
        if ($stream_name === null || (is_array($stream_name) && count($stream_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stream_name when calling getCurrentIncomingStreamStatistics'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/instances/{instanceName}/incomingstreams/{streamName}/monitoring/current';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($instance_name !== null) {
            $resourcePath = str_replace(
                '{' . 'instanceName' . '}',
                ObjectSerializer::toPathValue($instance_name),
                $resourcePath
            );
        }
        // path params
        if ($stream_name !== null) {
            $resourcePath = str_replace(
                '{' . 'streamName' . '}',
                ObjectSerializer::toPathValue($stream_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDRMConfig
     *
     * Retrieves the DRM configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\DRMConfig
     */
    public function getDRMConfig($server_name, $vhost_name, $app_name)
    {
        list($response) = $this->getDRMConfigWithHttpInfo($server_name, $vhost_name, $app_name);
        return $response;
    }

    /**
     * Operation getDRMConfigWithHttpInfo
     *
     * Retrieves the DRM configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\DRMConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDRMConfigWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\DRMConfig';
        $request = $this->getDRMConfigRequest($server_name, $vhost_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\DRMConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDRMConfigAsync
     *
     * Retrieves the DRM configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDRMConfigAsync($server_name, $vhost_name, $app_name)
    {
        return $this->getDRMConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDRMConfigAsyncWithHttpInfo
     *
     * Retrieves the DRM configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDRMConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\DRMConfig';
        $request = $this->getDRMConfigRequest($server_name, $vhost_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDRMConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDRMConfigRequest($server_name, $vhost_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getDRMConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getDRMConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getDRMConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/drm';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDRMConfigAdv
     *
     * Retrieves the advanced DRM configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\DRMConfigAdv
     */
    public function getDRMConfigAdv($server_name, $vhost_name, $app_name)
    {
        list($response) = $this->getDRMConfigAdvWithHttpInfo($server_name, $vhost_name, $app_name);
        return $response;
    }

    /**
     * Operation getDRMConfigAdvWithHttpInfo
     *
     * Retrieves the advanced DRM configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\DRMConfigAdv, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDRMConfigAdvWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\DRMConfigAdv';
        $request = $this->getDRMConfigAdvRequest($server_name, $vhost_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\DRMConfigAdv',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDRMConfigAdvAsync
     *
     * Retrieves the advanced DRM configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDRMConfigAdvAsync($server_name, $vhost_name, $app_name)
    {
        return $this->getDRMConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDRMConfigAdvAsyncWithHttpInfo
     *
     * Retrieves the advanced DRM configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDRMConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\DRMConfigAdv';
        $request = $this->getDRMConfigAdvRequest($server_name, $vhost_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDRMConfigAdv'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDRMConfigAdvRequest($server_name, $vhost_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getDRMConfigAdv'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getDRMConfigAdv'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getDRMConfigAdv'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/drm/adv';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDVRConfig
     *
     * Retrieves the DVR configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\DVRConfig
     */
    public function getDVRConfig($server_name, $vhost_name, $app_name)
    {
        list($response) = $this->getDVRConfigWithHttpInfo($server_name, $vhost_name, $app_name);
        return $response;
    }

    /**
     * Operation getDVRConfigWithHttpInfo
     *
     * Retrieves the DVR configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\DVRConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDVRConfigWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\DVRConfig';
        $request = $this->getDVRConfigRequest($server_name, $vhost_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\DVRConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDVRConfigAsync
     *
     * Retrieves the DVR configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDVRConfigAsync($server_name, $vhost_name, $app_name)
    {
        return $this->getDVRConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDVRConfigAsyncWithHttpInfo
     *
     * Retrieves the DVR configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDVRConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\DVRConfig';
        $request = $this->getDVRConfigRequest($server_name, $vhost_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDVRConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDVRConfigRequest($server_name, $vhost_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getDVRConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getDVRConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getDVRConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/dvr';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDVRConfigAdv
     *
     * Retrieves the advanced DVR configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\DVRConfigAdv
     */
    public function getDVRConfigAdv($server_name, $vhost_name, $app_name)
    {
        list($response) = $this->getDVRConfigAdvWithHttpInfo($server_name, $vhost_name, $app_name);
        return $response;
    }

    /**
     * Operation getDVRConfigAdvWithHttpInfo
     *
     * Retrieves the advanced DVR configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\DVRConfigAdv, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDVRConfigAdvWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\DVRConfigAdv';
        $request = $this->getDVRConfigAdvRequest($server_name, $vhost_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\DVRConfigAdv',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDVRConfigAdvAsync
     *
     * Retrieves the advanced DVR configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDVRConfigAdvAsync($server_name, $vhost_name, $app_name)
    {
        return $this->getDVRConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDVRConfigAdvAsyncWithHttpInfo
     *
     * Retrieves the advanced DVR configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDVRConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\DVRConfigAdv';
        $request = $this->getDVRConfigAdvRequest($server_name, $vhost_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDVRConfigAdv'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDVRConfigAdvRequest($server_name, $vhost_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getDVRConfigAdv'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getDVRConfigAdv'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getDVRConfigAdv'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/dvr/adv';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDefaultStreamRecorderConfig
     *
     * Retrieves a Stream Recorder of the requested name, popluated with the default values
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  string $recorder_name recorder_name (required)
     * @param  string $instance_name instance_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\DefaultStreamRecorderConfig
     */
    public function getDefaultStreamRecorderConfig($server_name, $vhost_name, $app_name, $recorder_name, $instance_name)
    {
        list($response) = $this->getDefaultStreamRecorderConfigWithHttpInfo($server_name, $vhost_name, $app_name, $recorder_name, $instance_name);
        return $response;
    }

    /**
     * Operation getDefaultStreamRecorderConfigWithHttpInfo
     *
     * Retrieves a Stream Recorder of the requested name, popluated with the default values
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $recorder_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\DefaultStreamRecorderConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDefaultStreamRecorderConfigWithHttpInfo($server_name, $vhost_name, $app_name, $recorder_name, $instance_name)
    {
        $returnType = '\Swagger\Client\Model\DefaultStreamRecorderConfig';
        $request = $this->getDefaultStreamRecorderConfigRequest($server_name, $vhost_name, $app_name, $recorder_name, $instance_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\DefaultStreamRecorderConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDefaultStreamRecorderConfigAsync
     *
     * Retrieves a Stream Recorder of the requested name, popluated with the default values
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $recorder_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDefaultStreamRecorderConfigAsync($server_name, $vhost_name, $app_name, $recorder_name, $instance_name)
    {
        return $this->getDefaultStreamRecorderConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $recorder_name, $instance_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDefaultStreamRecorderConfigAsyncWithHttpInfo
     *
     * Retrieves a Stream Recorder of the requested name, popluated with the default values
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $recorder_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDefaultStreamRecorderConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $recorder_name, $instance_name)
    {
        $returnType = '\Swagger\Client\Model\DefaultStreamRecorderConfig';
        $request = $this->getDefaultStreamRecorderConfigRequest($server_name, $vhost_name, $app_name, $recorder_name, $instance_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDefaultStreamRecorderConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $recorder_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDefaultStreamRecorderConfigRequest($server_name, $vhost_name, $app_name, $recorder_name, $instance_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getDefaultStreamRecorderConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getDefaultStreamRecorderConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getDefaultStreamRecorderConfig'
            );
        }
        // verify the required parameter 'recorder_name' is set
        if ($recorder_name === null || (is_array($recorder_name) && count($recorder_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recorder_name when calling getDefaultStreamRecorderConfig'
            );
        }
        // verify the required parameter 'instance_name' is set
        if ($instance_name === null || (is_array($instance_name) && count($instance_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_name when calling getDefaultStreamRecorderConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/instances/{instanceName}/streamrecorders/{recorderName}/default';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($recorder_name !== null) {
            $resourcePath = str_replace(
                '{' . 'recorderName' . '}',
                ObjectSerializer::toPathValue($recorder_name),
                $resourcePath
            );
        }
        // path params
        if ($instance_name !== null) {
            $resourcePath = str_replace(
                '{' . 'instanceName' . '}',
                ObjectSerializer::toPathValue($instance_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDvrRESTConverterStore
     *
     * Retrieves the information about a store/converter associated with the application instance
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  string $instance_name instance_name (required)
     * @param  string $dvr_store_name dvr_store_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\DvrRESTConverterStore
     */
    public function getDvrRESTConverterStore($server_name, $vhost_name, $app_name, $instance_name, $dvr_store_name)
    {
        list($response) = $this->getDvrRESTConverterStoreWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name, $dvr_store_name);
        return $response;
    }

    /**
     * Operation getDvrRESTConverterStoreWithHttpInfo
     *
     * Retrieves the information about a store/converter associated with the application instance
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  string $dvr_store_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\DvrRESTConverterStore, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDvrRESTConverterStoreWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name, $dvr_store_name)
    {
        $returnType = '\Swagger\Client\Model\DvrRESTConverterStore';
        $request = $this->getDvrRESTConverterStoreRequest($server_name, $vhost_name, $app_name, $instance_name, $dvr_store_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\DvrRESTConverterStore',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDvrRESTConverterStoreAsync
     *
     * Retrieves the information about a store/converter associated with the application instance
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  string $dvr_store_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDvrRESTConverterStoreAsync($server_name, $vhost_name, $app_name, $instance_name, $dvr_store_name)
    {
        return $this->getDvrRESTConverterStoreAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name, $dvr_store_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDvrRESTConverterStoreAsyncWithHttpInfo
     *
     * Retrieves the information about a store/converter associated with the application instance
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  string $dvr_store_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDvrRESTConverterStoreAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name, $dvr_store_name)
    {
        $returnType = '\Swagger\Client\Model\DvrRESTConverterStore';
        $request = $this->getDvrRESTConverterStoreRequest($server_name, $vhost_name, $app_name, $instance_name, $dvr_store_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDvrRESTConverterStore'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  string $dvr_store_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDvrRESTConverterStoreRequest($server_name, $vhost_name, $app_name, $instance_name, $dvr_store_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getDvrRESTConverterStore'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getDvrRESTConverterStore'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getDvrRESTConverterStore'
            );
        }
        // verify the required parameter 'instance_name' is set
        if ($instance_name === null || (is_array($instance_name) && count($instance_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_name when calling getDvrRESTConverterStore'
            );
        }
        // verify the required parameter 'dvr_store_name' is set
        if ($dvr_store_name === null || (is_array($dvr_store_name) && count($dvr_store_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dvr_store_name when calling getDvrRESTConverterStore'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/instances/{instanceName}/dvrstores/{dvrStoreName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($instance_name !== null) {
            $resourcePath = str_replace(
                '{' . 'instanceName' . '}',
                ObjectSerializer::toPathValue($instance_name),
                $resourcePath
            );
        }
        // path params
        if ($dvr_store_name !== null) {
            $resourcePath = str_replace(
                '{' . 'dvrStoreName' . '}',
                ObjectSerializer::toPathValue($dvr_store_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDvrRESTConverterStores
     *
     * Retrieves the list of DVR stores associated with this application instance
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  string $instance_name instance_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\DvrRESTConverterStores
     */
    public function getDvrRESTConverterStores($server_name, $vhost_name, $app_name, $instance_name)
    {
        list($response) = $this->getDvrRESTConverterStoresWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name);
        return $response;
    }

    /**
     * Operation getDvrRESTConverterStoresWithHttpInfo
     *
     * Retrieves the list of DVR stores associated with this application instance
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\DvrRESTConverterStores, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDvrRESTConverterStoresWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name)
    {
        $returnType = '\Swagger\Client\Model\DvrRESTConverterStores';
        $request = $this->getDvrRESTConverterStoresRequest($server_name, $vhost_name, $app_name, $instance_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\DvrRESTConverterStores',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDvrRESTConverterStoresAsync
     *
     * Retrieves the list of DVR stores associated with this application instance
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDvrRESTConverterStoresAsync($server_name, $vhost_name, $app_name, $instance_name)
    {
        return $this->getDvrRESTConverterStoresAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDvrRESTConverterStoresAsyncWithHttpInfo
     *
     * Retrieves the list of DVR stores associated with this application instance
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDvrRESTConverterStoresAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name)
    {
        $returnType = '\Swagger\Client\Model\DvrRESTConverterStores';
        $request = $this->getDvrRESTConverterStoresRequest($server_name, $vhost_name, $app_name, $instance_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDvrRESTConverterStores'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDvrRESTConverterStoresRequest($server_name, $vhost_name, $app_name, $instance_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getDvrRESTConverterStores'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getDvrRESTConverterStores'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getDvrRESTConverterStores'
            );
        }
        // verify the required parameter 'instance_name' is set
        if ($instance_name === null || (is_array($instance_name) && count($instance_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_name when calling getDvrRESTConverterStores'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/instances/{instanceName}/dvrstores';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($instance_name !== null) {
            $resourcePath = str_replace(
                '{' . 'instanceName' . '}',
                ObjectSerializer::toPathValue($instance_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getHistoricApplicationStatistics
     *
     * Retrieves the historic Application statistics
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\HistoricApplicationStatistics
     */
    public function getHistoricApplicationStatistics($server_name, $vhost_name, $app_name)
    {
        list($response) = $this->getHistoricApplicationStatisticsWithHttpInfo($server_name, $vhost_name, $app_name);
        return $response;
    }

    /**
     * Operation getHistoricApplicationStatisticsWithHttpInfo
     *
     * Retrieves the historic Application statistics
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\HistoricApplicationStatistics, HTTP status code, HTTP response headers (array of strings)
     */
    public function getHistoricApplicationStatisticsWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\HistoricApplicationStatistics';
        $request = $this->getHistoricApplicationStatisticsRequest($server_name, $vhost_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\HistoricApplicationStatistics',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getHistoricApplicationStatisticsAsync
     *
     * Retrieves the historic Application statistics
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoricApplicationStatisticsAsync($server_name, $vhost_name, $app_name)
    {
        return $this->getHistoricApplicationStatisticsAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getHistoricApplicationStatisticsAsyncWithHttpInfo
     *
     * Retrieves the historic Application statistics
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoricApplicationStatisticsAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\HistoricApplicationStatistics';
        $request = $this->getHistoricApplicationStatisticsRequest($server_name, $vhost_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getHistoricApplicationStatistics'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getHistoricApplicationStatisticsRequest($server_name, $vhost_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getHistoricApplicationStatistics'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getHistoricApplicationStatistics'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getHistoricApplicationStatistics'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/monitoring/historic';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getIncomingStreamConfig
     *
     * Retrieves the Incoming Stream information for the specifed Incoming Stream
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  string $instance_name instance_name (required)
     * @param  string $stream_name stream_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\IncomingStreamConfig
     */
    public function getIncomingStreamConfig($server_name, $vhost_name, $app_name, $instance_name, $stream_name)
    {
        list($response) = $this->getIncomingStreamConfigWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name, $stream_name);
        return $response;
    }

    /**
     * Operation getIncomingStreamConfigWithHttpInfo
     *
     * Retrieves the Incoming Stream information for the specifed Incoming Stream
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  string $stream_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\IncomingStreamConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getIncomingStreamConfigWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name, $stream_name)
    {
        $returnType = '\Swagger\Client\Model\IncomingStreamConfig';
        $request = $this->getIncomingStreamConfigRequest($server_name, $vhost_name, $app_name, $instance_name, $stream_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\IncomingStreamConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getIncomingStreamConfigAsync
     *
     * Retrieves the Incoming Stream information for the specifed Incoming Stream
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  string $stream_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIncomingStreamConfigAsync($server_name, $vhost_name, $app_name, $instance_name, $stream_name)
    {
        return $this->getIncomingStreamConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name, $stream_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getIncomingStreamConfigAsyncWithHttpInfo
     *
     * Retrieves the Incoming Stream information for the specifed Incoming Stream
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  string $stream_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIncomingStreamConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name, $stream_name)
    {
        $returnType = '\Swagger\Client\Model\IncomingStreamConfig';
        $request = $this->getIncomingStreamConfigRequest($server_name, $vhost_name, $app_name, $instance_name, $stream_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getIncomingStreamConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  string $stream_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getIncomingStreamConfigRequest($server_name, $vhost_name, $app_name, $instance_name, $stream_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getIncomingStreamConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getIncomingStreamConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getIncomingStreamConfig'
            );
        }
        // verify the required parameter 'instance_name' is set
        if ($instance_name === null || (is_array($instance_name) && count($instance_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_name when calling getIncomingStreamConfig'
            );
        }
        // verify the required parameter 'stream_name' is set
        if ($stream_name === null || (is_array($stream_name) && count($stream_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stream_name when calling getIncomingStreamConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/instances/{instanceName}/incomingstreams/{streamName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($instance_name !== null) {
            $resourcePath = str_replace(
                '{' . 'instanceName' . '}',
                ObjectSerializer::toPathValue($instance_name),
                $resourcePath
            );
        }
        // path params
        if ($stream_name !== null) {
            $resourcePath = str_replace(
                '{' . 'streamName' . '}',
                ObjectSerializer::toPathValue($stream_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInstanceConfig
     *
     * Retrieves the specified Application Instance information
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  string $instance_name instance_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InstanceConfig
     */
    public function getInstanceConfig($server_name, $vhost_name, $app_name, $instance_name)
    {
        list($response) = $this->getInstanceConfigWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name);
        return $response;
    }

    /**
     * Operation getInstanceConfigWithHttpInfo
     *
     * Retrieves the specified Application Instance information
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InstanceConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInstanceConfigWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name)
    {
        $returnType = '\Swagger\Client\Model\InstanceConfig';
        $request = $this->getInstanceConfigRequest($server_name, $vhost_name, $app_name, $instance_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InstanceConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInstanceConfigAsync
     *
     * Retrieves the specified Application Instance information
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInstanceConfigAsync($server_name, $vhost_name, $app_name, $instance_name)
    {
        return $this->getInstanceConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInstanceConfigAsyncWithHttpInfo
     *
     * Retrieves the specified Application Instance information
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInstanceConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name)
    {
        $returnType = '\Swagger\Client\Model\InstanceConfig';
        $request = $this->getInstanceConfigRequest($server_name, $vhost_name, $app_name, $instance_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInstanceConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInstanceConfigRequest($server_name, $vhost_name, $app_name, $instance_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getInstanceConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getInstanceConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getInstanceConfig'
            );
        }
        // verify the required parameter 'instance_name' is set
        if ($instance_name === null || (is_array($instance_name) && count($instance_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_name when calling getInstanceConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/instances/{instanceName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($instance_name !== null) {
            $resourcePath = str_replace(
                '{' . 'instanceName' . '}',
                ObjectSerializer::toPathValue($instance_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInstancesConfig
     *
     * Retrieves the list of Instances for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InstancesConfig
     */
    public function getInstancesConfig($server_name, $vhost_name, $app_name)
    {
        list($response) = $this->getInstancesConfigWithHttpInfo($server_name, $vhost_name, $app_name);
        return $response;
    }

    /**
     * Operation getInstancesConfigWithHttpInfo
     *
     * Retrieves the list of Instances for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InstancesConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInstancesConfigWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InstancesConfig';
        $request = $this->getInstancesConfigRequest($server_name, $vhost_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InstancesConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInstancesConfigAsync
     *
     * Retrieves the list of Instances for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInstancesConfigAsync($server_name, $vhost_name, $app_name)
    {
        return $this->getInstancesConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInstancesConfigAsyncWithHttpInfo
     *
     * Retrieves the list of Instances for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInstancesConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InstancesConfig';
        $request = $this->getInstancesConfigRequest($server_name, $vhost_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInstancesConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInstancesConfigRequest($server_name, $vhost_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getInstancesConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getInstancesConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getInstancesConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/instances';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLiveEncoderConfig
     *
     * Retrieves the LiveEncoder configuration for the specified IncomingStream
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  string $instance_name instance_name (required)
     * @param  string $stream_name stream_name (required)
     * @param  string $publish_user The publish username to use in the encoder configuration (required)
     * @param  string $publish_host The IP address then encoder will publish to (required)
     * @param  string $publish_port The Port number the encoder will publish to (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\LiveEncoderConfig
     */
    public function getLiveEncoderConfig($server_name, $vhost_name, $app_name, $instance_name, $stream_name, $publish_user, $publish_host, $publish_port)
    {
        list($response) = $this->getLiveEncoderConfigWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name, $stream_name, $publish_user, $publish_host, $publish_port);
        return $response;
    }

    /**
     * Operation getLiveEncoderConfigWithHttpInfo
     *
     * Retrieves the LiveEncoder configuration for the specified IncomingStream
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  string $stream_name (required)
     * @param  string $publish_user The publish username to use in the encoder configuration (required)
     * @param  string $publish_host The IP address then encoder will publish to (required)
     * @param  string $publish_port The Port number the encoder will publish to (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\LiveEncoderConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLiveEncoderConfigWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name, $stream_name, $publish_user, $publish_host, $publish_port)
    {
        $returnType = '\Swagger\Client\Model\LiveEncoderConfig';
        $request = $this->getLiveEncoderConfigRequest($server_name, $vhost_name, $app_name, $instance_name, $stream_name, $publish_user, $publish_host, $publish_port);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\LiveEncoderConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLiveEncoderConfigAsync
     *
     * Retrieves the LiveEncoder configuration for the specified IncomingStream
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  string $stream_name (required)
     * @param  string $publish_user The publish username to use in the encoder configuration (required)
     * @param  string $publish_host The IP address then encoder will publish to (required)
     * @param  string $publish_port The Port number the encoder will publish to (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLiveEncoderConfigAsync($server_name, $vhost_name, $app_name, $instance_name, $stream_name, $publish_user, $publish_host, $publish_port)
    {
        return $this->getLiveEncoderConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name, $stream_name, $publish_user, $publish_host, $publish_port)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLiveEncoderConfigAsyncWithHttpInfo
     *
     * Retrieves the LiveEncoder configuration for the specified IncomingStream
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  string $stream_name (required)
     * @param  string $publish_user The publish username to use in the encoder configuration (required)
     * @param  string $publish_host The IP address then encoder will publish to (required)
     * @param  string $publish_port The Port number the encoder will publish to (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLiveEncoderConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name, $stream_name, $publish_user, $publish_host, $publish_port)
    {
        $returnType = '\Swagger\Client\Model\LiveEncoderConfig';
        $request = $this->getLiveEncoderConfigRequest($server_name, $vhost_name, $app_name, $instance_name, $stream_name, $publish_user, $publish_host, $publish_port);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLiveEncoderConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  string $stream_name (required)
     * @param  string $publish_user The publish username to use in the encoder configuration (required)
     * @param  string $publish_host The IP address then encoder will publish to (required)
     * @param  string $publish_port The Port number the encoder will publish to (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLiveEncoderConfigRequest($server_name, $vhost_name, $app_name, $instance_name, $stream_name, $publish_user, $publish_host, $publish_port)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getLiveEncoderConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getLiveEncoderConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getLiveEncoderConfig'
            );
        }
        // verify the required parameter 'instance_name' is set
        if ($instance_name === null || (is_array($instance_name) && count($instance_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_name when calling getLiveEncoderConfig'
            );
        }
        // verify the required parameter 'stream_name' is set
        if ($stream_name === null || (is_array($stream_name) && count($stream_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stream_name when calling getLiveEncoderConfig'
            );
        }
        // verify the required parameter 'publish_user' is set
        if ($publish_user === null || (is_array($publish_user) && count($publish_user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $publish_user when calling getLiveEncoderConfig'
            );
        }
        // verify the required parameter 'publish_host' is set
        if ($publish_host === null || (is_array($publish_host) && count($publish_host) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $publish_host when calling getLiveEncoderConfig'
            );
        }
        // verify the required parameter 'publish_port' is set
        if ($publish_port === null || (is_array($publish_port) && count($publish_port) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $publish_port when calling getLiveEncoderConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/instances/{instanceName}/incomingstreams/{streamName}/encoder/live';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($publish_user !== null) {
            $queryParams['publishUser'] = ObjectSerializer::toQueryValue($publish_user);
        }
        // query params
        if ($publish_host !== null) {
            $queryParams['publishHost'] = ObjectSerializer::toQueryValue($publish_host);
        }
        // query params
        if ($publish_port !== null) {
            $queryParams['publishPort'] = ObjectSerializer::toQueryValue($publish_port);
        }

        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($instance_name !== null) {
            $resourcePath = str_replace(
                '{' . 'instanceName' . '}',
                ObjectSerializer::toPathValue($instance_name),
                $resourcePath
            );
        }
        // path params
        if ($stream_name !== null) {
            $resourcePath = str_replace(
                '{' . 'streamName' . '}',
                ObjectSerializer::toPathValue($stream_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getModulesConfig
     *
     * Retrieves the list of Modules for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ModulesConfig
     */
    public function getModulesConfig($server_name, $vhost_name, $app_name)
    {
        list($response) = $this->getModulesConfigWithHttpInfo($server_name, $vhost_name, $app_name);
        return $response;
    }

    /**
     * Operation getModulesConfigWithHttpInfo
     *
     * Retrieves the list of Modules for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ModulesConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getModulesConfigWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\ModulesConfig';
        $request = $this->getModulesConfigRequest($server_name, $vhost_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ModulesConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getModulesConfigAsync
     *
     * Retrieves the list of Modules for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getModulesConfigAsync($server_name, $vhost_name, $app_name)
    {
        return $this->getModulesConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getModulesConfigAsyncWithHttpInfo
     *
     * Retrieves the list of Modules for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getModulesConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\ModulesConfig';
        $request = $this->getModulesConfigRequest($server_name, $vhost_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getModulesConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getModulesConfigRequest($server_name, $vhost_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getModulesConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getModulesConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getModulesConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/modules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPublisherAppConfig
     *
     * Retrieves the specified Publisher configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PublisherAppConfig
     */
    public function getPublisherAppConfig($server_name, $vhost_name, $publisher_name, $app_name)
    {
        list($response) = $this->getPublisherAppConfigWithHttpInfo($server_name, $vhost_name, $publisher_name, $app_name);
        return $response;
    }

    /**
     * Operation getPublisherAppConfigWithHttpInfo
     *
     * Retrieves the specified Publisher configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PublisherAppConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPublisherAppConfigWithHttpInfo($server_name, $vhost_name, $publisher_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\PublisherAppConfig';
        $request = $this->getPublisherAppConfigRequest($server_name, $vhost_name, $publisher_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PublisherAppConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPublisherAppConfigAsync
     *
     * Retrieves the specified Publisher configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPublisherAppConfigAsync($server_name, $vhost_name, $publisher_name, $app_name)
    {
        return $this->getPublisherAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $publisher_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPublisherAppConfigAsyncWithHttpInfo
     *
     * Retrieves the specified Publisher configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPublisherAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $publisher_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\PublisherAppConfig';
        $request = $this->getPublisherAppConfigRequest($server_name, $vhost_name, $publisher_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPublisherAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPublisherAppConfigRequest($server_name, $vhost_name, $publisher_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getPublisherAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getPublisherAppConfig'
            );
        }
        // verify the required parameter 'publisher_name' is set
        if ($publisher_name === null || (is_array($publisher_name) && count($publisher_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $publisher_name when calling getPublisherAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getPublisherAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/publishers/{publisherName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($publisher_name !== null) {
            $resourcePath = str_replace(
                '{' . 'publisherName' . '}',
                ObjectSerializer::toPathValue($publisher_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPublishersAppConfig
     *
     * Retrieves the list of Publishers for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PublishersAppConfig
     */
    public function getPublishersAppConfig($server_name, $vhost_name, $app_name)
    {
        list($response) = $this->getPublishersAppConfigWithHttpInfo($server_name, $vhost_name, $app_name);
        return $response;
    }

    /**
     * Operation getPublishersAppConfigWithHttpInfo
     *
     * Retrieves the list of Publishers for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PublishersAppConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPublishersAppConfigWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\PublishersAppConfig';
        $request = $this->getPublishersAppConfigRequest($server_name, $vhost_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PublishersAppConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPublishersAppConfigAsync
     *
     * Retrieves the list of Publishers for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPublishersAppConfigAsync($server_name, $vhost_name, $app_name)
    {
        return $this->getPublishersAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPublishersAppConfigAsyncWithHttpInfo
     *
     * Retrieves the list of Publishers for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPublishersAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\PublishersAppConfig';
        $request = $this->getPublishersAppConfigRequest($server_name, $vhost_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPublishersAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPublishersAppConfigRequest($server_name, $vhost_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getPublishersAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getPublishersAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getPublishersAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/publishers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPushPublishStreamAppConfig
     *
     * Retrieves the specified PushPublish map entry's configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  string $entry_name The entry name needed for this REST call (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PushPublishStreamAppConfig
     */
    public function getPushPublishStreamAppConfig($server_name, $vhost_name, $app_name, $entry_name)
    {
        list($response) = $this->getPushPublishStreamAppConfigWithHttpInfo($server_name, $vhost_name, $app_name, $entry_name);
        return $response;
    }

    /**
     * Operation getPushPublishStreamAppConfigWithHttpInfo
     *
     * Retrieves the specified PushPublish map entry's configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $entry_name The entry name needed for this REST call (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PushPublishStreamAppConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPushPublishStreamAppConfigWithHttpInfo($server_name, $vhost_name, $app_name, $entry_name)
    {
        $returnType = '\Swagger\Client\Model\PushPublishStreamAppConfig';
        $request = $this->getPushPublishStreamAppConfigRequest($server_name, $vhost_name, $app_name, $entry_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PushPublishStreamAppConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPushPublishStreamAppConfigAsync
     *
     * Retrieves the specified PushPublish map entry's configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $entry_name The entry name needed for this REST call (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPushPublishStreamAppConfigAsync($server_name, $vhost_name, $app_name, $entry_name)
    {
        return $this->getPushPublishStreamAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $entry_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPushPublishStreamAppConfigAsyncWithHttpInfo
     *
     * Retrieves the specified PushPublish map entry's configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $entry_name The entry name needed for this REST call (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPushPublishStreamAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $entry_name)
    {
        $returnType = '\Swagger\Client\Model\PushPublishStreamAppConfig';
        $request = $this->getPushPublishStreamAppConfigRequest($server_name, $vhost_name, $app_name, $entry_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPushPublishStreamAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $entry_name The entry name needed for this REST call (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPushPublishStreamAppConfigRequest($server_name, $vhost_name, $app_name, $entry_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getPushPublishStreamAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getPushPublishStreamAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getPushPublishStreamAppConfig'
            );
        }
        // verify the required parameter 'entry_name' is set
        if ($entry_name === null || (is_array($entry_name) && count($entry_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entry_name when calling getPushPublishStreamAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/pushpublish/mapentries/{entryName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($entry_name !== null) {
            $resourcePath = str_replace(
                '{' . 'entryName' . '}',
                ObjectSerializer::toPathValue($entry_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPushPublishStreamsAppConfig
     *
     * Retrieves the list of PushPublish map entries for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\PushPublishStreamsAppConfig
     */
    public function getPushPublishStreamsAppConfig($server_name, $vhost_name, $app_name)
    {
        list($response) = $this->getPushPublishStreamsAppConfigWithHttpInfo($server_name, $vhost_name, $app_name);
        return $response;
    }

    /**
     * Operation getPushPublishStreamsAppConfigWithHttpInfo
     *
     * Retrieves the list of PushPublish map entries for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\PushPublishStreamsAppConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPushPublishStreamsAppConfigWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\PushPublishStreamsAppConfig';
        $request = $this->getPushPublishStreamsAppConfigRequest($server_name, $vhost_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\PushPublishStreamsAppConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPushPublishStreamsAppConfigAsync
     *
     * Retrieves the list of PushPublish map entries for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPushPublishStreamsAppConfigAsync($server_name, $vhost_name, $app_name)
    {
        return $this->getPushPublishStreamsAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPushPublishStreamsAppConfigAsyncWithHttpInfo
     *
     * Retrieves the list of PushPublish map entries for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPushPublishStreamsAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\PushPublishStreamsAppConfig';
        $request = $this->getPushPublishStreamsAppConfigRequest($server_name, $vhost_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPushPublishStreamsAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPushPublishStreamsAppConfigRequest($server_name, $vhost_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getPushPublishStreamsAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getPushPublishStreamsAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getPushPublishStreamsAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/pushpublish/mapentries';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSDPFilesAppConfig
     *
     * Retrieves the list of SDP Files for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\SDPFilesAppConfig
     */
    public function getSDPFilesAppConfig($server_name, $vhost_name, $app_name)
    {
        list($response) = $this->getSDPFilesAppConfigWithHttpInfo($server_name, $vhost_name, $app_name);
        return $response;
    }

    /**
     * Operation getSDPFilesAppConfigWithHttpInfo
     *
     * Retrieves the list of SDP Files for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\SDPFilesAppConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSDPFilesAppConfigWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\SDPFilesAppConfig';
        $request = $this->getSDPFilesAppConfigRequest($server_name, $vhost_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\SDPFilesAppConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSDPFilesAppConfigAsync
     *
     * Retrieves the list of SDP Files for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSDPFilesAppConfigAsync($server_name, $vhost_name, $app_name)
    {
        return $this->getSDPFilesAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSDPFilesAppConfigAsyncWithHttpInfo
     *
     * Retrieves the list of SDP Files for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSDPFilesAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\SDPFilesAppConfig';
        $request = $this->getSDPFilesAppConfigRequest($server_name, $vhost_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSDPFilesAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSDPFilesAppConfigRequest($server_name, $vhost_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getSDPFilesAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getSDPFilesAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getSDPFilesAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/sdpfiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSMILFileAppConfig
     *
     * Retrieves the specified SMIL File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\SMILFileAppConfig
     */
    public function getSMILFileAppConfig($server_name, $vhost_name, $smilfile_name, $app_name)
    {
        list($response) = $this->getSMILFileAppConfigWithHttpInfo($server_name, $vhost_name, $smilfile_name, $app_name);
        return $response;
    }

    /**
     * Operation getSMILFileAppConfigWithHttpInfo
     *
     * Retrieves the specified SMIL File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\SMILFileAppConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSMILFileAppConfigWithHttpInfo($server_name, $vhost_name, $smilfile_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\SMILFileAppConfig';
        $request = $this->getSMILFileAppConfigRequest($server_name, $vhost_name, $smilfile_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\SMILFileAppConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSMILFileAppConfigAsync
     *
     * Retrieves the specified SMIL File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSMILFileAppConfigAsync($server_name, $vhost_name, $smilfile_name, $app_name)
    {
        return $this->getSMILFileAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $smilfile_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSMILFileAppConfigAsyncWithHttpInfo
     *
     * Retrieves the specified SMIL File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSMILFileAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $smilfile_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\SMILFileAppConfig';
        $request = $this->getSMILFileAppConfigRequest($server_name, $vhost_name, $smilfile_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSMILFileAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSMILFileAppConfigRequest($server_name, $vhost_name, $smilfile_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getSMILFileAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getSMILFileAppConfig'
            );
        }
        // verify the required parameter 'smilfile_name' is set
        if ($smilfile_name === null || (is_array($smilfile_name) && count($smilfile_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $smilfile_name when calling getSMILFileAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getSMILFileAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/smilfiles/{smilfileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($smilfile_name !== null) {
            $resourcePath = str_replace(
                '{' . 'smilfileName' . '}',
                ObjectSerializer::toPathValue($smilfile_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSMILFilesAppConfig
     *
     * Retrieves the list of SMIL Files for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\SMILFilesAppConfig
     */
    public function getSMILFilesAppConfig($server_name, $vhost_name, $app_name)
    {
        list($response) = $this->getSMILFilesAppConfigWithHttpInfo($server_name, $vhost_name, $app_name);
        return $response;
    }

    /**
     * Operation getSMILFilesAppConfigWithHttpInfo
     *
     * Retrieves the list of SMIL Files for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\SMILFilesAppConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSMILFilesAppConfigWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\SMILFilesAppConfig';
        $request = $this->getSMILFilesAppConfigRequest($server_name, $vhost_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\SMILFilesAppConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSMILFilesAppConfigAsync
     *
     * Retrieves the list of SMIL Files for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSMILFilesAppConfigAsync($server_name, $vhost_name, $app_name)
    {
        return $this->getSMILFilesAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSMILFilesAppConfigAsyncWithHttpInfo
     *
     * Retrieves the list of SMIL Files for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSMILFilesAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\SMILFilesAppConfig';
        $request = $this->getSMILFilesAppConfigRequest($server_name, $vhost_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSMILFilesAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSMILFilesAppConfigRequest($server_name, $vhost_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getSMILFilesAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getSMILFilesAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getSMILFilesAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/smilfiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSecurityConfig
     *
     * Retrieves the Security configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\SecurityConfig
     */
    public function getSecurityConfig($server_name, $vhost_name, $app_name)
    {
        list($response) = $this->getSecurityConfigWithHttpInfo($server_name, $vhost_name, $app_name);
        return $response;
    }

    /**
     * Operation getSecurityConfigWithHttpInfo
     *
     * Retrieves the Security configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\SecurityConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSecurityConfigWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\SecurityConfig';
        $request = $this->getSecurityConfigRequest($server_name, $vhost_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\SecurityConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSecurityConfigAsync
     *
     * Retrieves the Security configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSecurityConfigAsync($server_name, $vhost_name, $app_name)
    {
        return $this->getSecurityConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSecurityConfigAsyncWithHttpInfo
     *
     * Retrieves the Security configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSecurityConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\SecurityConfig';
        $request = $this->getSecurityConfigRequest($server_name, $vhost_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSecurityConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSecurityConfigRequest($server_name, $vhost_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getSecurityConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getSecurityConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getSecurityConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/security';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getShortUrlEncoderConfig
     *
     * Retrieves the Short URL for the LiveEncoder configuration for the specified IncomingStream
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  string $instance_name instance_name (required)
     * @param  string $stream_name stream_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ShortUrlEncoderConfig
     */
    public function getShortUrlEncoderConfig($server_name, $vhost_name, $app_name, $instance_name, $stream_name)
    {
        list($response) = $this->getShortUrlEncoderConfigWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name, $stream_name);
        return $response;
    }

    /**
     * Operation getShortUrlEncoderConfigWithHttpInfo
     *
     * Retrieves the Short URL for the LiveEncoder configuration for the specified IncomingStream
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  string $stream_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ShortUrlEncoderConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getShortUrlEncoderConfigWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name, $stream_name)
    {
        $returnType = '\Swagger\Client\Model\ShortUrlEncoderConfig';
        $request = $this->getShortUrlEncoderConfigRequest($server_name, $vhost_name, $app_name, $instance_name, $stream_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ShortUrlEncoderConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getShortUrlEncoderConfigAsync
     *
     * Retrieves the Short URL for the LiveEncoder configuration for the specified IncomingStream
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  string $stream_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getShortUrlEncoderConfigAsync($server_name, $vhost_name, $app_name, $instance_name, $stream_name)
    {
        return $this->getShortUrlEncoderConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name, $stream_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getShortUrlEncoderConfigAsyncWithHttpInfo
     *
     * Retrieves the Short URL for the LiveEncoder configuration for the specified IncomingStream
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  string $stream_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getShortUrlEncoderConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name, $stream_name)
    {
        $returnType = '\Swagger\Client\Model\ShortUrlEncoderConfig';
        $request = $this->getShortUrlEncoderConfigRequest($server_name, $vhost_name, $app_name, $instance_name, $stream_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getShortUrlEncoderConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  string $stream_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getShortUrlEncoderConfigRequest($server_name, $vhost_name, $app_name, $instance_name, $stream_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getShortUrlEncoderConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getShortUrlEncoderConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getShortUrlEncoderConfig'
            );
        }
        // verify the required parameter 'instance_name' is set
        if ($instance_name === null || (is_array($instance_name) && count($instance_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_name when calling getShortUrlEncoderConfig'
            );
        }
        // verify the required parameter 'stream_name' is set
        if ($stream_name === null || (is_array($stream_name) && count($stream_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stream_name when calling getShortUrlEncoderConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/instances/{instanceName}/incomingstreams/{streamName}/encoder/shorturl';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($instance_name !== null) {
            $resourcePath = str_replace(
                '{' . 'instanceName' . '}',
                ObjectSerializer::toPathValue($instance_name),
                $resourcePath
            );
        }
        // path params
        if ($stream_name !== null) {
            $resourcePath = str_replace(
                '{' . 'streamName' . '}',
                ObjectSerializer::toPathValue($stream_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSourceControlConfig
     *
     * Gets information about the Source Control and it's supported features
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  string $instance_name instance_name (required)
     * @param  string $stream_name stream_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\SourceControlConfig
     */
    public function getSourceControlConfig($server_name, $vhost_name, $app_name, $instance_name, $stream_name)
    {
        list($response) = $this->getSourceControlConfigWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name, $stream_name);
        return $response;
    }

    /**
     * Operation getSourceControlConfigWithHttpInfo
     *
     * Gets information about the Source Control and it's supported features
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  string $stream_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\SourceControlConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSourceControlConfigWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name, $stream_name)
    {
        $returnType = '\Swagger\Client\Model\SourceControlConfig';
        $request = $this->getSourceControlConfigRequest($server_name, $vhost_name, $app_name, $instance_name, $stream_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\SourceControlConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSourceControlConfigAsync
     *
     * Gets information about the Source Control and it's supported features
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  string $stream_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSourceControlConfigAsync($server_name, $vhost_name, $app_name, $instance_name, $stream_name)
    {
        return $this->getSourceControlConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name, $stream_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSourceControlConfigAsyncWithHttpInfo
     *
     * Gets information about the Source Control and it's supported features
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  string $stream_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSourceControlConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name, $stream_name)
    {
        $returnType = '\Swagger\Client\Model\SourceControlConfig';
        $request = $this->getSourceControlConfigRequest($server_name, $vhost_name, $app_name, $instance_name, $stream_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSourceControlConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  string $stream_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSourceControlConfigRequest($server_name, $vhost_name, $app_name, $instance_name, $stream_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getSourceControlConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getSourceControlConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getSourceControlConfig'
            );
        }
        // verify the required parameter 'instance_name' is set
        if ($instance_name === null || (is_array($instance_name) && count($instance_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_name when calling getSourceControlConfig'
            );
        }
        // verify the required parameter 'stream_name' is set
        if ($stream_name === null || (is_array($stream_name) && count($stream_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stream_name when calling getSourceControlConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/instances/{instanceName}/incomingstreams/{streamName}/sourcecontrol';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($instance_name !== null) {
            $resourcePath = str_replace(
                '{' . 'instanceName' . '}',
                ObjectSerializer::toPathValue($instance_name),
                $resourcePath
            );
        }
        // path params
        if ($stream_name !== null) {
            $resourcePath = str_replace(
                '{' . 'streamName' . '}',
                ObjectSerializer::toPathValue($stream_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStreamConfigurationConfig
     *
     * Retrieves the Stream configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\StreamConfigurationConfig
     */
    public function getStreamConfigurationConfig($server_name, $vhost_name, $app_name)
    {
        list($response) = $this->getStreamConfigurationConfigWithHttpInfo($server_name, $vhost_name, $app_name);
        return $response;
    }

    /**
     * Operation getStreamConfigurationConfigWithHttpInfo
     *
     * Retrieves the Stream configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\StreamConfigurationConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStreamConfigurationConfigWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\StreamConfigurationConfig';
        $request = $this->getStreamConfigurationConfigRequest($server_name, $vhost_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\StreamConfigurationConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStreamConfigurationConfigAsync
     *
     * Retrieves the Stream configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStreamConfigurationConfigAsync($server_name, $vhost_name, $app_name)
    {
        return $this->getStreamConfigurationConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStreamConfigurationConfigAsyncWithHttpInfo
     *
     * Retrieves the Stream configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStreamConfigurationConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\StreamConfigurationConfig';
        $request = $this->getStreamConfigurationConfigRequest($server_name, $vhost_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStreamConfigurationConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStreamConfigurationConfigRequest($server_name, $vhost_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getStreamConfigurationConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getStreamConfigurationConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getStreamConfigurationConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/streamconfiguration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStreamFileAppConfig
     *
     * Retrieves the specified Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\StreamFileAppConfig
     */
    public function getStreamFileAppConfig($server_name, $vhost_name, $streamfile_name, $app_name)
    {
        list($response) = $this->getStreamFileAppConfigWithHttpInfo($server_name, $vhost_name, $streamfile_name, $app_name);
        return $response;
    }

    /**
     * Operation getStreamFileAppConfigWithHttpInfo
     *
     * Retrieves the specified Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\StreamFileAppConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStreamFileAppConfigWithHttpInfo($server_name, $vhost_name, $streamfile_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\StreamFileAppConfig';
        $request = $this->getStreamFileAppConfigRequest($server_name, $vhost_name, $streamfile_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\StreamFileAppConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStreamFileAppConfigAsync
     *
     * Retrieves the specified Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStreamFileAppConfigAsync($server_name, $vhost_name, $streamfile_name, $app_name)
    {
        return $this->getStreamFileAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $streamfile_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStreamFileAppConfigAsyncWithHttpInfo
     *
     * Retrieves the specified Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStreamFileAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $streamfile_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\StreamFileAppConfig';
        $request = $this->getStreamFileAppConfigRequest($server_name, $vhost_name, $streamfile_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStreamFileAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStreamFileAppConfigRequest($server_name, $vhost_name, $streamfile_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getStreamFileAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getStreamFileAppConfig'
            );
        }
        // verify the required parameter 'streamfile_name' is set
        if ($streamfile_name === null || (is_array($streamfile_name) && count($streamfile_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $streamfile_name when calling getStreamFileAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getStreamFileAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/streamfiles/{streamfileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($streamfile_name !== null) {
            $resourcePath = str_replace(
                '{' . 'streamfileName' . '}',
                ObjectSerializer::toPathValue($streamfile_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStreamFileAppConfigAdv
     *
     * Retrieves the Advanced Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $streamfile_name The stream file name without the .stream extension (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\StreamFileAppConfigAdv
     */
    public function getStreamFileAppConfigAdv($server_name, $vhost_name, $streamfile_name, $app_name)
    {
        list($response) = $this->getStreamFileAppConfigAdvWithHttpInfo($server_name, $vhost_name, $streamfile_name, $app_name);
        return $response;
    }

    /**
     * Operation getStreamFileAppConfigAdvWithHttpInfo
     *
     * Retrieves the Advanced Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the .stream extension (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\StreamFileAppConfigAdv, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStreamFileAppConfigAdvWithHttpInfo($server_name, $vhost_name, $streamfile_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\StreamFileAppConfigAdv';
        $request = $this->getStreamFileAppConfigAdvRequest($server_name, $vhost_name, $streamfile_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\StreamFileAppConfigAdv',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStreamFileAppConfigAdvAsync
     *
     * Retrieves the Advanced Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the .stream extension (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStreamFileAppConfigAdvAsync($server_name, $vhost_name, $streamfile_name, $app_name)
    {
        return $this->getStreamFileAppConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $streamfile_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStreamFileAppConfigAdvAsyncWithHttpInfo
     *
     * Retrieves the Advanced Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the .stream extension (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStreamFileAppConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $streamfile_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\StreamFileAppConfigAdv';
        $request = $this->getStreamFileAppConfigAdvRequest($server_name, $vhost_name, $streamfile_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStreamFileAppConfigAdv'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the .stream extension (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStreamFileAppConfigAdvRequest($server_name, $vhost_name, $streamfile_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getStreamFileAppConfigAdv'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getStreamFileAppConfigAdv'
            );
        }
        // verify the required parameter 'streamfile_name' is set
        if ($streamfile_name === null || (is_array($streamfile_name) && count($streamfile_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $streamfile_name when calling getStreamFileAppConfigAdv'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getStreamFileAppConfigAdv'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/streamfiles/{streamfileName}/adv';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($streamfile_name !== null) {
            $resourcePath = str_replace(
                '{' . 'streamfileName' . '}',
                ObjectSerializer::toPathValue($streamfile_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStreamFilesAppConfig
     *
     * Retrieves the list of Stream Files for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\StreamFilesAppConfig
     */
    public function getStreamFilesAppConfig($server_name, $vhost_name, $app_name)
    {
        list($response) = $this->getStreamFilesAppConfigWithHttpInfo($server_name, $vhost_name, $app_name);
        return $response;
    }

    /**
     * Operation getStreamFilesAppConfigWithHttpInfo
     *
     * Retrieves the list of Stream Files for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\StreamFilesAppConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStreamFilesAppConfigWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\StreamFilesAppConfig';
        $request = $this->getStreamFilesAppConfigRequest($server_name, $vhost_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\StreamFilesAppConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStreamFilesAppConfigAsync
     *
     * Retrieves the list of Stream Files for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStreamFilesAppConfigAsync($server_name, $vhost_name, $app_name)
    {
        return $this->getStreamFilesAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStreamFilesAppConfigAsyncWithHttpInfo
     *
     * Retrieves the list of Stream Files for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStreamFilesAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\StreamFilesAppConfig';
        $request = $this->getStreamFilesAppConfigRequest($server_name, $vhost_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStreamFilesAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStreamFilesAppConfigRequest($server_name, $vhost_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getStreamFilesAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getStreamFilesAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getStreamFilesAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/streamfiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStreamGroupConfig
     *
     * Retrieves the specified StreamGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  string $group_name group_name (required)
     * @param  string $instance_name instance_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\StreamGroupConfig
     */
    public function getStreamGroupConfig($server_name, $vhost_name, $app_name, $group_name, $instance_name)
    {
        list($response) = $this->getStreamGroupConfigWithHttpInfo($server_name, $vhost_name, $app_name, $group_name, $instance_name);
        return $response;
    }

    /**
     * Operation getStreamGroupConfigWithHttpInfo
     *
     * Retrieves the specified StreamGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $group_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\StreamGroupConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStreamGroupConfigWithHttpInfo($server_name, $vhost_name, $app_name, $group_name, $instance_name)
    {
        $returnType = '\Swagger\Client\Model\StreamGroupConfig';
        $request = $this->getStreamGroupConfigRequest($server_name, $vhost_name, $app_name, $group_name, $instance_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\StreamGroupConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStreamGroupConfigAsync
     *
     * Retrieves the specified StreamGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $group_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStreamGroupConfigAsync($server_name, $vhost_name, $app_name, $group_name, $instance_name)
    {
        return $this->getStreamGroupConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $group_name, $instance_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStreamGroupConfigAsyncWithHttpInfo
     *
     * Retrieves the specified StreamGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $group_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStreamGroupConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $group_name, $instance_name)
    {
        $returnType = '\Swagger\Client\Model\StreamGroupConfig';
        $request = $this->getStreamGroupConfigRequest($server_name, $vhost_name, $app_name, $group_name, $instance_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStreamGroupConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $group_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStreamGroupConfigRequest($server_name, $vhost_name, $app_name, $group_name, $instance_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getStreamGroupConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getStreamGroupConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getStreamGroupConfig'
            );
        }
        // verify the required parameter 'group_name' is set
        if ($group_name === null || (is_array($group_name) && count($group_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_name when calling getStreamGroupConfig'
            );
        }
        // verify the required parameter 'instance_name' is set
        if ($instance_name === null || (is_array($instance_name) && count($instance_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_name when calling getStreamGroupConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/instances/{instanceName}/streamgroups/{groupName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($group_name !== null) {
            $resourcePath = str_replace(
                '{' . 'groupName' . '}',
                ObjectSerializer::toPathValue($group_name),
                $resourcePath
            );
        }
        // path params
        if ($instance_name !== null) {
            $resourcePath = str_replace(
                '{' . 'instanceName' . '}',
                ObjectSerializer::toPathValue($instance_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStreamGroupsConfig
     *
     * Retrieves the list of Stream Groups for the specified Application Instance
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  string $instance_name instance_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\StreamGroupsConfig
     */
    public function getStreamGroupsConfig($server_name, $vhost_name, $app_name, $instance_name)
    {
        list($response) = $this->getStreamGroupsConfigWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name);
        return $response;
    }

    /**
     * Operation getStreamGroupsConfigWithHttpInfo
     *
     * Retrieves the list of Stream Groups for the specified Application Instance
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\StreamGroupsConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStreamGroupsConfigWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name)
    {
        $returnType = '\Swagger\Client\Model\StreamGroupsConfig';
        $request = $this->getStreamGroupsConfigRequest($server_name, $vhost_name, $app_name, $instance_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\StreamGroupsConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStreamGroupsConfigAsync
     *
     * Retrieves the list of Stream Groups for the specified Application Instance
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStreamGroupsConfigAsync($server_name, $vhost_name, $app_name, $instance_name)
    {
        return $this->getStreamGroupsConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStreamGroupsConfigAsyncWithHttpInfo
     *
     * Retrieves the list of Stream Groups for the specified Application Instance
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStreamGroupsConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name)
    {
        $returnType = '\Swagger\Client\Model\StreamGroupsConfig';
        $request = $this->getStreamGroupsConfigRequest($server_name, $vhost_name, $app_name, $instance_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStreamGroupsConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStreamGroupsConfigRequest($server_name, $vhost_name, $app_name, $instance_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getStreamGroupsConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getStreamGroupsConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getStreamGroupsConfig'
            );
        }
        // verify the required parameter 'instance_name' is set
        if ($instance_name === null || (is_array($instance_name) && count($instance_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_name when calling getStreamGroupsConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/instances/{instanceName}/streamgroups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($instance_name !== null) {
            $resourcePath = str_replace(
                '{' . 'instanceName' . '}',
                ObjectSerializer::toPathValue($instance_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStreamRecorderConfig
     *
     * Retrieves the specifed Stream Recorder
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  string $recorder_name recorder_name (required)
     * @param  string $instance_name instance_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\StreamRecorderConfig
     */
    public function getStreamRecorderConfig($server_name, $vhost_name, $app_name, $recorder_name, $instance_name)
    {
        list($response) = $this->getStreamRecorderConfigWithHttpInfo($server_name, $vhost_name, $app_name, $recorder_name, $instance_name);
        return $response;
    }

    /**
     * Operation getStreamRecorderConfigWithHttpInfo
     *
     * Retrieves the specifed Stream Recorder
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $recorder_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\StreamRecorderConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStreamRecorderConfigWithHttpInfo($server_name, $vhost_name, $app_name, $recorder_name, $instance_name)
    {
        $returnType = '\Swagger\Client\Model\StreamRecorderConfig';
        $request = $this->getStreamRecorderConfigRequest($server_name, $vhost_name, $app_name, $recorder_name, $instance_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\StreamRecorderConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStreamRecorderConfigAsync
     *
     * Retrieves the specifed Stream Recorder
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $recorder_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStreamRecorderConfigAsync($server_name, $vhost_name, $app_name, $recorder_name, $instance_name)
    {
        return $this->getStreamRecorderConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $recorder_name, $instance_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStreamRecorderConfigAsyncWithHttpInfo
     *
     * Retrieves the specifed Stream Recorder
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $recorder_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStreamRecorderConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $recorder_name, $instance_name)
    {
        $returnType = '\Swagger\Client\Model\StreamRecorderConfig';
        $request = $this->getStreamRecorderConfigRequest($server_name, $vhost_name, $app_name, $recorder_name, $instance_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStreamRecorderConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $recorder_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStreamRecorderConfigRequest($server_name, $vhost_name, $app_name, $recorder_name, $instance_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getStreamRecorderConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getStreamRecorderConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getStreamRecorderConfig'
            );
        }
        // verify the required parameter 'recorder_name' is set
        if ($recorder_name === null || (is_array($recorder_name) && count($recorder_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recorder_name when calling getStreamRecorderConfig'
            );
        }
        // verify the required parameter 'instance_name' is set
        if ($instance_name === null || (is_array($instance_name) && count($instance_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_name when calling getStreamRecorderConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/instances/{instanceName}/streamrecorders/{recorderName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($recorder_name !== null) {
            $resourcePath = str_replace(
                '{' . 'recorderName' . '}',
                ObjectSerializer::toPathValue($recorder_name),
                $resourcePath
            );
        }
        // path params
        if ($instance_name !== null) {
            $resourcePath = str_replace(
                '{' . 'instanceName' . '}',
                ObjectSerializer::toPathValue($instance_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStreamRecordersConfig
     *
     * Retrieves the list of Stream Recorders for the specified Application Instance
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  string $instance_name instance_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\StreamRecordersConfig
     */
    public function getStreamRecordersConfig($server_name, $vhost_name, $app_name, $instance_name)
    {
        list($response) = $this->getStreamRecordersConfigWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name);
        return $response;
    }

    /**
     * Operation getStreamRecordersConfigWithHttpInfo
     *
     * Retrieves the list of Stream Recorders for the specified Application Instance
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\StreamRecordersConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStreamRecordersConfigWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name)
    {
        $returnType = '\Swagger\Client\Model\StreamRecordersConfig';
        $request = $this->getStreamRecordersConfigRequest($server_name, $vhost_name, $app_name, $instance_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\StreamRecordersConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStreamRecordersConfigAsync
     *
     * Retrieves the list of Stream Recorders for the specified Application Instance
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStreamRecordersConfigAsync($server_name, $vhost_name, $app_name, $instance_name)
    {
        return $this->getStreamRecordersConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStreamRecordersConfigAsyncWithHttpInfo
     *
     * Retrieves the list of Stream Recorders for the specified Application Instance
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStreamRecordersConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name)
    {
        $returnType = '\Swagger\Client\Model\StreamRecordersConfig';
        $request = $this->getStreamRecordersConfigRequest($server_name, $vhost_name, $app_name, $instance_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStreamRecordersConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStreamRecordersConfigRequest($server_name, $vhost_name, $app_name, $instance_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getStreamRecordersConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getStreamRecordersConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getStreamRecordersConfig'
            );
        }
        // verify the required parameter 'instance_name' is set
        if ($instance_name === null || (is_array($instance_name) && count($instance_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_name when calling getStreamRecordersConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/instances/{instanceName}/streamrecorders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($instance_name !== null) {
            $resourcePath = str_replace(
                '{' . 'instanceName' . '}',
                ObjectSerializer::toPathValue($instance_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTranscoderAppConfig
     *
     * Retrieves the Transcoder configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TranscoderAppConfig
     */
    public function getTranscoderAppConfig($server_name, $vhost_name, $app_name)
    {
        list($response) = $this->getTranscoderAppConfigWithHttpInfo($server_name, $vhost_name, $app_name);
        return $response;
    }

    /**
     * Operation getTranscoderAppConfigWithHttpInfo
     *
     * Retrieves the Transcoder configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TranscoderAppConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTranscoderAppConfigWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderAppConfig';
        $request = $this->getTranscoderAppConfigRequest($server_name, $vhost_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TranscoderAppConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTranscoderAppConfigAsync
     *
     * Retrieves the Transcoder configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderAppConfigAsync($server_name, $vhost_name, $app_name)
    {
        return $this->getTranscoderAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTranscoderAppConfigAsyncWithHttpInfo
     *
     * Retrieves the Transcoder configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderAppConfig';
        $request = $this->getTranscoderAppConfigRequest($server_name, $vhost_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTranscoderAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTranscoderAppConfigRequest($server_name, $vhost_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getTranscoderAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getTranscoderAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getTranscoderAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/transcoder';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTranscoderAppConfigAdv
     *
     * Retrieves the Advanced Transcoder configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TranscoderAppConfigAdv
     */
    public function getTranscoderAppConfigAdv($server_name, $vhost_name, $app_name)
    {
        list($response) = $this->getTranscoderAppConfigAdvWithHttpInfo($server_name, $vhost_name, $app_name);
        return $response;
    }

    /**
     * Operation getTranscoderAppConfigAdvWithHttpInfo
     *
     * Retrieves the Advanced Transcoder configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TranscoderAppConfigAdv, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTranscoderAppConfigAdvWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderAppConfigAdv';
        $request = $this->getTranscoderAppConfigAdvRequest($server_name, $vhost_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TranscoderAppConfigAdv',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTranscoderAppConfigAdvAsync
     *
     * Retrieves the Advanced Transcoder configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderAppConfigAdvAsync($server_name, $vhost_name, $app_name)
    {
        return $this->getTranscoderAppConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTranscoderAppConfigAdvAsyncWithHttpInfo
     *
     * Retrieves the Advanced Transcoder configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderAppConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderAppConfigAdv';
        $request = $this->getTranscoderAppConfigAdvRequest($server_name, $vhost_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTranscoderAppConfigAdv'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTranscoderAppConfigAdvRequest($server_name, $vhost_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getTranscoderAppConfigAdv'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getTranscoderAppConfigAdv'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getTranscoderAppConfigAdv'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/transcoder/adv';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTranscoderEncodeAppConfig
     *
     * Retrieves the specified Trancoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $encode_name encode_name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TranscoderEncodeAppConfig
     */
    public function getTranscoderEncodeAppConfig($server_name, $vhost_name, $template_name, $encode_name, $app_name)
    {
        list($response) = $this->getTranscoderEncodeAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $app_name);
        return $response;
    }

    /**
     * Operation getTranscoderEncodeAppConfigWithHttpInfo
     *
     * Retrieves the specified Trancoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TranscoderEncodeAppConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTranscoderEncodeAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderEncodeAppConfig';
        $request = $this->getTranscoderEncodeAppConfigRequest($server_name, $vhost_name, $template_name, $encode_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TranscoderEncodeAppConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTranscoderEncodeAppConfigAsync
     *
     * Retrieves the specified Trancoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderEncodeAppConfigAsync($server_name, $vhost_name, $template_name, $encode_name, $app_name)
    {
        return $this->getTranscoderEncodeAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTranscoderEncodeAppConfigAsyncWithHttpInfo
     *
     * Retrieves the specified Trancoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderEncodeAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderEncodeAppConfig';
        $request = $this->getTranscoderEncodeAppConfigRequest($server_name, $vhost_name, $template_name, $encode_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTranscoderEncodeAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTranscoderEncodeAppConfigRequest($server_name, $vhost_name, $template_name, $encode_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getTranscoderEncodeAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getTranscoderEncodeAppConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling getTranscoderEncodeAppConfig'
            );
        }
        // verify the required parameter 'encode_name' is set
        if ($encode_name === null || (is_array($encode_name) && count($encode_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $encode_name when calling getTranscoderEncodeAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getTranscoderEncodeAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/transcoder/templates/{templateName}/encodes/{encodeName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($encode_name !== null) {
            $resourcePath = str_replace(
                '{' . 'encodeName' . '}',
                ObjectSerializer::toPathValue($encode_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTranscoderEncodeAppConfigAdv
     *
     * Retrieves the Advanced Transcoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $encode_name encode_name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TranscoderEncodeAppConfigAdv
     */
    public function getTranscoderEncodeAppConfigAdv($server_name, $vhost_name, $template_name, $encode_name, $app_name)
    {
        list($response) = $this->getTranscoderEncodeAppConfigAdvWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $app_name);
        return $response;
    }

    /**
     * Operation getTranscoderEncodeAppConfigAdvWithHttpInfo
     *
     * Retrieves the Advanced Transcoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TranscoderEncodeAppConfigAdv, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTranscoderEncodeAppConfigAdvWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderEncodeAppConfigAdv';
        $request = $this->getTranscoderEncodeAppConfigAdvRequest($server_name, $vhost_name, $template_name, $encode_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TranscoderEncodeAppConfigAdv',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTranscoderEncodeAppConfigAdvAsync
     *
     * Retrieves the Advanced Transcoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderEncodeAppConfigAdvAsync($server_name, $vhost_name, $template_name, $encode_name, $app_name)
    {
        return $this->getTranscoderEncodeAppConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTranscoderEncodeAppConfigAdvAsyncWithHttpInfo
     *
     * Retrieves the Advanced Transcoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderEncodeAppConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderEncodeAppConfigAdv';
        $request = $this->getTranscoderEncodeAppConfigAdvRequest($server_name, $vhost_name, $template_name, $encode_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTranscoderEncodeAppConfigAdv'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTranscoderEncodeAppConfigAdvRequest($server_name, $vhost_name, $template_name, $encode_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getTranscoderEncodeAppConfigAdv'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getTranscoderEncodeAppConfigAdv'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling getTranscoderEncodeAppConfigAdv'
            );
        }
        // verify the required parameter 'encode_name' is set
        if ($encode_name === null || (is_array($encode_name) && count($encode_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $encode_name when calling getTranscoderEncodeAppConfigAdv'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getTranscoderEncodeAppConfigAdv'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/transcoder/templates/{templateName}/encodes/{encodeName}/adv';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($encode_name !== null) {
            $resourcePath = str_replace(
                '{' . 'encodeName' . '}',
                ObjectSerializer::toPathValue($encode_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTranscoderEncodesAppConfig
     *
     * Retrieves the list of Transcoder Encode Configurations for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TranscoderEncodesAppConfig
     */
    public function getTranscoderEncodesAppConfig($server_name, $vhost_name, $template_name, $app_name)
    {
        list($response) = $this->getTranscoderEncodesAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $app_name);
        return $response;
    }

    /**
     * Operation getTranscoderEncodesAppConfigWithHttpInfo
     *
     * Retrieves the list of Transcoder Encode Configurations for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TranscoderEncodesAppConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTranscoderEncodesAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderEncodesAppConfig';
        $request = $this->getTranscoderEncodesAppConfigRequest($server_name, $vhost_name, $template_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TranscoderEncodesAppConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTranscoderEncodesAppConfigAsync
     *
     * Retrieves the list of Transcoder Encode Configurations for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderEncodesAppConfigAsync($server_name, $vhost_name, $template_name, $app_name)
    {
        return $this->getTranscoderEncodesAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTranscoderEncodesAppConfigAsyncWithHttpInfo
     *
     * Retrieves the list of Transcoder Encode Configurations for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderEncodesAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderEncodesAppConfig';
        $request = $this->getTranscoderEncodesAppConfigRequest($server_name, $vhost_name, $template_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTranscoderEncodesAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTranscoderEncodesAppConfigRequest($server_name, $vhost_name, $template_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getTranscoderEncodesAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getTranscoderEncodesAppConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling getTranscoderEncodesAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getTranscoderEncodesAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/transcoder/templates/{templateName}/encodes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTranscoderOverlayDecodeAppConfig
     *
     * Retrieves the specified Trancoder Overlay Decode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $overlay_name overlay_name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TranscoderOverlayDecodeAppConfig
     */
    public function getTranscoderOverlayDecodeAppConfig($server_name, $vhost_name, $template_name, $overlay_name, $app_name)
    {
        list($response) = $this->getTranscoderOverlayDecodeAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $app_name);
        return $response;
    }

    /**
     * Operation getTranscoderOverlayDecodeAppConfigWithHttpInfo
     *
     * Retrieves the specified Trancoder Overlay Decode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TranscoderOverlayDecodeAppConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTranscoderOverlayDecodeAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderOverlayDecodeAppConfig';
        $request = $this->getTranscoderOverlayDecodeAppConfigRequest($server_name, $vhost_name, $template_name, $overlay_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TranscoderOverlayDecodeAppConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTranscoderOverlayDecodeAppConfigAsync
     *
     * Retrieves the specified Trancoder Overlay Decode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderOverlayDecodeAppConfigAsync($server_name, $vhost_name, $template_name, $overlay_name, $app_name)
    {
        return $this->getTranscoderOverlayDecodeAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTranscoderOverlayDecodeAppConfigAsyncWithHttpInfo
     *
     * Retrieves the specified Trancoder Overlay Decode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderOverlayDecodeAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderOverlayDecodeAppConfig';
        $request = $this->getTranscoderOverlayDecodeAppConfigRequest($server_name, $vhost_name, $template_name, $overlay_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTranscoderOverlayDecodeAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTranscoderOverlayDecodeAppConfigRequest($server_name, $vhost_name, $template_name, $overlay_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getTranscoderOverlayDecodeAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getTranscoderOverlayDecodeAppConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling getTranscoderOverlayDecodeAppConfig'
            );
        }
        // verify the required parameter 'overlay_name' is set
        if ($overlay_name === null || (is_array($overlay_name) && count($overlay_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $overlay_name when calling getTranscoderOverlayDecodeAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getTranscoderOverlayDecodeAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/transcoder/templates/{templateName}/decode/overlays/{overlayName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($overlay_name !== null) {
            $resourcePath = str_replace(
                '{' . 'overlayName' . '}',
                ObjectSerializer::toPathValue($overlay_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTranscoderOverlayEncodeAppConfig
     *
     * Retrieves the specified Trancoder Overlay Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $overlay_name overlay_name (required)
     * @param  string $encode_name encode_name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TranscoderOverlayEncodeAppConfig
     */
    public function getTranscoderOverlayEncodeAppConfig($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $app_name)
    {
        list($response) = $this->getTranscoderOverlayEncodeAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $app_name);
        return $response;
    }

    /**
     * Operation getTranscoderOverlayEncodeAppConfigWithHttpInfo
     *
     * Retrieves the specified Trancoder Overlay Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TranscoderOverlayEncodeAppConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTranscoderOverlayEncodeAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderOverlayEncodeAppConfig';
        $request = $this->getTranscoderOverlayEncodeAppConfigRequest($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TranscoderOverlayEncodeAppConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTranscoderOverlayEncodeAppConfigAsync
     *
     * Retrieves the specified Trancoder Overlay Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderOverlayEncodeAppConfigAsync($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $app_name)
    {
        return $this->getTranscoderOverlayEncodeAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTranscoderOverlayEncodeAppConfigAsyncWithHttpInfo
     *
     * Retrieves the specified Trancoder Overlay Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderOverlayEncodeAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderOverlayEncodeAppConfig';
        $request = $this->getTranscoderOverlayEncodeAppConfigRequest($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTranscoderOverlayEncodeAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTranscoderOverlayEncodeAppConfigRequest($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getTranscoderOverlayEncodeAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getTranscoderOverlayEncodeAppConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling getTranscoderOverlayEncodeAppConfig'
            );
        }
        // verify the required parameter 'overlay_name' is set
        if ($overlay_name === null || (is_array($overlay_name) && count($overlay_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $overlay_name when calling getTranscoderOverlayEncodeAppConfig'
            );
        }
        // verify the required parameter 'encode_name' is set
        if ($encode_name === null || (is_array($encode_name) && count($encode_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $encode_name when calling getTranscoderOverlayEncodeAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getTranscoderOverlayEncodeAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/transcoder/templates/{templateName}/encodes/{encodeName}/overlays/{overlayName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($overlay_name !== null) {
            $resourcePath = str_replace(
                '{' . 'overlayName' . '}',
                ObjectSerializer::toPathValue($overlay_name),
                $resourcePath
            );
        }
        // path params
        if ($encode_name !== null) {
            $resourcePath = str_replace(
                '{' . 'encodeName' . '}',
                ObjectSerializer::toPathValue($encode_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTranscoderStreamNameGroupAppConfig
     *
     * Retrieves the specified Trancoder StreamNameGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $group_name group_name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TranscoderStreamNameGroupAppConfig
     */
    public function getTranscoderStreamNameGroupAppConfig($server_name, $vhost_name, $template_name, $group_name, $app_name)
    {
        list($response) = $this->getTranscoderStreamNameGroupAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $group_name, $app_name);
        return $response;
    }

    /**
     * Operation getTranscoderStreamNameGroupAppConfigWithHttpInfo
     *
     * Retrieves the specified Trancoder StreamNameGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $group_name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TranscoderStreamNameGroupAppConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTranscoderStreamNameGroupAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $group_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderStreamNameGroupAppConfig';
        $request = $this->getTranscoderStreamNameGroupAppConfigRequest($server_name, $vhost_name, $template_name, $group_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TranscoderStreamNameGroupAppConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTranscoderStreamNameGroupAppConfigAsync
     *
     * Retrieves the specified Trancoder StreamNameGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $group_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderStreamNameGroupAppConfigAsync($server_name, $vhost_name, $template_name, $group_name, $app_name)
    {
        return $this->getTranscoderStreamNameGroupAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $group_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTranscoderStreamNameGroupAppConfigAsyncWithHttpInfo
     *
     * Retrieves the specified Trancoder StreamNameGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $group_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderStreamNameGroupAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $group_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderStreamNameGroupAppConfig';
        $request = $this->getTranscoderStreamNameGroupAppConfigRequest($server_name, $vhost_name, $template_name, $group_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTranscoderStreamNameGroupAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $group_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTranscoderStreamNameGroupAppConfigRequest($server_name, $vhost_name, $template_name, $group_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getTranscoderStreamNameGroupAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getTranscoderStreamNameGroupAppConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling getTranscoderStreamNameGroupAppConfig'
            );
        }
        // verify the required parameter 'group_name' is set
        if ($group_name === null || (is_array($group_name) && count($group_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_name when calling getTranscoderStreamNameGroupAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getTranscoderStreamNameGroupAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/transcoder/templates/{templateName}/streamnamegroups/{groupName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($group_name !== null) {
            $resourcePath = str_replace(
                '{' . 'groupName' . '}',
                ObjectSerializer::toPathValue($group_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTranscoderStreamNameGroupsAppConfig
     *
     * Retrieves the list of Transcoder Stream Name Groups for the specified Template
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TranscoderStreamNameGroupsAppConfig
     */
    public function getTranscoderStreamNameGroupsAppConfig($server_name, $vhost_name, $template_name, $app_name)
    {
        list($response) = $this->getTranscoderStreamNameGroupsAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $app_name);
        return $response;
    }

    /**
     * Operation getTranscoderStreamNameGroupsAppConfigWithHttpInfo
     *
     * Retrieves the list of Transcoder Stream Name Groups for the specified Template
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TranscoderStreamNameGroupsAppConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTranscoderStreamNameGroupsAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderStreamNameGroupsAppConfig';
        $request = $this->getTranscoderStreamNameGroupsAppConfigRequest($server_name, $vhost_name, $template_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TranscoderStreamNameGroupsAppConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTranscoderStreamNameGroupsAppConfigAsync
     *
     * Retrieves the list of Transcoder Stream Name Groups for the specified Template
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderStreamNameGroupsAppConfigAsync($server_name, $vhost_name, $template_name, $app_name)
    {
        return $this->getTranscoderStreamNameGroupsAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTranscoderStreamNameGroupsAppConfigAsyncWithHttpInfo
     *
     * Retrieves the list of Transcoder Stream Name Groups for the specified Template
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderStreamNameGroupsAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderStreamNameGroupsAppConfig';
        $request = $this->getTranscoderStreamNameGroupsAppConfigRequest($server_name, $vhost_name, $template_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTranscoderStreamNameGroupsAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTranscoderStreamNameGroupsAppConfigRequest($server_name, $vhost_name, $template_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getTranscoderStreamNameGroupsAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getTranscoderStreamNameGroupsAppConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling getTranscoderStreamNameGroupsAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getTranscoderStreamNameGroupsAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/transcoder/templates/{templateName}/streamnamegroups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTranscoderTemplateAppConfig
     *
     * Retrieves the specified Trancoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TranscoderTemplateAppConfig
     */
    public function getTranscoderTemplateAppConfig($server_name, $vhost_name, $template_name, $app_name)
    {
        list($response) = $this->getTranscoderTemplateAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $app_name);
        return $response;
    }

    /**
     * Operation getTranscoderTemplateAppConfigWithHttpInfo
     *
     * Retrieves the specified Trancoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TranscoderTemplateAppConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTranscoderTemplateAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderTemplateAppConfig';
        $request = $this->getTranscoderTemplateAppConfigRequest($server_name, $vhost_name, $template_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TranscoderTemplateAppConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTranscoderTemplateAppConfigAsync
     *
     * Retrieves the specified Trancoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderTemplateAppConfigAsync($server_name, $vhost_name, $template_name, $app_name)
    {
        return $this->getTranscoderTemplateAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTranscoderTemplateAppConfigAsyncWithHttpInfo
     *
     * Retrieves the specified Trancoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderTemplateAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderTemplateAppConfig';
        $request = $this->getTranscoderTemplateAppConfigRequest($server_name, $vhost_name, $template_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTranscoderTemplateAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTranscoderTemplateAppConfigRequest($server_name, $vhost_name, $template_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getTranscoderTemplateAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getTranscoderTemplateAppConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling getTranscoderTemplateAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getTranscoderTemplateAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/transcoder/templates/{templateName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTranscoderTemplateAppConfigAdv
     *
     * Retrieves the Advanced Transcoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TranscoderTemplateAppConfigAdv
     */
    public function getTranscoderTemplateAppConfigAdv($server_name, $vhost_name, $template_name, $app_name)
    {
        list($response) = $this->getTranscoderTemplateAppConfigAdvWithHttpInfo($server_name, $vhost_name, $template_name, $app_name);
        return $response;
    }

    /**
     * Operation getTranscoderTemplateAppConfigAdvWithHttpInfo
     *
     * Retrieves the Advanced Transcoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TranscoderTemplateAppConfigAdv, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTranscoderTemplateAppConfigAdvWithHttpInfo($server_name, $vhost_name, $template_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderTemplateAppConfigAdv';
        $request = $this->getTranscoderTemplateAppConfigAdvRequest($server_name, $vhost_name, $template_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TranscoderTemplateAppConfigAdv',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTranscoderTemplateAppConfigAdvAsync
     *
     * Retrieves the Advanced Transcoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderTemplateAppConfigAdvAsync($server_name, $vhost_name, $template_name, $app_name)
    {
        return $this->getTranscoderTemplateAppConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTranscoderTemplateAppConfigAdvAsyncWithHttpInfo
     *
     * Retrieves the Advanced Transcoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderTemplateAppConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderTemplateAppConfigAdv';
        $request = $this->getTranscoderTemplateAppConfigAdvRequest($server_name, $vhost_name, $template_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTranscoderTemplateAppConfigAdv'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTranscoderTemplateAppConfigAdvRequest($server_name, $vhost_name, $template_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getTranscoderTemplateAppConfigAdv'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getTranscoderTemplateAppConfigAdv'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling getTranscoderTemplateAppConfigAdv'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getTranscoderTemplateAppConfigAdv'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/transcoder/templates/{templateName}/adv';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTranscoderTemplatesAppConfig
     *
     * Retrieves the list of Transcoder Template Configurations for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TranscoderTemplatesAppConfig
     */
    public function getTranscoderTemplatesAppConfig($server_name, $vhost_name, $app_name)
    {
        list($response) = $this->getTranscoderTemplatesAppConfigWithHttpInfo($server_name, $vhost_name, $app_name);
        return $response;
    }

    /**
     * Operation getTranscoderTemplatesAppConfigWithHttpInfo
     *
     * Retrieves the list of Transcoder Template Configurations for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TranscoderTemplatesAppConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTranscoderTemplatesAppConfigWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderTemplatesAppConfig';
        $request = $this->getTranscoderTemplatesAppConfigRequest($server_name, $vhost_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TranscoderTemplatesAppConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTranscoderTemplatesAppConfigAsync
     *
     * Retrieves the list of Transcoder Template Configurations for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderTemplatesAppConfigAsync($server_name, $vhost_name, $app_name)
    {
        return $this->getTranscoderTemplatesAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTranscoderTemplatesAppConfigAsyncWithHttpInfo
     *
     * Retrieves the list of Transcoder Template Configurations for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTranscoderTemplatesAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\TranscoderTemplatesAppConfig';
        $request = $this->getTranscoderTemplatesAppConfigRequest($server_name, $vhost_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTranscoderTemplatesAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTranscoderTemplatesAppConfigRequest($server_name, $vhost_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getTranscoderTemplatesAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getTranscoderTemplatesAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getTranscoderTemplatesAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/transcoder/templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVerimatrixStreamMapsConfig
     *
     * Retrieves the Verimatrix stream mapfile for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\VerimatrixStreamMapsConfig
     */
    public function getVerimatrixStreamMapsConfig($server_name, $vhost_name, $app_name)
    {
        list($response) = $this->getVerimatrixStreamMapsConfigWithHttpInfo($server_name, $vhost_name, $app_name);
        return $response;
    }

    /**
     * Operation getVerimatrixStreamMapsConfigWithHttpInfo
     *
     * Retrieves the Verimatrix stream mapfile for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\VerimatrixStreamMapsConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVerimatrixStreamMapsConfigWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\VerimatrixStreamMapsConfig';
        $request = $this->getVerimatrixStreamMapsConfigRequest($server_name, $vhost_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\VerimatrixStreamMapsConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVerimatrixStreamMapsConfigAsync
     *
     * Retrieves the Verimatrix stream mapfile for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVerimatrixStreamMapsConfigAsync($server_name, $vhost_name, $app_name)
    {
        return $this->getVerimatrixStreamMapsConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVerimatrixStreamMapsConfigAsyncWithHttpInfo
     *
     * Retrieves the Verimatrix stream mapfile for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVerimatrixStreamMapsConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\VerimatrixStreamMapsConfig';
        $request = $this->getVerimatrixStreamMapsConfigRequest($server_name, $vhost_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVerimatrixStreamMapsConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVerimatrixStreamMapsConfigRequest($server_name, $vhost_name, $app_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling getVerimatrixStreamMapsConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling getVerimatrixStreamMapsConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling getVerimatrixStreamMapsConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/drm/verimatrixmapfile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApplicationConfig
     *
     * Adds the specified Application configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\ApplicationConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postApplicationConfig($server_name, $vhost_name, $app_name, $body)
    {
        $this->postApplicationConfigWithHttpInfo($server_name, $vhost_name, $app_name, $body);
    }

    /**
     * Operation postApplicationConfigWithHttpInfo
     *
     * Adds the specified Application configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\ApplicationConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApplicationConfigWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->postApplicationConfigRequest($server_name, $vhost_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postApplicationConfigAsync
     *
     * Adds the specified Application configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\ApplicationConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApplicationConfigAsync($server_name, $vhost_name, $app_name, $body)
    {
        return $this->postApplicationConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApplicationConfigAsyncWithHttpInfo
     *
     * Adds the specified Application configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\ApplicationConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApplicationConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->postApplicationConfigRequest($server_name, $vhost_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApplicationConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\ApplicationConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postApplicationConfigRequest($server_name, $vhost_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling postApplicationConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling postApplicationConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling postApplicationConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postApplicationConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApplicationConfigAdv
     *
     * Adds the specified advanced Application configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\ApplicationConfigAdv $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postApplicationConfigAdv($server_name, $vhost_name, $app_name, $body)
    {
        $this->postApplicationConfigAdvWithHttpInfo($server_name, $vhost_name, $app_name, $body);
    }

    /**
     * Operation postApplicationConfigAdvWithHttpInfo
     *
     * Adds the specified advanced Application configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\ApplicationConfigAdv $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApplicationConfigAdvWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->postApplicationConfigAdvRequest($server_name, $vhost_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postApplicationConfigAdvAsync
     *
     * Adds the specified advanced Application configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\ApplicationConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApplicationConfigAdvAsync($server_name, $vhost_name, $app_name, $body)
    {
        return $this->postApplicationConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApplicationConfigAdvAsyncWithHttpInfo
     *
     * Adds the specified advanced Application configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\ApplicationConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApplicationConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->postApplicationConfigAdvRequest($server_name, $vhost_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApplicationConfigAdv'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\ApplicationConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postApplicationConfigAdvRequest($server_name, $vhost_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling postApplicationConfigAdv'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling postApplicationConfigAdv'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling postApplicationConfigAdv'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postApplicationConfigAdv'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/adv';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postApplicationsConfig
     *
     * Adds an Application to the list of Applications  for the specifed vhost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  \Swagger\Client\Model\ApplicationConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postApplicationsConfig($server_name, $vhost_name, $body)
    {
        $this->postApplicationsConfigWithHttpInfo($server_name, $vhost_name, $body);
    }

    /**
     * Operation postApplicationsConfigWithHttpInfo
     *
     * Adds an Application to the list of Applications  for the specifed vhost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  \Swagger\Client\Model\ApplicationConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postApplicationsConfigWithHttpInfo($server_name, $vhost_name, $body)
    {
        $returnType = '';
        $request = $this->postApplicationsConfigRequest($server_name, $vhost_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postApplicationsConfigAsync
     *
     * Adds an Application to the list of Applications  for the specifed vhost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  \Swagger\Client\Model\ApplicationConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApplicationsConfigAsync($server_name, $vhost_name, $body)
    {
        return $this->postApplicationsConfigAsyncWithHttpInfo($server_name, $vhost_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postApplicationsConfigAsyncWithHttpInfo
     *
     * Adds an Application to the list of Applications  for the specifed vhost
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  \Swagger\Client\Model\ApplicationConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postApplicationsConfigAsyncWithHttpInfo($server_name, $vhost_name, $body)
    {
        $returnType = '';
        $request = $this->postApplicationsConfigRequest($server_name, $vhost_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postApplicationsConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  \Swagger\Client\Model\ApplicationConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postApplicationsConfigRequest($server_name, $vhost_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling postApplicationsConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling postApplicationsConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postApplicationsConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPublisherAppConfig
     *
     * Adds the specified Publisher configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\PublisherAppConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postPublisherAppConfig($server_name, $vhost_name, $publisher_name, $app_name, $body)
    {
        $this->postPublisherAppConfigWithHttpInfo($server_name, $vhost_name, $publisher_name, $app_name, $body);
    }

    /**
     * Operation postPublisherAppConfigWithHttpInfo
     *
     * Adds the specified Publisher configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\PublisherAppConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPublisherAppConfigWithHttpInfo($server_name, $vhost_name, $publisher_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->postPublisherAppConfigRequest($server_name, $vhost_name, $publisher_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postPublisherAppConfigAsync
     *
     * Adds the specified Publisher configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\PublisherAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPublisherAppConfigAsync($server_name, $vhost_name, $publisher_name, $app_name, $body)
    {
        return $this->postPublisherAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $publisher_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPublisherAppConfigAsyncWithHttpInfo
     *
     * Adds the specified Publisher configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\PublisherAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPublisherAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $publisher_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->postPublisherAppConfigRequest($server_name, $vhost_name, $publisher_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPublisherAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\PublisherAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPublisherAppConfigRequest($server_name, $vhost_name, $publisher_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling postPublisherAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling postPublisherAppConfig'
            );
        }
        // verify the required parameter 'publisher_name' is set
        if ($publisher_name === null || (is_array($publisher_name) && count($publisher_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $publisher_name when calling postPublisherAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling postPublisherAppConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postPublisherAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/publishers/{publisherName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($publisher_name !== null) {
            $resourcePath = str_replace(
                '{' . 'publisherName' . '}',
                ObjectSerializer::toPathValue($publisher_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPublishersAppConfig
     *
     * Add a Publisher to list of Publishers for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\PublisherAppConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postPublishersAppConfig($server_name, $vhost_name, $app_name, $body)
    {
        $this->postPublishersAppConfigWithHttpInfo($server_name, $vhost_name, $app_name, $body);
    }

    /**
     * Operation postPublishersAppConfigWithHttpInfo
     *
     * Add a Publisher to list of Publishers for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\PublisherAppConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPublishersAppConfigWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->postPublishersAppConfigRequest($server_name, $vhost_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postPublishersAppConfigAsync
     *
     * Add a Publisher to list of Publishers for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\PublisherAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPublishersAppConfigAsync($server_name, $vhost_name, $app_name, $body)
    {
        return $this->postPublishersAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPublishersAppConfigAsyncWithHttpInfo
     *
     * Add a Publisher to list of Publishers for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\PublisherAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPublishersAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->postPublishersAppConfigRequest($server_name, $vhost_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPublishersAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\PublisherAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPublishersAppConfigRequest($server_name, $vhost_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling postPublishersAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling postPublishersAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling postPublishersAppConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postPublishersAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/publishers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPushPublishStreamAppConfig
     *
     * Adds the specified PushPublish map entry for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  string $entry_name The entry name needed for this REST call (required)
     * @param  \Swagger\Client\Model\PushPublishStreamAppConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postPushPublishStreamAppConfig($server_name, $vhost_name, $app_name, $entry_name, $body)
    {
        $this->postPushPublishStreamAppConfigWithHttpInfo($server_name, $vhost_name, $app_name, $entry_name, $body);
    }

    /**
     * Operation postPushPublishStreamAppConfigWithHttpInfo
     *
     * Adds the specified PushPublish map entry for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $entry_name The entry name needed for this REST call (required)
     * @param  \Swagger\Client\Model\PushPublishStreamAppConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPushPublishStreamAppConfigWithHttpInfo($server_name, $vhost_name, $app_name, $entry_name, $body)
    {
        $returnType = '';
        $request = $this->postPushPublishStreamAppConfigRequest($server_name, $vhost_name, $app_name, $entry_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postPushPublishStreamAppConfigAsync
     *
     * Adds the specified PushPublish map entry for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $entry_name The entry name needed for this REST call (required)
     * @param  \Swagger\Client\Model\PushPublishStreamAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPushPublishStreamAppConfigAsync($server_name, $vhost_name, $app_name, $entry_name, $body)
    {
        return $this->postPushPublishStreamAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $entry_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPushPublishStreamAppConfigAsyncWithHttpInfo
     *
     * Adds the specified PushPublish map entry for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $entry_name The entry name needed for this REST call (required)
     * @param  \Swagger\Client\Model\PushPublishStreamAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPushPublishStreamAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $entry_name, $body)
    {
        $returnType = '';
        $request = $this->postPushPublishStreamAppConfigRequest($server_name, $vhost_name, $app_name, $entry_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPushPublishStreamAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $entry_name The entry name needed for this REST call (required)
     * @param  \Swagger\Client\Model\PushPublishStreamAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPushPublishStreamAppConfigRequest($server_name, $vhost_name, $app_name, $entry_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling postPushPublishStreamAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling postPushPublishStreamAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling postPushPublishStreamAppConfig'
            );
        }
        // verify the required parameter 'entry_name' is set
        if ($entry_name === null || (is_array($entry_name) && count($entry_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entry_name when calling postPushPublishStreamAppConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postPushPublishStreamAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/pushpublish/mapentries/{entryName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($entry_name !== null) {
            $resourcePath = str_replace(
                '{' . 'entryName' . '}',
                ObjectSerializer::toPathValue($entry_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPushPublishStreamsAppConfig
     *
     * Adds a PushPublish map entry to list of PushPublish map entries for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\PushPublishStreamAppConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postPushPublishStreamsAppConfig($server_name, $vhost_name, $app_name, $body)
    {
        $this->postPushPublishStreamsAppConfigWithHttpInfo($server_name, $vhost_name, $app_name, $body);
    }

    /**
     * Operation postPushPublishStreamsAppConfigWithHttpInfo
     *
     * Adds a PushPublish map entry to list of PushPublish map entries for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\PushPublishStreamAppConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPushPublishStreamsAppConfigWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->postPushPublishStreamsAppConfigRequest($server_name, $vhost_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postPushPublishStreamsAppConfigAsync
     *
     * Adds a PushPublish map entry to list of PushPublish map entries for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\PushPublishStreamAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPushPublishStreamsAppConfigAsync($server_name, $vhost_name, $app_name, $body)
    {
        return $this->postPushPublishStreamsAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPushPublishStreamsAppConfigAsyncWithHttpInfo
     *
     * Adds a PushPublish map entry to list of PushPublish map entries for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\PushPublishStreamAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPushPublishStreamsAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->postPushPublishStreamsAppConfigRequest($server_name, $vhost_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPushPublishStreamsAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\PushPublishStreamAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPushPublishStreamsAppConfigRequest($server_name, $vhost_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling postPushPublishStreamsAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling postPushPublishStreamsAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling postPushPublishStreamsAppConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postPushPublishStreamsAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/pushpublish/mapentries';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postSMILFileAppConfig
     *
     * Adds the specified SMIL File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\SMILFileAppConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postSMILFileAppConfig($server_name, $vhost_name, $smilfile_name, $app_name, $body)
    {
        $this->postSMILFileAppConfigWithHttpInfo($server_name, $vhost_name, $smilfile_name, $app_name, $body);
    }

    /**
     * Operation postSMILFileAppConfigWithHttpInfo
     *
     * Adds the specified SMIL File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\SMILFileAppConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postSMILFileAppConfigWithHttpInfo($server_name, $vhost_name, $smilfile_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->postSMILFileAppConfigRequest($server_name, $vhost_name, $smilfile_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postSMILFileAppConfigAsync
     *
     * Adds the specified SMIL File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\SMILFileAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSMILFileAppConfigAsync($server_name, $vhost_name, $smilfile_name, $app_name, $body)
    {
        return $this->postSMILFileAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $smilfile_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postSMILFileAppConfigAsyncWithHttpInfo
     *
     * Adds the specified SMIL File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\SMILFileAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSMILFileAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $smilfile_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->postSMILFileAppConfigRequest($server_name, $vhost_name, $smilfile_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postSMILFileAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\SMILFileAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postSMILFileAppConfigRequest($server_name, $vhost_name, $smilfile_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling postSMILFileAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling postSMILFileAppConfig'
            );
        }
        // verify the required parameter 'smilfile_name' is set
        if ($smilfile_name === null || (is_array($smilfile_name) && count($smilfile_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $smilfile_name when calling postSMILFileAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling postSMILFileAppConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postSMILFileAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/smilfiles/{smilfileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($smilfile_name !== null) {
            $resourcePath = str_replace(
                '{' . 'smilfileName' . '}',
                ObjectSerializer::toPathValue($smilfile_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postSMILFilesAppConfig
     *
     * Adds a SMIL File to the list of SMIL Files for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  \Swagger\Client\Model\SMILFileAppConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postSMILFilesAppConfig($server_name, $vhost_name, $app_name, $body)
    {
        $this->postSMILFilesAppConfigWithHttpInfo($server_name, $vhost_name, $app_name, $body);
    }

    /**
     * Operation postSMILFilesAppConfigWithHttpInfo
     *
     * Adds a SMIL File to the list of SMIL Files for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  \Swagger\Client\Model\SMILFileAppConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postSMILFilesAppConfigWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->postSMILFilesAppConfigRequest($server_name, $vhost_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postSMILFilesAppConfigAsync
     *
     * Adds a SMIL File to the list of SMIL Files for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  \Swagger\Client\Model\SMILFileAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSMILFilesAppConfigAsync($server_name, $vhost_name, $app_name, $body)
    {
        return $this->postSMILFilesAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postSMILFilesAppConfigAsyncWithHttpInfo
     *
     * Adds a SMIL File to the list of SMIL Files for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  \Swagger\Client\Model\SMILFileAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSMILFilesAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->postSMILFilesAppConfigRequest($server_name, $vhost_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postSMILFilesAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  \Swagger\Client\Model\SMILFileAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postSMILFilesAppConfigRequest($server_name, $vhost_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling postSMILFilesAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling postSMILFilesAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling postSMILFilesAppConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postSMILFilesAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/smilfiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postStreamFileAppConfig
     *
     * Adds the specified Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\StreamFileAppConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postStreamFileAppConfig($server_name, $vhost_name, $streamfile_name, $app_name, $body)
    {
        $this->postStreamFileAppConfigWithHttpInfo($server_name, $vhost_name, $streamfile_name, $app_name, $body);
    }

    /**
     * Operation postStreamFileAppConfigWithHttpInfo
     *
     * Adds the specified Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\StreamFileAppConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postStreamFileAppConfigWithHttpInfo($server_name, $vhost_name, $streamfile_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->postStreamFileAppConfigRequest($server_name, $vhost_name, $streamfile_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postStreamFileAppConfigAsync
     *
     * Adds the specified Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\StreamFileAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postStreamFileAppConfigAsync($server_name, $vhost_name, $streamfile_name, $app_name, $body)
    {
        return $this->postStreamFileAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $streamfile_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postStreamFileAppConfigAsyncWithHttpInfo
     *
     * Adds the specified Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\StreamFileAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postStreamFileAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $streamfile_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->postStreamFileAppConfigRequest($server_name, $vhost_name, $streamfile_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postStreamFileAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\StreamFileAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postStreamFileAppConfigRequest($server_name, $vhost_name, $streamfile_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling postStreamFileAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling postStreamFileAppConfig'
            );
        }
        // verify the required parameter 'streamfile_name' is set
        if ($streamfile_name === null || (is_array($streamfile_name) && count($streamfile_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $streamfile_name when calling postStreamFileAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling postStreamFileAppConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postStreamFileAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/streamfiles/{streamfileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($streamfile_name !== null) {
            $resourcePath = str_replace(
                '{' . 'streamfileName' . '}',
                ObjectSerializer::toPathValue($streamfile_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postStreamFilesAppConfig
     *
     * Adds a Stream File to the list of Stream Files for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\StreamFileAppConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postStreamFilesAppConfig($server_name, $vhost_name, $app_name, $body)
    {
        $this->postStreamFilesAppConfigWithHttpInfo($server_name, $vhost_name, $app_name, $body);
    }

    /**
     * Operation postStreamFilesAppConfigWithHttpInfo
     *
     * Adds a Stream File to the list of Stream Files for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\StreamFileAppConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postStreamFilesAppConfigWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->postStreamFilesAppConfigRequest($server_name, $vhost_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postStreamFilesAppConfigAsync
     *
     * Adds a Stream File to the list of Stream Files for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\StreamFileAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postStreamFilesAppConfigAsync($server_name, $vhost_name, $app_name, $body)
    {
        return $this->postStreamFilesAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postStreamFilesAppConfigAsyncWithHttpInfo
     *
     * Adds a Stream File to the list of Stream Files for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\StreamFileAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postStreamFilesAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->postStreamFilesAppConfigRequest($server_name, $vhost_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postStreamFilesAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\StreamFileAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postStreamFilesAppConfigRequest($server_name, $vhost_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling postStreamFilesAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling postStreamFilesAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling postStreamFilesAppConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postStreamFilesAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/streamfiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postStreamRecorderConfig
     *
     * Creates a new Stream Recorder and starts recording
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  string $recorder_name recorder_name (required)
     * @param  string $instance_name instance_name (required)
     * @param  \Swagger\Client\Model\StreamRecorderConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postStreamRecorderConfig($server_name, $vhost_name, $app_name, $recorder_name, $instance_name, $body)
    {
        $this->postStreamRecorderConfigWithHttpInfo($server_name, $vhost_name, $app_name, $recorder_name, $instance_name, $body);
    }

    /**
     * Operation postStreamRecorderConfigWithHttpInfo
     *
     * Creates a new Stream Recorder and starts recording
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $recorder_name (required)
     * @param  string $instance_name (required)
     * @param  \Swagger\Client\Model\StreamRecorderConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postStreamRecorderConfigWithHttpInfo($server_name, $vhost_name, $app_name, $recorder_name, $instance_name, $body)
    {
        $returnType = '';
        $request = $this->postStreamRecorderConfigRequest($server_name, $vhost_name, $app_name, $recorder_name, $instance_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postStreamRecorderConfigAsync
     *
     * Creates a new Stream Recorder and starts recording
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $recorder_name (required)
     * @param  string $instance_name (required)
     * @param  \Swagger\Client\Model\StreamRecorderConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postStreamRecorderConfigAsync($server_name, $vhost_name, $app_name, $recorder_name, $instance_name, $body)
    {
        return $this->postStreamRecorderConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $recorder_name, $instance_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postStreamRecorderConfigAsyncWithHttpInfo
     *
     * Creates a new Stream Recorder and starts recording
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $recorder_name (required)
     * @param  string $instance_name (required)
     * @param  \Swagger\Client\Model\StreamRecorderConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postStreamRecorderConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $recorder_name, $instance_name, $body)
    {
        $returnType = '';
        $request = $this->postStreamRecorderConfigRequest($server_name, $vhost_name, $app_name, $recorder_name, $instance_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postStreamRecorderConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $recorder_name (required)
     * @param  string $instance_name (required)
     * @param  \Swagger\Client\Model\StreamRecorderConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postStreamRecorderConfigRequest($server_name, $vhost_name, $app_name, $recorder_name, $instance_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling postStreamRecorderConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling postStreamRecorderConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling postStreamRecorderConfig'
            );
        }
        // verify the required parameter 'recorder_name' is set
        if ($recorder_name === null || (is_array($recorder_name) && count($recorder_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recorder_name when calling postStreamRecorderConfig'
            );
        }
        // verify the required parameter 'instance_name' is set
        if ($instance_name === null || (is_array($instance_name) && count($instance_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_name when calling postStreamRecorderConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postStreamRecorderConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/instances/{instanceName}/streamrecorders/{recorderName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($recorder_name !== null) {
            $resourcePath = str_replace(
                '{' . 'recorderName' . '}',
                ObjectSerializer::toPathValue($recorder_name),
                $resourcePath
            );
        }
        // path params
        if ($instance_name !== null) {
            $resourcePath = str_replace(
                '{' . 'instanceName' . '}',
                ObjectSerializer::toPathValue($instance_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postStreamRecordersConfig
     *
     * Creates a new Stream Recorder in the specified Application Instance and starts recording
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  string $instance_name instance_name (required)
     * @param  \Swagger\Client\Model\StreamRecorderConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postStreamRecordersConfig($server_name, $vhost_name, $app_name, $instance_name, $body)
    {
        $this->postStreamRecordersConfigWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name, $body);
    }

    /**
     * Operation postStreamRecordersConfigWithHttpInfo
     *
     * Creates a new Stream Recorder in the specified Application Instance and starts recording
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  \Swagger\Client\Model\StreamRecorderConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postStreamRecordersConfigWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name, $body)
    {
        $returnType = '';
        $request = $this->postStreamRecordersConfigRequest($server_name, $vhost_name, $app_name, $instance_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postStreamRecordersConfigAsync
     *
     * Creates a new Stream Recorder in the specified Application Instance and starts recording
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  \Swagger\Client\Model\StreamRecorderConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postStreamRecordersConfigAsync($server_name, $vhost_name, $app_name, $instance_name, $body)
    {
        return $this->postStreamRecordersConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postStreamRecordersConfigAsyncWithHttpInfo
     *
     * Creates a new Stream Recorder in the specified Application Instance and starts recording
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  \Swagger\Client\Model\StreamRecorderConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postStreamRecordersConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $instance_name, $body)
    {
        $returnType = '';
        $request = $this->postStreamRecordersConfigRequest($server_name, $vhost_name, $app_name, $instance_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postStreamRecordersConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $instance_name (required)
     * @param  \Swagger\Client\Model\StreamRecorderConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postStreamRecordersConfigRequest($server_name, $vhost_name, $app_name, $instance_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling postStreamRecordersConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling postStreamRecordersConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling postStreamRecordersConfig'
            );
        }
        // verify the required parameter 'instance_name' is set
        if ($instance_name === null || (is_array($instance_name) && count($instance_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_name when calling postStreamRecordersConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postStreamRecordersConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/instances/{instanceName}/streamrecorders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($instance_name !== null) {
            $resourcePath = str_replace(
                '{' . 'instanceName' . '}',
                ObjectSerializer::toPathValue($instance_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postTranscoderEncodeAppConfig
     *
     * Adds the specified Trancoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $encode_name encode_name (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeAppConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postTranscoderEncodeAppConfig($server_name, $vhost_name, $template_name, $encode_name, $app_name, $body)
    {
        $this->postTranscoderEncodeAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $app_name, $body);
    }

    /**
     * Operation postTranscoderEncodeAppConfigWithHttpInfo
     *
     * Adds the specified Trancoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeAppConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postTranscoderEncodeAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->postTranscoderEncodeAppConfigRequest($server_name, $vhost_name, $template_name, $encode_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postTranscoderEncodeAppConfigAsync
     *
     * Adds the specified Trancoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTranscoderEncodeAppConfigAsync($server_name, $vhost_name, $template_name, $encode_name, $app_name, $body)
    {
        return $this->postTranscoderEncodeAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postTranscoderEncodeAppConfigAsyncWithHttpInfo
     *
     * Adds the specified Trancoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTranscoderEncodeAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->postTranscoderEncodeAppConfigRequest($server_name, $vhost_name, $template_name, $encode_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postTranscoderEncodeAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postTranscoderEncodeAppConfigRequest($server_name, $vhost_name, $template_name, $encode_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling postTranscoderEncodeAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling postTranscoderEncodeAppConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling postTranscoderEncodeAppConfig'
            );
        }
        // verify the required parameter 'encode_name' is set
        if ($encode_name === null || (is_array($encode_name) && count($encode_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $encode_name when calling postTranscoderEncodeAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling postTranscoderEncodeAppConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postTranscoderEncodeAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/transcoder/templates/{templateName}/encodes/{encodeName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($encode_name !== null) {
            $resourcePath = str_replace(
                '{' . 'encodeName' . '}',
                ObjectSerializer::toPathValue($encode_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postTranscoderEncodesAppConfig
     *
     * Adds a Transcoder Encode Configuration to the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeAppConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postTranscoderEncodesAppConfig($server_name, $vhost_name, $template_name, $app_name, $body)
    {
        $this->postTranscoderEncodesAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $app_name, $body);
    }

    /**
     * Operation postTranscoderEncodesAppConfigWithHttpInfo
     *
     * Adds a Transcoder Encode Configuration to the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeAppConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postTranscoderEncodesAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->postTranscoderEncodesAppConfigRequest($server_name, $vhost_name, $template_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postTranscoderEncodesAppConfigAsync
     *
     * Adds a Transcoder Encode Configuration to the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTranscoderEncodesAppConfigAsync($server_name, $vhost_name, $template_name, $app_name, $body)
    {
        return $this->postTranscoderEncodesAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postTranscoderEncodesAppConfigAsyncWithHttpInfo
     *
     * Adds a Transcoder Encode Configuration to the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTranscoderEncodesAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->postTranscoderEncodesAppConfigRequest($server_name, $vhost_name, $template_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postTranscoderEncodesAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postTranscoderEncodesAppConfigRequest($server_name, $vhost_name, $template_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling postTranscoderEncodesAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling postTranscoderEncodesAppConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling postTranscoderEncodesAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling postTranscoderEncodesAppConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postTranscoderEncodesAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/transcoder/templates/{templateName}/encodes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postTranscoderStreamNameGroupAppConfig
     *
     * Adds the specified Trancoder StreamNameGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $group_name group_name (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\TranscoderStreamNameGroupAppConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postTranscoderStreamNameGroupAppConfig($server_name, $vhost_name, $template_name, $group_name, $app_name, $body)
    {
        $this->postTranscoderStreamNameGroupAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $group_name, $app_name, $body);
    }

    /**
     * Operation postTranscoderStreamNameGroupAppConfigWithHttpInfo
     *
     * Adds the specified Trancoder StreamNameGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $group_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderStreamNameGroupAppConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postTranscoderStreamNameGroupAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $group_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->postTranscoderStreamNameGroupAppConfigRequest($server_name, $vhost_name, $template_name, $group_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postTranscoderStreamNameGroupAppConfigAsync
     *
     * Adds the specified Trancoder StreamNameGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $group_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderStreamNameGroupAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTranscoderStreamNameGroupAppConfigAsync($server_name, $vhost_name, $template_name, $group_name, $app_name, $body)
    {
        return $this->postTranscoderStreamNameGroupAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $group_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postTranscoderStreamNameGroupAppConfigAsyncWithHttpInfo
     *
     * Adds the specified Trancoder StreamNameGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $group_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderStreamNameGroupAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTranscoderStreamNameGroupAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $group_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->postTranscoderStreamNameGroupAppConfigRequest($server_name, $vhost_name, $template_name, $group_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postTranscoderStreamNameGroupAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $group_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderStreamNameGroupAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postTranscoderStreamNameGroupAppConfigRequest($server_name, $vhost_name, $template_name, $group_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling postTranscoderStreamNameGroupAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling postTranscoderStreamNameGroupAppConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling postTranscoderStreamNameGroupAppConfig'
            );
        }
        // verify the required parameter 'group_name' is set
        if ($group_name === null || (is_array($group_name) && count($group_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_name when calling postTranscoderStreamNameGroupAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling postTranscoderStreamNameGroupAppConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postTranscoderStreamNameGroupAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/transcoder/templates/{templateName}/streamnamegroups/{groupName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($group_name !== null) {
            $resourcePath = str_replace(
                '{' . 'groupName' . '}',
                ObjectSerializer::toPathValue($group_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postTranscoderStreamNameGroupsAppConfig
     *
     * Adds a Transcoder Stream Name Groups Configuration to the specified Template
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\TranscoderStreamNameGroupAppConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postTranscoderStreamNameGroupsAppConfig($server_name, $vhost_name, $template_name, $app_name, $body)
    {
        $this->postTranscoderStreamNameGroupsAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $app_name, $body);
    }

    /**
     * Operation postTranscoderStreamNameGroupsAppConfigWithHttpInfo
     *
     * Adds a Transcoder Stream Name Groups Configuration to the specified Template
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderStreamNameGroupAppConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postTranscoderStreamNameGroupsAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->postTranscoderStreamNameGroupsAppConfigRequest($server_name, $vhost_name, $template_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postTranscoderStreamNameGroupsAppConfigAsync
     *
     * Adds a Transcoder Stream Name Groups Configuration to the specified Template
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderStreamNameGroupAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTranscoderStreamNameGroupsAppConfigAsync($server_name, $vhost_name, $template_name, $app_name, $body)
    {
        return $this->postTranscoderStreamNameGroupsAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postTranscoderStreamNameGroupsAppConfigAsyncWithHttpInfo
     *
     * Adds a Transcoder Stream Name Groups Configuration to the specified Template
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderStreamNameGroupAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTranscoderStreamNameGroupsAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->postTranscoderStreamNameGroupsAppConfigRequest($server_name, $vhost_name, $template_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postTranscoderStreamNameGroupsAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderStreamNameGroupAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postTranscoderStreamNameGroupsAppConfigRequest($server_name, $vhost_name, $template_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling postTranscoderStreamNameGroupsAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling postTranscoderStreamNameGroupsAppConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling postTranscoderStreamNameGroupsAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling postTranscoderStreamNameGroupsAppConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postTranscoderStreamNameGroupsAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/transcoder/templates/{templateName}/streamnamegroups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postTranscoderTemplateAppConfig
     *
     * Adds the specified Trancoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateAppConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postTranscoderTemplateAppConfig($server_name, $vhost_name, $template_name, $app_name, $body)
    {
        $this->postTranscoderTemplateAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $app_name, $body);
    }

    /**
     * Operation postTranscoderTemplateAppConfigWithHttpInfo
     *
     * Adds the specified Trancoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateAppConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postTranscoderTemplateAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->postTranscoderTemplateAppConfigRequest($server_name, $vhost_name, $template_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postTranscoderTemplateAppConfigAsync
     *
     * Adds the specified Trancoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTranscoderTemplateAppConfigAsync($server_name, $vhost_name, $template_name, $app_name, $body)
    {
        return $this->postTranscoderTemplateAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postTranscoderTemplateAppConfigAsyncWithHttpInfo
     *
     * Adds the specified Trancoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTranscoderTemplateAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->postTranscoderTemplateAppConfigRequest($server_name, $vhost_name, $template_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postTranscoderTemplateAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postTranscoderTemplateAppConfigRequest($server_name, $vhost_name, $template_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling postTranscoderTemplateAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling postTranscoderTemplateAppConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling postTranscoderTemplateAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling postTranscoderTemplateAppConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postTranscoderTemplateAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/transcoder/templates/{templateName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postTranscoderTemplatesAppConfig
     *
     * Adds a Transcoder Templates Configuration to the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateAppConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postTranscoderTemplatesAppConfig($server_name, $vhost_name, $app_name, $body)
    {
        $this->postTranscoderTemplatesAppConfigWithHttpInfo($server_name, $vhost_name, $app_name, $body);
    }

    /**
     * Operation postTranscoderTemplatesAppConfigWithHttpInfo
     *
     * Adds a Transcoder Templates Configuration to the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateAppConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postTranscoderTemplatesAppConfigWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->postTranscoderTemplatesAppConfigRequest($server_name, $vhost_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postTranscoderTemplatesAppConfigAsync
     *
     * Adds a Transcoder Templates Configuration to the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTranscoderTemplatesAppConfigAsync($server_name, $vhost_name, $app_name, $body)
    {
        return $this->postTranscoderTemplatesAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postTranscoderTemplatesAppConfigAsyncWithHttpInfo
     *
     * Adds a Transcoder Templates Configuration to the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postTranscoderTemplatesAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->postTranscoderTemplatesAppConfigRequest($server_name, $vhost_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postTranscoderTemplatesAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postTranscoderTemplatesAppConfigRequest($server_name, $vhost_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling postTranscoderTemplatesAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling postTranscoderTemplatesAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling postTranscoderTemplatesAppConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postTranscoderTemplatesAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/transcoder/templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postWSCRESTProxyConfig
     *
     * Proxies a WSC REST API request
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\WSCRESTProxyConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postWSCRESTProxyConfig($server_name, $vhost_name, $app_name, $body)
    {
        $this->postWSCRESTProxyConfigWithHttpInfo($server_name, $vhost_name, $app_name, $body);
    }

    /**
     * Operation postWSCRESTProxyConfigWithHttpInfo
     *
     * Proxies a WSC REST API request
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\WSCRESTProxyConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postWSCRESTProxyConfigWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->postWSCRESTProxyConfigRequest($server_name, $vhost_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation postWSCRESTProxyConfigAsync
     *
     * Proxies a WSC REST API request
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\WSCRESTProxyConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postWSCRESTProxyConfigAsync($server_name, $vhost_name, $app_name, $body)
    {
        return $this->postWSCRESTProxyConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postWSCRESTProxyConfigAsyncWithHttpInfo
     *
     * Proxies a WSC REST API request
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\WSCRESTProxyConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postWSCRESTProxyConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->postWSCRESTProxyConfigRequest($server_name, $vhost_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postWSCRESTProxyConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\WSCRESTProxyConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postWSCRESTProxyConfigRequest($server_name, $vhost_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling postWSCRESTProxyConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling postWSCRESTProxyConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling postWSCRESTProxyConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling postWSCRESTProxyConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/wscrestproxy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putApplicationAction
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $dst_entry_name The destination application name when copying (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putApplicationAction($server_name, $action, $vhost_name, $app_name, $dst_entry_name = null)
    {
        $this->putApplicationActionWithHttpInfo($server_name, $action, $vhost_name, $app_name, $dst_entry_name);
    }

    /**
     * Operation putApplicationActionWithHttpInfo
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $dst_entry_name The destination application name when copying (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putApplicationActionWithHttpInfo($server_name, $action, $vhost_name, $app_name, $dst_entry_name = null)
    {
        $returnType = '';
        $request = $this->putApplicationActionRequest($server_name, $action, $vhost_name, $app_name, $dst_entry_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putApplicationActionAsync
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $dst_entry_name The destination application name when copying (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putApplicationActionAsync($server_name, $action, $vhost_name, $app_name, $dst_entry_name = null)
    {
        return $this->putApplicationActionAsyncWithHttpInfo($server_name, $action, $vhost_name, $app_name, $dst_entry_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putApplicationActionAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $dst_entry_name The destination application name when copying (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putApplicationActionAsyncWithHttpInfo($server_name, $action, $vhost_name, $app_name, $dst_entry_name = null)
    {
        $returnType = '';
        $request = $this->putApplicationActionRequest($server_name, $action, $vhost_name, $app_name, $dst_entry_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putApplicationAction'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $dst_entry_name The destination application name when copying (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putApplicationActionRequest($server_name, $action, $vhost_name, $app_name, $dst_entry_name = null)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putApplicationAction'
            );
        }
        // verify the required parameter 'action' is set
        if ($action === null || (is_array($action) && count($action) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $action when calling putApplicationAction'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putApplicationAction'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putApplicationAction'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/actions/{action}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($dst_entry_name !== null) {
            $queryParams['dstEntryName'] = ObjectSerializer::toQueryValue($dst_entry_name);
        }

        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($action !== null) {
            $resourcePath = str_replace(
                '{' . 'action' . '}',
                ObjectSerializer::toPathValue($action),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putApplicationConfig
     *
     * Updates the specified Application configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\ApplicationConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putApplicationConfig($server_name, $vhost_name, $app_name, $body)
    {
        $this->putApplicationConfigWithHttpInfo($server_name, $vhost_name, $app_name, $body);
    }

    /**
     * Operation putApplicationConfigWithHttpInfo
     *
     * Updates the specified Application configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\ApplicationConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putApplicationConfigWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putApplicationConfigRequest($server_name, $vhost_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putApplicationConfigAsync
     *
     * Updates the specified Application configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\ApplicationConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putApplicationConfigAsync($server_name, $vhost_name, $app_name, $body)
    {
        return $this->putApplicationConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putApplicationConfigAsyncWithHttpInfo
     *
     * Updates the specified Application configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\ApplicationConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putApplicationConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putApplicationConfigRequest($server_name, $vhost_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putApplicationConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\ApplicationConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putApplicationConfigRequest($server_name, $vhost_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putApplicationConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putApplicationConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putApplicationConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putApplicationConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putApplicationConfigAdv
     *
     * Updates the specified advanced Application configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\ApplicationConfigAdv $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putApplicationConfigAdv($server_name, $vhost_name, $app_name, $body)
    {
        $this->putApplicationConfigAdvWithHttpInfo($server_name, $vhost_name, $app_name, $body);
    }

    /**
     * Operation putApplicationConfigAdvWithHttpInfo
     *
     * Updates the specified advanced Application configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\ApplicationConfigAdv $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putApplicationConfigAdvWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putApplicationConfigAdvRequest($server_name, $vhost_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putApplicationConfigAdvAsync
     *
     * Updates the specified advanced Application configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\ApplicationConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putApplicationConfigAdvAsync($server_name, $vhost_name, $app_name, $body)
    {
        return $this->putApplicationConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putApplicationConfigAdvAsyncWithHttpInfo
     *
     * Updates the specified advanced Application configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\ApplicationConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putApplicationConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putApplicationConfigAdvRequest($server_name, $vhost_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putApplicationConfigAdv'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\ApplicationConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putApplicationConfigAdvRequest($server_name, $vhost_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putApplicationConfigAdv'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putApplicationConfigAdv'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putApplicationConfigAdv'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putApplicationConfigAdv'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/adv';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putBuyDRMStreamMapsConfig
     *
     * Updates the BuyDRM stream mapfile for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\BuyDRMStreamMapsConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putBuyDRMStreamMapsConfig($server_name, $vhost_name, $app_name, $body)
    {
        $this->putBuyDRMStreamMapsConfigWithHttpInfo($server_name, $vhost_name, $app_name, $body);
    }

    /**
     * Operation putBuyDRMStreamMapsConfigWithHttpInfo
     *
     * Updates the BuyDRM stream mapfile for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\BuyDRMStreamMapsConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putBuyDRMStreamMapsConfigWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putBuyDRMStreamMapsConfigRequest($server_name, $vhost_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putBuyDRMStreamMapsConfigAsync
     *
     * Updates the BuyDRM stream mapfile for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\BuyDRMStreamMapsConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putBuyDRMStreamMapsConfigAsync($server_name, $vhost_name, $app_name, $body)
    {
        return $this->putBuyDRMStreamMapsConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putBuyDRMStreamMapsConfigAsyncWithHttpInfo
     *
     * Updates the BuyDRM stream mapfile for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\BuyDRMStreamMapsConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putBuyDRMStreamMapsConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putBuyDRMStreamMapsConfigRequest($server_name, $vhost_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putBuyDRMStreamMapsConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\BuyDRMStreamMapsConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putBuyDRMStreamMapsConfigRequest($server_name, $vhost_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putBuyDRMStreamMapsConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putBuyDRMStreamMapsConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putBuyDRMStreamMapsConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putBuyDRMStreamMapsConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/drm/buydrmmapfile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putDRMConfig
     *
     * Updates the DRM configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\DRMConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putDRMConfig($server_name, $vhost_name, $app_name, $body)
    {
        $this->putDRMConfigWithHttpInfo($server_name, $vhost_name, $app_name, $body);
    }

    /**
     * Operation putDRMConfigWithHttpInfo
     *
     * Updates the DRM configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\DRMConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putDRMConfigWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putDRMConfigRequest($server_name, $vhost_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putDRMConfigAsync
     *
     * Updates the DRM configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\DRMConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putDRMConfigAsync($server_name, $vhost_name, $app_name, $body)
    {
        return $this->putDRMConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putDRMConfigAsyncWithHttpInfo
     *
     * Updates the DRM configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\DRMConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putDRMConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putDRMConfigRequest($server_name, $vhost_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putDRMConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\DRMConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putDRMConfigRequest($server_name, $vhost_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putDRMConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putDRMConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putDRMConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putDRMConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/drm';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putDRMConfigAdv
     *
     * Updates the advanced DRM configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\DRMConfigAdv $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putDRMConfigAdv($server_name, $vhost_name, $app_name, $body)
    {
        $this->putDRMConfigAdvWithHttpInfo($server_name, $vhost_name, $app_name, $body);
    }

    /**
     * Operation putDRMConfigAdvWithHttpInfo
     *
     * Updates the advanced DRM configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\DRMConfigAdv $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putDRMConfigAdvWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putDRMConfigAdvRequest($server_name, $vhost_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putDRMConfigAdvAsync
     *
     * Updates the advanced DRM configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\DRMConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putDRMConfigAdvAsync($server_name, $vhost_name, $app_name, $body)
    {
        return $this->putDRMConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putDRMConfigAdvAsyncWithHttpInfo
     *
     * Updates the advanced DRM configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\DRMConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putDRMConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putDRMConfigAdvRequest($server_name, $vhost_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putDRMConfigAdv'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\DRMConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putDRMConfigAdvRequest($server_name, $vhost_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putDRMConfigAdv'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putDRMConfigAdv'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putDRMConfigAdv'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putDRMConfigAdv'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/drm/adv';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putDVRConfig
     *
     * Updates the DVR configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\DVRConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putDVRConfig($server_name, $vhost_name, $app_name, $body)
    {
        $this->putDVRConfigWithHttpInfo($server_name, $vhost_name, $app_name, $body);
    }

    /**
     * Operation putDVRConfigWithHttpInfo
     *
     * Updates the DVR configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\DVRConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putDVRConfigWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putDVRConfigRequest($server_name, $vhost_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putDVRConfigAsync
     *
     * Updates the DVR configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\DVRConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putDVRConfigAsync($server_name, $vhost_name, $app_name, $body)
    {
        return $this->putDVRConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putDVRConfigAsyncWithHttpInfo
     *
     * Updates the DVR configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\DVRConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putDVRConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putDVRConfigRequest($server_name, $vhost_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putDVRConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\DVRConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putDVRConfigRequest($server_name, $vhost_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putDVRConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putDVRConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putDVRConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putDVRConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/dvr';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putDVRConfigAdv
     *
     * Updates the advanced DVR configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\DVRConfigAdv $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putDVRConfigAdv($server_name, $vhost_name, $app_name, $body)
    {
        $this->putDVRConfigAdvWithHttpInfo($server_name, $vhost_name, $app_name, $body);
    }

    /**
     * Operation putDVRConfigAdvWithHttpInfo
     *
     * Updates the advanced DVR configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\DVRConfigAdv $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putDVRConfigAdvWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putDVRConfigAdvRequest($server_name, $vhost_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putDVRConfigAdvAsync
     *
     * Updates the advanced DVR configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\DVRConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putDVRConfigAdvAsync($server_name, $vhost_name, $app_name, $body)
    {
        return $this->putDVRConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putDVRConfigAdvAsyncWithHttpInfo
     *
     * Updates the advanced DVR configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\DVRConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putDVRConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putDVRConfigAdvRequest($server_name, $vhost_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putDVRConfigAdv'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\DVRConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putDVRConfigAdvRequest($server_name, $vhost_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putDVRConfigAdv'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putDVRConfigAdv'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putDVRConfigAdv'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putDVRConfigAdv'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/dvr/adv';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putDvrRESTConverterStoreAction
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $instance_name The application instance name needed for this REST call (required)
     * @param  string $dvr_store_name The nDVR store name needed for this REST call (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putDvrRESTConverterStoreAction($server_name, $action, $vhost_name, $app_name, $instance_name, $dvr_store_name)
    {
        $this->putDvrRESTConverterStoreActionWithHttpInfo($server_name, $action, $vhost_name, $app_name, $instance_name, $dvr_store_name);
    }

    /**
     * Operation putDvrRESTConverterStoreActionWithHttpInfo
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $instance_name The application instance name needed for this REST call (required)
     * @param  string $dvr_store_name The nDVR store name needed for this REST call (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putDvrRESTConverterStoreActionWithHttpInfo($server_name, $action, $vhost_name, $app_name, $instance_name, $dvr_store_name)
    {
        $returnType = '';
        $request = $this->putDvrRESTConverterStoreActionRequest($server_name, $action, $vhost_name, $app_name, $instance_name, $dvr_store_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putDvrRESTConverterStoreActionAsync
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $instance_name The application instance name needed for this REST call (required)
     * @param  string $dvr_store_name The nDVR store name needed for this REST call (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putDvrRESTConverterStoreActionAsync($server_name, $action, $vhost_name, $app_name, $instance_name, $dvr_store_name)
    {
        return $this->putDvrRESTConverterStoreActionAsyncWithHttpInfo($server_name, $action, $vhost_name, $app_name, $instance_name, $dvr_store_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putDvrRESTConverterStoreActionAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $instance_name The application instance name needed for this REST call (required)
     * @param  string $dvr_store_name The nDVR store name needed for this REST call (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putDvrRESTConverterStoreActionAsyncWithHttpInfo($server_name, $action, $vhost_name, $app_name, $instance_name, $dvr_store_name)
    {
        $returnType = '';
        $request = $this->putDvrRESTConverterStoreActionRequest($server_name, $action, $vhost_name, $app_name, $instance_name, $dvr_store_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putDvrRESTConverterStoreAction'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $instance_name The application instance name needed for this REST call (required)
     * @param  string $dvr_store_name The nDVR store name needed for this REST call (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putDvrRESTConverterStoreActionRequest($server_name, $action, $vhost_name, $app_name, $instance_name, $dvr_store_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putDvrRESTConverterStoreAction'
            );
        }
        // verify the required parameter 'action' is set
        if ($action === null || (is_array($action) && count($action) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $action when calling putDvrRESTConverterStoreAction'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putDvrRESTConverterStoreAction'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putDvrRESTConverterStoreAction'
            );
        }
        // verify the required parameter 'instance_name' is set
        if ($instance_name === null || (is_array($instance_name) && count($instance_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_name when calling putDvrRESTConverterStoreAction'
            );
        }
        // verify the required parameter 'dvr_store_name' is set
        if ($dvr_store_name === null || (is_array($dvr_store_name) && count($dvr_store_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dvr_store_name when calling putDvrRESTConverterStoreAction'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/instances/{instanceName}/dvrstores/{dvrStoreName}/actions/{action}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($action !== null) {
            $resourcePath = str_replace(
                '{' . 'action' . '}',
                ObjectSerializer::toPathValue($action),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($instance_name !== null) {
            $resourcePath = str_replace(
                '{' . 'instanceName' . '}',
                ObjectSerializer::toPathValue($instance_name),
                $resourcePath
            );
        }
        // path params
        if ($dvr_store_name !== null) {
            $resourcePath = str_replace(
                '{' . 'dvrStoreName' . '}',
                ObjectSerializer::toPathValue($dvr_store_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putDvrRESTConverterStoresAction
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $instance_name The application instance name needed for this REST call (required)
     * @param  string $dvr_converter_default_file_destination The file location to use when converting a nDVR store, the default is configured as the StorageDir in the application in use (optional)
     * @param  string $dvr_converter_debug_conversions Indicates if the conversion should have debugging enabled, can be true or false, default is false (optional)
     * @param  string $dvr_converter_continue_on_source_errors Indicates if the conversion should continue even if errors are detected, can be true or false, default is true (optional)
     * @param  string $dvr_converter_audio_video_sync_enable Indicates if the audio/video offset should be detected and conversion only started after the sync in no longer detected or over default allowable time. Can be true or false, default is false (optional)
     * @param  string $dvr_converter_audio_video_max_offset Indicates the maximum audio/video timecodes can be out of sync (optional, default to 200)
     * @param  string $dvr_converter_audio_video_max_buffer Indicates the maximum time a correct audio/video sync will be searched for before giving up (optional, default to 8000)
     * @param  string $dvr_converter_start_time A start time in UTC from where the conversion should start in the store, default is the first entry in the store (optional)
     * @param  string $dvr_converter_end_time A end time in UTC  where the conversion should end in the store, default is to the end of the store (optional)
     * @param  string $dvr_converter_duration A duration for the conversion either added to the start or subtracted from the end time, if you use duration you can not use start and end (optional)
     * @param  string $dvr_converter_output_filename Indicates the output filename if not using the default, which is the name of the store being converted (optional)
     * @param  string $dvr_converter_store_list The comma-separated list of stores to convert (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putDvrRESTConverterStoresAction($server_name, $action, $vhost_name, $app_name, $instance_name, $dvr_converter_default_file_destination = null, $dvr_converter_debug_conversions = null, $dvr_converter_continue_on_source_errors = null, $dvr_converter_audio_video_sync_enable = null, $dvr_converter_audio_video_max_offset = '200', $dvr_converter_audio_video_max_buffer = '8000', $dvr_converter_start_time = null, $dvr_converter_end_time = null, $dvr_converter_duration = null, $dvr_converter_output_filename = null, $dvr_converter_store_list = null)
    {
        $this->putDvrRESTConverterStoresActionWithHttpInfo($server_name, $action, $vhost_name, $app_name, $instance_name, $dvr_converter_default_file_destination, $dvr_converter_debug_conversions, $dvr_converter_continue_on_source_errors, $dvr_converter_audio_video_sync_enable, $dvr_converter_audio_video_max_offset, $dvr_converter_audio_video_max_buffer, $dvr_converter_start_time, $dvr_converter_end_time, $dvr_converter_duration, $dvr_converter_output_filename, $dvr_converter_store_list);
    }

    /**
     * Operation putDvrRESTConverterStoresActionWithHttpInfo
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $instance_name The application instance name needed for this REST call (required)
     * @param  string $dvr_converter_default_file_destination The file location to use when converting a nDVR store, the default is configured as the StorageDir in the application in use (optional)
     * @param  string $dvr_converter_debug_conversions Indicates if the conversion should have debugging enabled, can be true or false, default is false (optional)
     * @param  string $dvr_converter_continue_on_source_errors Indicates if the conversion should continue even if errors are detected, can be true or false, default is true (optional)
     * @param  string $dvr_converter_audio_video_sync_enable Indicates if the audio/video offset should be detected and conversion only started after the sync in no longer detected or over default allowable time. Can be true or false, default is false (optional)
     * @param  string $dvr_converter_audio_video_max_offset Indicates the maximum audio/video timecodes can be out of sync (optional, default to 200)
     * @param  string $dvr_converter_audio_video_max_buffer Indicates the maximum time a correct audio/video sync will be searched for before giving up (optional, default to 8000)
     * @param  string $dvr_converter_start_time A start time in UTC from where the conversion should start in the store, default is the first entry in the store (optional)
     * @param  string $dvr_converter_end_time A end time in UTC  where the conversion should end in the store, default is to the end of the store (optional)
     * @param  string $dvr_converter_duration A duration for the conversion either added to the start or subtracted from the end time, if you use duration you can not use start and end (optional)
     * @param  string $dvr_converter_output_filename Indicates the output filename if not using the default, which is the name of the store being converted (optional)
     * @param  string $dvr_converter_store_list The comma-separated list of stores to convert (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putDvrRESTConverterStoresActionWithHttpInfo($server_name, $action, $vhost_name, $app_name, $instance_name, $dvr_converter_default_file_destination = null, $dvr_converter_debug_conversions = null, $dvr_converter_continue_on_source_errors = null, $dvr_converter_audio_video_sync_enable = null, $dvr_converter_audio_video_max_offset = '200', $dvr_converter_audio_video_max_buffer = '8000', $dvr_converter_start_time = null, $dvr_converter_end_time = null, $dvr_converter_duration = null, $dvr_converter_output_filename = null, $dvr_converter_store_list = null)
    {
        $returnType = '';
        $request = $this->putDvrRESTConverterStoresActionRequest($server_name, $action, $vhost_name, $app_name, $instance_name, $dvr_converter_default_file_destination, $dvr_converter_debug_conversions, $dvr_converter_continue_on_source_errors, $dvr_converter_audio_video_sync_enable, $dvr_converter_audio_video_max_offset, $dvr_converter_audio_video_max_buffer, $dvr_converter_start_time, $dvr_converter_end_time, $dvr_converter_duration, $dvr_converter_output_filename, $dvr_converter_store_list);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putDvrRESTConverterStoresActionAsync
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $instance_name The application instance name needed for this REST call (required)
     * @param  string $dvr_converter_default_file_destination The file location to use when converting a nDVR store, the default is configured as the StorageDir in the application in use (optional)
     * @param  string $dvr_converter_debug_conversions Indicates if the conversion should have debugging enabled, can be true or false, default is false (optional)
     * @param  string $dvr_converter_continue_on_source_errors Indicates if the conversion should continue even if errors are detected, can be true or false, default is true (optional)
     * @param  string $dvr_converter_audio_video_sync_enable Indicates if the audio/video offset should be detected and conversion only started after the sync in no longer detected or over default allowable time. Can be true or false, default is false (optional)
     * @param  string $dvr_converter_audio_video_max_offset Indicates the maximum audio/video timecodes can be out of sync (optional, default to 200)
     * @param  string $dvr_converter_audio_video_max_buffer Indicates the maximum time a correct audio/video sync will be searched for before giving up (optional, default to 8000)
     * @param  string $dvr_converter_start_time A start time in UTC from where the conversion should start in the store, default is the first entry in the store (optional)
     * @param  string $dvr_converter_end_time A end time in UTC  where the conversion should end in the store, default is to the end of the store (optional)
     * @param  string $dvr_converter_duration A duration for the conversion either added to the start or subtracted from the end time, if you use duration you can not use start and end (optional)
     * @param  string $dvr_converter_output_filename Indicates the output filename if not using the default, which is the name of the store being converted (optional)
     * @param  string $dvr_converter_store_list The comma-separated list of stores to convert (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putDvrRESTConverterStoresActionAsync($server_name, $action, $vhost_name, $app_name, $instance_name, $dvr_converter_default_file_destination = null, $dvr_converter_debug_conversions = null, $dvr_converter_continue_on_source_errors = null, $dvr_converter_audio_video_sync_enable = null, $dvr_converter_audio_video_max_offset = '200', $dvr_converter_audio_video_max_buffer = '8000', $dvr_converter_start_time = null, $dvr_converter_end_time = null, $dvr_converter_duration = null, $dvr_converter_output_filename = null, $dvr_converter_store_list = null)
    {
        return $this->putDvrRESTConverterStoresActionAsyncWithHttpInfo($server_name, $action, $vhost_name, $app_name, $instance_name, $dvr_converter_default_file_destination, $dvr_converter_debug_conversions, $dvr_converter_continue_on_source_errors, $dvr_converter_audio_video_sync_enable, $dvr_converter_audio_video_max_offset, $dvr_converter_audio_video_max_buffer, $dvr_converter_start_time, $dvr_converter_end_time, $dvr_converter_duration, $dvr_converter_output_filename, $dvr_converter_store_list)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putDvrRESTConverterStoresActionAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $instance_name The application instance name needed for this REST call (required)
     * @param  string $dvr_converter_default_file_destination The file location to use when converting a nDVR store, the default is configured as the StorageDir in the application in use (optional)
     * @param  string $dvr_converter_debug_conversions Indicates if the conversion should have debugging enabled, can be true or false, default is false (optional)
     * @param  string $dvr_converter_continue_on_source_errors Indicates if the conversion should continue even if errors are detected, can be true or false, default is true (optional)
     * @param  string $dvr_converter_audio_video_sync_enable Indicates if the audio/video offset should be detected and conversion only started after the sync in no longer detected or over default allowable time. Can be true or false, default is false (optional)
     * @param  string $dvr_converter_audio_video_max_offset Indicates the maximum audio/video timecodes can be out of sync (optional, default to 200)
     * @param  string $dvr_converter_audio_video_max_buffer Indicates the maximum time a correct audio/video sync will be searched for before giving up (optional, default to 8000)
     * @param  string $dvr_converter_start_time A start time in UTC from where the conversion should start in the store, default is the first entry in the store (optional)
     * @param  string $dvr_converter_end_time A end time in UTC  where the conversion should end in the store, default is to the end of the store (optional)
     * @param  string $dvr_converter_duration A duration for the conversion either added to the start or subtracted from the end time, if you use duration you can not use start and end (optional)
     * @param  string $dvr_converter_output_filename Indicates the output filename if not using the default, which is the name of the store being converted (optional)
     * @param  string $dvr_converter_store_list The comma-separated list of stores to convert (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putDvrRESTConverterStoresActionAsyncWithHttpInfo($server_name, $action, $vhost_name, $app_name, $instance_name, $dvr_converter_default_file_destination = null, $dvr_converter_debug_conversions = null, $dvr_converter_continue_on_source_errors = null, $dvr_converter_audio_video_sync_enable = null, $dvr_converter_audio_video_max_offset = '200', $dvr_converter_audio_video_max_buffer = '8000', $dvr_converter_start_time = null, $dvr_converter_end_time = null, $dvr_converter_duration = null, $dvr_converter_output_filename = null, $dvr_converter_store_list = null)
    {
        $returnType = '';
        $request = $this->putDvrRESTConverterStoresActionRequest($server_name, $action, $vhost_name, $app_name, $instance_name, $dvr_converter_default_file_destination, $dvr_converter_debug_conversions, $dvr_converter_continue_on_source_errors, $dvr_converter_audio_video_sync_enable, $dvr_converter_audio_video_max_offset, $dvr_converter_audio_video_max_buffer, $dvr_converter_start_time, $dvr_converter_end_time, $dvr_converter_duration, $dvr_converter_output_filename, $dvr_converter_store_list);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putDvrRESTConverterStoresAction'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $instance_name The application instance name needed for this REST call (required)
     * @param  string $dvr_converter_default_file_destination The file location to use when converting a nDVR store, the default is configured as the StorageDir in the application in use (optional)
     * @param  string $dvr_converter_debug_conversions Indicates if the conversion should have debugging enabled, can be true or false, default is false (optional)
     * @param  string $dvr_converter_continue_on_source_errors Indicates if the conversion should continue even if errors are detected, can be true or false, default is true (optional)
     * @param  string $dvr_converter_audio_video_sync_enable Indicates if the audio/video offset should be detected and conversion only started after the sync in no longer detected or over default allowable time. Can be true or false, default is false (optional)
     * @param  string $dvr_converter_audio_video_max_offset Indicates the maximum audio/video timecodes can be out of sync (optional, default to 200)
     * @param  string $dvr_converter_audio_video_max_buffer Indicates the maximum time a correct audio/video sync will be searched for before giving up (optional, default to 8000)
     * @param  string $dvr_converter_start_time A start time in UTC from where the conversion should start in the store, default is the first entry in the store (optional)
     * @param  string $dvr_converter_end_time A end time in UTC  where the conversion should end in the store, default is to the end of the store (optional)
     * @param  string $dvr_converter_duration A duration for the conversion either added to the start or subtracted from the end time, if you use duration you can not use start and end (optional)
     * @param  string $dvr_converter_output_filename Indicates the output filename if not using the default, which is the name of the store being converted (optional)
     * @param  string $dvr_converter_store_list The comma-separated list of stores to convert (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putDvrRESTConverterStoresActionRequest($server_name, $action, $vhost_name, $app_name, $instance_name, $dvr_converter_default_file_destination = null, $dvr_converter_debug_conversions = null, $dvr_converter_continue_on_source_errors = null, $dvr_converter_audio_video_sync_enable = null, $dvr_converter_audio_video_max_offset = '200', $dvr_converter_audio_video_max_buffer = '8000', $dvr_converter_start_time = null, $dvr_converter_end_time = null, $dvr_converter_duration = null, $dvr_converter_output_filename = null, $dvr_converter_store_list = null)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putDvrRESTConverterStoresAction'
            );
        }
        // verify the required parameter 'action' is set
        if ($action === null || (is_array($action) && count($action) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $action when calling putDvrRESTConverterStoresAction'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putDvrRESTConverterStoresAction'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putDvrRESTConverterStoresAction'
            );
        }
        // verify the required parameter 'instance_name' is set
        if ($instance_name === null || (is_array($instance_name) && count($instance_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_name when calling putDvrRESTConverterStoresAction'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/instances/{instanceName}/dvrstores/actions/{action}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($dvr_converter_default_file_destination !== null) {
            $queryParams['dvrConverterDefaultFileDestination'] = ObjectSerializer::toQueryValue($dvr_converter_default_file_destination);
        }
        // query params
        if ($dvr_converter_debug_conversions !== null) {
            $queryParams['dvrConverterDebugConversions'] = ObjectSerializer::toQueryValue($dvr_converter_debug_conversions);
        }
        // query params
        if ($dvr_converter_continue_on_source_errors !== null) {
            $queryParams['dvrConverterContinueOnSourceErrors'] = ObjectSerializer::toQueryValue($dvr_converter_continue_on_source_errors);
        }
        // query params
        if ($dvr_converter_audio_video_sync_enable !== null) {
            $queryParams['dvrConverterAudioVideoSyncEnable'] = ObjectSerializer::toQueryValue($dvr_converter_audio_video_sync_enable);
        }
        // query params
        if ($dvr_converter_audio_video_max_offset !== null) {
            $queryParams['dvrConverterAudioVideoMaxOffset'] = ObjectSerializer::toQueryValue($dvr_converter_audio_video_max_offset);
        }
        // query params
        if ($dvr_converter_audio_video_max_buffer !== null) {
            $queryParams['dvrConverterAudioVideoMaxBuffer'] = ObjectSerializer::toQueryValue($dvr_converter_audio_video_max_buffer);
        }
        // query params
        if ($dvr_converter_start_time !== null) {
            $queryParams['dvrConverterStartTime'] = ObjectSerializer::toQueryValue($dvr_converter_start_time);
        }
        // query params
        if ($dvr_converter_end_time !== null) {
            $queryParams['dvrConverterEndTime'] = ObjectSerializer::toQueryValue($dvr_converter_end_time);
        }
        // query params
        if ($dvr_converter_duration !== null) {
            $queryParams['dvrConverterDuration'] = ObjectSerializer::toQueryValue($dvr_converter_duration);
        }
        // query params
        if ($dvr_converter_output_filename !== null) {
            $queryParams['dvrConverterOutputFilename'] = ObjectSerializer::toQueryValue($dvr_converter_output_filename);
        }
        // query params
        if ($dvr_converter_store_list !== null) {
            $queryParams['dvrConverterStoreList'] = ObjectSerializer::toQueryValue($dvr_converter_store_list);
        }

        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($action !== null) {
            $resourcePath = str_replace(
                '{' . 'action' . '}',
                ObjectSerializer::toPathValue($action),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($instance_name !== null) {
            $resourcePath = str_replace(
                '{' . 'instanceName' . '}',
                ObjectSerializer::toPathValue($instance_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putIncomingStreamAction
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $instance_name The application instance name needed for this REST call (required)
     * @param  string $stream_name The stream name needed for this REST call (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putIncomingStreamAction($server_name, $action, $vhost_name, $app_name, $instance_name, $stream_name)
    {
        $this->putIncomingStreamActionWithHttpInfo($server_name, $action, $vhost_name, $app_name, $instance_name, $stream_name);
    }

    /**
     * Operation putIncomingStreamActionWithHttpInfo
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $instance_name The application instance name needed for this REST call (required)
     * @param  string $stream_name The stream name needed for this REST call (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putIncomingStreamActionWithHttpInfo($server_name, $action, $vhost_name, $app_name, $instance_name, $stream_name)
    {
        $returnType = '';
        $request = $this->putIncomingStreamActionRequest($server_name, $action, $vhost_name, $app_name, $instance_name, $stream_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putIncomingStreamActionAsync
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $instance_name The application instance name needed for this REST call (required)
     * @param  string $stream_name The stream name needed for this REST call (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putIncomingStreamActionAsync($server_name, $action, $vhost_name, $app_name, $instance_name, $stream_name)
    {
        return $this->putIncomingStreamActionAsyncWithHttpInfo($server_name, $action, $vhost_name, $app_name, $instance_name, $stream_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putIncomingStreamActionAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $instance_name The application instance name needed for this REST call (required)
     * @param  string $stream_name The stream name needed for this REST call (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putIncomingStreamActionAsyncWithHttpInfo($server_name, $action, $vhost_name, $app_name, $instance_name, $stream_name)
    {
        $returnType = '';
        $request = $this->putIncomingStreamActionRequest($server_name, $action, $vhost_name, $app_name, $instance_name, $stream_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putIncomingStreamAction'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $instance_name The application instance name needed for this REST call (required)
     * @param  string $stream_name The stream name needed for this REST call (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putIncomingStreamActionRequest($server_name, $action, $vhost_name, $app_name, $instance_name, $stream_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putIncomingStreamAction'
            );
        }
        // verify the required parameter 'action' is set
        if ($action === null || (is_array($action) && count($action) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $action when calling putIncomingStreamAction'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putIncomingStreamAction'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putIncomingStreamAction'
            );
        }
        // verify the required parameter 'instance_name' is set
        if ($instance_name === null || (is_array($instance_name) && count($instance_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_name when calling putIncomingStreamAction'
            );
        }
        // verify the required parameter 'stream_name' is set
        if ($stream_name === null || (is_array($stream_name) && count($stream_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stream_name when calling putIncomingStreamAction'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/instances/{instanceName}/incomingstreams/{streamName}/actions/{action}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($action !== null) {
            $resourcePath = str_replace(
                '{' . 'action' . '}',
                ObjectSerializer::toPathValue($action),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($instance_name !== null) {
            $resourcePath = str_replace(
                '{' . 'instanceName' . '}',
                ObjectSerializer::toPathValue($instance_name),
                $resourcePath
            );
        }
        // path params
        if ($stream_name !== null) {
            $resourcePath = str_replace(
                '{' . 'streamName' . '}',
                ObjectSerializer::toPathValue($stream_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putInstanceAction
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $instance_name The application instance name needed for this REST call (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putInstanceAction($server_name, $action, $vhost_name, $app_name, $instance_name)
    {
        $this->putInstanceActionWithHttpInfo($server_name, $action, $vhost_name, $app_name, $instance_name);
    }

    /**
     * Operation putInstanceActionWithHttpInfo
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $instance_name The application instance name needed for this REST call (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putInstanceActionWithHttpInfo($server_name, $action, $vhost_name, $app_name, $instance_name)
    {
        $returnType = '';
        $request = $this->putInstanceActionRequest($server_name, $action, $vhost_name, $app_name, $instance_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putInstanceActionAsync
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $instance_name The application instance name needed for this REST call (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putInstanceActionAsync($server_name, $action, $vhost_name, $app_name, $instance_name)
    {
        return $this->putInstanceActionAsyncWithHttpInfo($server_name, $action, $vhost_name, $app_name, $instance_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putInstanceActionAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $instance_name The application instance name needed for this REST call (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putInstanceActionAsyncWithHttpInfo($server_name, $action, $vhost_name, $app_name, $instance_name)
    {
        $returnType = '';
        $request = $this->putInstanceActionRequest($server_name, $action, $vhost_name, $app_name, $instance_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putInstanceAction'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $instance_name The application instance name needed for this REST call (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putInstanceActionRequest($server_name, $action, $vhost_name, $app_name, $instance_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putInstanceAction'
            );
        }
        // verify the required parameter 'action' is set
        if ($action === null || (is_array($action) && count($action) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $action when calling putInstanceAction'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putInstanceAction'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putInstanceAction'
            );
        }
        // verify the required parameter 'instance_name' is set
        if ($instance_name === null || (is_array($instance_name) && count($instance_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_name when calling putInstanceAction'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/instances/{instanceName}/actions/{action}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($action !== null) {
            $resourcePath = str_replace(
                '{' . 'action' . '}',
                ObjectSerializer::toPathValue($action),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($instance_name !== null) {
            $resourcePath = str_replace(
                '{' . 'instanceName' . '}',
                ObjectSerializer::toPathValue($instance_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putMediaCacheApplicationStoreAction
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $instance_name The application instance name needed for this REST call (required)
     * @param  string $filename The file or stream name item to be used in all rest action requests (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putMediaCacheApplicationStoreAction($server_name, $action, $vhost_name, $app_name, $instance_name, $filename = null)
    {
        $this->putMediaCacheApplicationStoreActionWithHttpInfo($server_name, $action, $vhost_name, $app_name, $instance_name, $filename);
    }

    /**
     * Operation putMediaCacheApplicationStoreActionWithHttpInfo
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $instance_name The application instance name needed for this REST call (required)
     * @param  string $filename The file or stream name item to be used in all rest action requests (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putMediaCacheApplicationStoreActionWithHttpInfo($server_name, $action, $vhost_name, $app_name, $instance_name, $filename = null)
    {
        $returnType = '';
        $request = $this->putMediaCacheApplicationStoreActionRequest($server_name, $action, $vhost_name, $app_name, $instance_name, $filename);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putMediaCacheApplicationStoreActionAsync
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $instance_name The application instance name needed for this REST call (required)
     * @param  string $filename The file or stream name item to be used in all rest action requests (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putMediaCacheApplicationStoreActionAsync($server_name, $action, $vhost_name, $app_name, $instance_name, $filename = null)
    {
        return $this->putMediaCacheApplicationStoreActionAsyncWithHttpInfo($server_name, $action, $vhost_name, $app_name, $instance_name, $filename)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putMediaCacheApplicationStoreActionAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $instance_name The application instance name needed for this REST call (required)
     * @param  string $filename The file or stream name item to be used in all rest action requests (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putMediaCacheApplicationStoreActionAsyncWithHttpInfo($server_name, $action, $vhost_name, $app_name, $instance_name, $filename = null)
    {
        $returnType = '';
        $request = $this->putMediaCacheApplicationStoreActionRequest($server_name, $action, $vhost_name, $app_name, $instance_name, $filename);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putMediaCacheApplicationStoreAction'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $instance_name The application instance name needed for this REST call (required)
     * @param  string $filename The file or stream name item to be used in all rest action requests (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putMediaCacheApplicationStoreActionRequest($server_name, $action, $vhost_name, $app_name, $instance_name, $filename = null)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putMediaCacheApplicationStoreAction'
            );
        }
        // verify the required parameter 'action' is set
        if ($action === null || (is_array($action) && count($action) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $action when calling putMediaCacheApplicationStoreAction'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putMediaCacheApplicationStoreAction'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putMediaCacheApplicationStoreAction'
            );
        }
        // verify the required parameter 'instance_name' is set
        if ($instance_name === null || (is_array($instance_name) && count($instance_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_name when calling putMediaCacheApplicationStoreAction'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/instances/{instanceName}/mediacache/stores/actions/{action}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($filename !== null) {
            $queryParams['filename'] = ObjectSerializer::toQueryValue($filename);
        }

        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($action !== null) {
            $resourcePath = str_replace(
                '{' . 'action' . '}',
                ObjectSerializer::toPathValue($action),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($instance_name !== null) {
            $resourcePath = str_replace(
                '{' . 'instanceName' . '}',
                ObjectSerializer::toPathValue($instance_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putModulesConfig
     *
     * Updates the list of Modules for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\ModulesConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putModulesConfig($server_name, $vhost_name, $app_name, $body)
    {
        $this->putModulesConfigWithHttpInfo($server_name, $vhost_name, $app_name, $body);
    }

    /**
     * Operation putModulesConfigWithHttpInfo
     *
     * Updates the list of Modules for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\ModulesConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putModulesConfigWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putModulesConfigRequest($server_name, $vhost_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putModulesConfigAsync
     *
     * Updates the list of Modules for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\ModulesConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putModulesConfigAsync($server_name, $vhost_name, $app_name, $body)
    {
        return $this->putModulesConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putModulesConfigAsyncWithHttpInfo
     *
     * Updates the list of Modules for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\ModulesConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putModulesConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putModulesConfigRequest($server_name, $vhost_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putModulesConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\ModulesConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putModulesConfigRequest($server_name, $vhost_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putModulesConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putModulesConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putModulesConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putModulesConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/modules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPublisherAppConfig
     *
     * Updates the specified Publisher configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\PublisherAppConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putPublisherAppConfig($server_name, $vhost_name, $publisher_name, $app_name, $body)
    {
        $this->putPublisherAppConfigWithHttpInfo($server_name, $vhost_name, $publisher_name, $app_name, $body);
    }

    /**
     * Operation putPublisherAppConfigWithHttpInfo
     *
     * Updates the specified Publisher configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\PublisherAppConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPublisherAppConfigWithHttpInfo($server_name, $vhost_name, $publisher_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putPublisherAppConfigRequest($server_name, $vhost_name, $publisher_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putPublisherAppConfigAsync
     *
     * Updates the specified Publisher configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\PublisherAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPublisherAppConfigAsync($server_name, $vhost_name, $publisher_name, $app_name, $body)
    {
        return $this->putPublisherAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $publisher_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPublisherAppConfigAsyncWithHttpInfo
     *
     * Updates the specified Publisher configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\PublisherAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPublisherAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $publisher_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putPublisherAppConfigRequest($server_name, $vhost_name, $publisher_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPublisherAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name The vhost name (required)
     * @param  string $publisher_name The publisher name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\PublisherAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPublisherAppConfigRequest($server_name, $vhost_name, $publisher_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putPublisherAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putPublisherAppConfig'
            );
        }
        // verify the required parameter 'publisher_name' is set
        if ($publisher_name === null || (is_array($publisher_name) && count($publisher_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $publisher_name when calling putPublisherAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putPublisherAppConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putPublisherAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/publishers/{publisherName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($publisher_name !== null) {
            $resourcePath = str_replace(
                '{' . 'publisherName' . '}',
                ObjectSerializer::toPathValue($publisher_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPushPublishStreamAppAction
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $entry_name The map entry name needed for this REST call (required)
     * @param  string $dst_entry_name The destination entryName when copying (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putPushPublishStreamAppAction($server_name, $action, $vhost_name, $app_name, $entry_name, $dst_entry_name = null)
    {
        $this->putPushPublishStreamAppActionWithHttpInfo($server_name, $action, $vhost_name, $app_name, $entry_name, $dst_entry_name);
    }

    /**
     * Operation putPushPublishStreamAppActionWithHttpInfo
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $entry_name The map entry name needed for this REST call (required)
     * @param  string $dst_entry_name The destination entryName when copying (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPushPublishStreamAppActionWithHttpInfo($server_name, $action, $vhost_name, $app_name, $entry_name, $dst_entry_name = null)
    {
        $returnType = '';
        $request = $this->putPushPublishStreamAppActionRequest($server_name, $action, $vhost_name, $app_name, $entry_name, $dst_entry_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putPushPublishStreamAppActionAsync
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $entry_name The map entry name needed for this REST call (required)
     * @param  string $dst_entry_name The destination entryName when copying (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPushPublishStreamAppActionAsync($server_name, $action, $vhost_name, $app_name, $entry_name, $dst_entry_name = null)
    {
        return $this->putPushPublishStreamAppActionAsyncWithHttpInfo($server_name, $action, $vhost_name, $app_name, $entry_name, $dst_entry_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPushPublishStreamAppActionAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $entry_name The map entry name needed for this REST call (required)
     * @param  string $dst_entry_name The destination entryName when copying (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPushPublishStreamAppActionAsyncWithHttpInfo($server_name, $action, $vhost_name, $app_name, $entry_name, $dst_entry_name = null)
    {
        $returnType = '';
        $request = $this->putPushPublishStreamAppActionRequest($server_name, $action, $vhost_name, $app_name, $entry_name, $dst_entry_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPushPublishStreamAppAction'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $entry_name The map entry name needed for this REST call (required)
     * @param  string $dst_entry_name The destination entryName when copying (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPushPublishStreamAppActionRequest($server_name, $action, $vhost_name, $app_name, $entry_name, $dst_entry_name = null)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putPushPublishStreamAppAction'
            );
        }
        // verify the required parameter 'action' is set
        if ($action === null || (is_array($action) && count($action) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $action when calling putPushPublishStreamAppAction'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putPushPublishStreamAppAction'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putPushPublishStreamAppAction'
            );
        }
        // verify the required parameter 'entry_name' is set
        if ($entry_name === null || (is_array($entry_name) && count($entry_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entry_name when calling putPushPublishStreamAppAction'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/pushpublish/mapentries/{entryName}/actions/{action}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($dst_entry_name !== null) {
            $queryParams['dstEntryName'] = ObjectSerializer::toQueryValue($dst_entry_name);
        }

        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($action !== null) {
            $resourcePath = str_replace(
                '{' . 'action' . '}',
                ObjectSerializer::toPathValue($action),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($entry_name !== null) {
            $resourcePath = str_replace(
                '{' . 'entryName' . '}',
                ObjectSerializer::toPathValue($entry_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPushPublishStreamAppConfig
     *
     * Updates the specified PushPublish map entry's configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  string $entry_name The entry name needed for this REST call (required)
     * @param  \Swagger\Client\Model\PushPublishStreamAppConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putPushPublishStreamAppConfig($server_name, $vhost_name, $app_name, $entry_name, $body)
    {
        $this->putPushPublishStreamAppConfigWithHttpInfo($server_name, $vhost_name, $app_name, $entry_name, $body);
    }

    /**
     * Operation putPushPublishStreamAppConfigWithHttpInfo
     *
     * Updates the specified PushPublish map entry's configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $entry_name The entry name needed for this REST call (required)
     * @param  \Swagger\Client\Model\PushPublishStreamAppConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPushPublishStreamAppConfigWithHttpInfo($server_name, $vhost_name, $app_name, $entry_name, $body)
    {
        $returnType = '';
        $request = $this->putPushPublishStreamAppConfigRequest($server_name, $vhost_name, $app_name, $entry_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putPushPublishStreamAppConfigAsync
     *
     * Updates the specified PushPublish map entry's configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $entry_name The entry name needed for this REST call (required)
     * @param  \Swagger\Client\Model\PushPublishStreamAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPushPublishStreamAppConfigAsync($server_name, $vhost_name, $app_name, $entry_name, $body)
    {
        return $this->putPushPublishStreamAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $entry_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPushPublishStreamAppConfigAsyncWithHttpInfo
     *
     * Updates the specified PushPublish map entry's configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $entry_name The entry name needed for this REST call (required)
     * @param  \Swagger\Client\Model\PushPublishStreamAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPushPublishStreamAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $entry_name, $body)
    {
        $returnType = '';
        $request = $this->putPushPublishStreamAppConfigRequest($server_name, $vhost_name, $app_name, $entry_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPushPublishStreamAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  string $entry_name The entry name needed for this REST call (required)
     * @param  \Swagger\Client\Model\PushPublishStreamAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPushPublishStreamAppConfigRequest($server_name, $vhost_name, $app_name, $entry_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putPushPublishStreamAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putPushPublishStreamAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putPushPublishStreamAppConfig'
            );
        }
        // verify the required parameter 'entry_name' is set
        if ($entry_name === null || (is_array($entry_name) && count($entry_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entry_name when calling putPushPublishStreamAppConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putPushPublishStreamAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/pushpublish/mapentries/{entryName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($entry_name !== null) {
            $resourcePath = str_replace(
                '{' . 'entryName' . '}',
                ObjectSerializer::toPathValue($entry_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPushPublishStreamsAppConfig
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\PushPublishStreamAppConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putPushPublishStreamsAppConfig($server_name, $vhost_name, $app_name, $body)
    {
        $this->putPushPublishStreamsAppConfigWithHttpInfo($server_name, $vhost_name, $app_name, $body);
    }

    /**
     * Operation putPushPublishStreamsAppConfigWithHttpInfo
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\PushPublishStreamAppConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPushPublishStreamsAppConfigWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putPushPublishStreamsAppConfigRequest($server_name, $vhost_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putPushPublishStreamsAppConfigAsync
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\PushPublishStreamAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPushPublishStreamsAppConfigAsync($server_name, $vhost_name, $app_name, $body)
    {
        return $this->putPushPublishStreamsAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPushPublishStreamsAppConfigAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\PushPublishStreamAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPushPublishStreamsAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putPushPublishStreamsAppConfigRequest($server_name, $vhost_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPushPublishStreamsAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\PushPublishStreamAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPushPublishStreamsAppConfigRequest($server_name, $vhost_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putPushPublishStreamsAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putPushPublishStreamsAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putPushPublishStreamsAppConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putPushPublishStreamsAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/pushpublish/mapentries';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSDPFileAppAction
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $media_caster_type The MediaCasterType to use for the connection (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $sdpfile_name The sdp file name needed for this REST call (required)
     * @param  string $connect_app_name The name of the application to connect to (optional)
     * @param  string $app_nstance The name of the application instance to connect to (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putSDPFileAppAction($server_name, $action, $media_caster_type, $vhost_name, $app_name, $sdpfile_name, $connect_app_name = null, $app_nstance = null)
    {
        $this->putSDPFileAppActionWithHttpInfo($server_name, $action, $media_caster_type, $vhost_name, $app_name, $sdpfile_name, $connect_app_name, $app_nstance);
    }

    /**
     * Operation putSDPFileAppActionWithHttpInfo
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $media_caster_type The MediaCasterType to use for the connection (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $sdpfile_name The sdp file name needed for this REST call (required)
     * @param  string $connect_app_name The name of the application to connect to (optional)
     * @param  string $app_nstance The name of the application instance to connect to (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSDPFileAppActionWithHttpInfo($server_name, $action, $media_caster_type, $vhost_name, $app_name, $sdpfile_name, $connect_app_name = null, $app_nstance = null)
    {
        $returnType = '';
        $request = $this->putSDPFileAppActionRequest($server_name, $action, $media_caster_type, $vhost_name, $app_name, $sdpfile_name, $connect_app_name, $app_nstance);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putSDPFileAppActionAsync
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $media_caster_type The MediaCasterType to use for the connection (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $sdpfile_name The sdp file name needed for this REST call (required)
     * @param  string $connect_app_name The name of the application to connect to (optional)
     * @param  string $app_nstance The name of the application instance to connect to (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSDPFileAppActionAsync($server_name, $action, $media_caster_type, $vhost_name, $app_name, $sdpfile_name, $connect_app_name = null, $app_nstance = null)
    {
        return $this->putSDPFileAppActionAsyncWithHttpInfo($server_name, $action, $media_caster_type, $vhost_name, $app_name, $sdpfile_name, $connect_app_name, $app_nstance)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSDPFileAppActionAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $media_caster_type The MediaCasterType to use for the connection (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $sdpfile_name The sdp file name needed for this REST call (required)
     * @param  string $connect_app_name The name of the application to connect to (optional)
     * @param  string $app_nstance The name of the application instance to connect to (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSDPFileAppActionAsyncWithHttpInfo($server_name, $action, $media_caster_type, $vhost_name, $app_name, $sdpfile_name, $connect_app_name = null, $app_nstance = null)
    {
        $returnType = '';
        $request = $this->putSDPFileAppActionRequest($server_name, $action, $media_caster_type, $vhost_name, $app_name, $sdpfile_name, $connect_app_name, $app_nstance);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSDPFileAppAction'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $media_caster_type The MediaCasterType to use for the connection (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $sdpfile_name The sdp file name needed for this REST call (required)
     * @param  string $connect_app_name The name of the application to connect to (optional)
     * @param  string $app_nstance The name of the application instance to connect to (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putSDPFileAppActionRequest($server_name, $action, $media_caster_type, $vhost_name, $app_name, $sdpfile_name, $connect_app_name = null, $app_nstance = null)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putSDPFileAppAction'
            );
        }
        // verify the required parameter 'action' is set
        if ($action === null || (is_array($action) && count($action) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $action when calling putSDPFileAppAction'
            );
        }
        // verify the required parameter 'media_caster_type' is set
        if ($media_caster_type === null || (is_array($media_caster_type) && count($media_caster_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $media_caster_type when calling putSDPFileAppAction'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putSDPFileAppAction'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putSDPFileAppAction'
            );
        }
        // verify the required parameter 'sdpfile_name' is set
        if ($sdpfile_name === null || (is_array($sdpfile_name) && count($sdpfile_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sdpfile_name when calling putSDPFileAppAction'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/sdpfiles/{sdpfileName}/actions/{action}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($connect_app_name !== null) {
            $queryParams['connectAppName'] = ObjectSerializer::toQueryValue($connect_app_name);
        }
        // query params
        if ($app_nstance !== null) {
            $queryParams['appInstance'] = ObjectSerializer::toQueryValue($app_nstance);
        }
        // query params
        if ($media_caster_type !== null) {
            $queryParams['mediaCasterType'] = ObjectSerializer::toQueryValue($media_caster_type);
        }

        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($action !== null) {
            $resourcePath = str_replace(
                '{' . 'action' . '}',
                ObjectSerializer::toPathValue($action),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($sdpfile_name !== null) {
            $resourcePath = str_replace(
                '{' . 'sdpfileName' . '}',
                ObjectSerializer::toPathValue($sdpfile_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSMILFileAppAction
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $media_caster_type The MediaCasterType to use for the connection (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $smilfile_name The SMIL file name needed for this REST call (required)
     * @param  string $connect_app_name The name of the application to connect to (optional)
     * @param  string $app_nstance The name of the application instance to connect to (optional)
     * @param  string $dst_entry_name The destination SMIL file name when copying (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putSMILFileAppAction($server_name, $action, $media_caster_type, $vhost_name, $app_name, $smilfile_name, $connect_app_name = null, $app_nstance = null, $dst_entry_name = null)
    {
        $this->putSMILFileAppActionWithHttpInfo($server_name, $action, $media_caster_type, $vhost_name, $app_name, $smilfile_name, $connect_app_name, $app_nstance, $dst_entry_name);
    }

    /**
     * Operation putSMILFileAppActionWithHttpInfo
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $media_caster_type The MediaCasterType to use for the connection (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $smilfile_name The SMIL file name needed for this REST call (required)
     * @param  string $connect_app_name The name of the application to connect to (optional)
     * @param  string $app_nstance The name of the application instance to connect to (optional)
     * @param  string $dst_entry_name The destination SMIL file name when copying (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSMILFileAppActionWithHttpInfo($server_name, $action, $media_caster_type, $vhost_name, $app_name, $smilfile_name, $connect_app_name = null, $app_nstance = null, $dst_entry_name = null)
    {
        $returnType = '';
        $request = $this->putSMILFileAppActionRequest($server_name, $action, $media_caster_type, $vhost_name, $app_name, $smilfile_name, $connect_app_name, $app_nstance, $dst_entry_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putSMILFileAppActionAsync
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $media_caster_type The MediaCasterType to use for the connection (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $smilfile_name The SMIL file name needed for this REST call (required)
     * @param  string $connect_app_name The name of the application to connect to (optional)
     * @param  string $app_nstance The name of the application instance to connect to (optional)
     * @param  string $dst_entry_name The destination SMIL file name when copying (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSMILFileAppActionAsync($server_name, $action, $media_caster_type, $vhost_name, $app_name, $smilfile_name, $connect_app_name = null, $app_nstance = null, $dst_entry_name = null)
    {
        return $this->putSMILFileAppActionAsyncWithHttpInfo($server_name, $action, $media_caster_type, $vhost_name, $app_name, $smilfile_name, $connect_app_name, $app_nstance, $dst_entry_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSMILFileAppActionAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $media_caster_type The MediaCasterType to use for the connection (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $smilfile_name The SMIL file name needed for this REST call (required)
     * @param  string $connect_app_name The name of the application to connect to (optional)
     * @param  string $app_nstance The name of the application instance to connect to (optional)
     * @param  string $dst_entry_name The destination SMIL file name when copying (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSMILFileAppActionAsyncWithHttpInfo($server_name, $action, $media_caster_type, $vhost_name, $app_name, $smilfile_name, $connect_app_name = null, $app_nstance = null, $dst_entry_name = null)
    {
        $returnType = '';
        $request = $this->putSMILFileAppActionRequest($server_name, $action, $media_caster_type, $vhost_name, $app_name, $smilfile_name, $connect_app_name, $app_nstance, $dst_entry_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSMILFileAppAction'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $media_caster_type The MediaCasterType to use for the connection (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $smilfile_name The SMIL file name needed for this REST call (required)
     * @param  string $connect_app_name The name of the application to connect to (optional)
     * @param  string $app_nstance The name of the application instance to connect to (optional)
     * @param  string $dst_entry_name The destination SMIL file name when copying (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putSMILFileAppActionRequest($server_name, $action, $media_caster_type, $vhost_name, $app_name, $smilfile_name, $connect_app_name = null, $app_nstance = null, $dst_entry_name = null)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putSMILFileAppAction'
            );
        }
        // verify the required parameter 'action' is set
        if ($action === null || (is_array($action) && count($action) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $action when calling putSMILFileAppAction'
            );
        }
        // verify the required parameter 'media_caster_type' is set
        if ($media_caster_type === null || (is_array($media_caster_type) && count($media_caster_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $media_caster_type when calling putSMILFileAppAction'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putSMILFileAppAction'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putSMILFileAppAction'
            );
        }
        // verify the required parameter 'smilfile_name' is set
        if ($smilfile_name === null || (is_array($smilfile_name) && count($smilfile_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $smilfile_name when calling putSMILFileAppAction'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/smilfiles/{smilfileName}/actions/{action}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($connect_app_name !== null) {
            $queryParams['connectAppName'] = ObjectSerializer::toQueryValue($connect_app_name);
        }
        // query params
        if ($app_nstance !== null) {
            $queryParams['appInstance'] = ObjectSerializer::toQueryValue($app_nstance);
        }
        // query params
        if ($media_caster_type !== null) {
            $queryParams['mediaCasterType'] = ObjectSerializer::toQueryValue($media_caster_type);
        }
        // query params
        if ($dst_entry_name !== null) {
            $queryParams['dstEntryName'] = ObjectSerializer::toQueryValue($dst_entry_name);
        }

        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($action !== null) {
            $resourcePath = str_replace(
                '{' . 'action' . '}',
                ObjectSerializer::toPathValue($action),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($smilfile_name !== null) {
            $resourcePath = str_replace(
                '{' . 'smilfileName' . '}',
                ObjectSerializer::toPathValue($smilfile_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSMILFileAppConfig
     *
     * Updates the specified SMIL File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\SMILFileAppConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putSMILFileAppConfig($server_name, $vhost_name, $smilfile_name, $app_name, $body)
    {
        $this->putSMILFileAppConfigWithHttpInfo($server_name, $vhost_name, $smilfile_name, $app_name, $body);
    }

    /**
     * Operation putSMILFileAppConfigWithHttpInfo
     *
     * Updates the specified SMIL File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\SMILFileAppConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSMILFileAppConfigWithHttpInfo($server_name, $vhost_name, $smilfile_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putSMILFileAppConfigRequest($server_name, $vhost_name, $smilfile_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putSMILFileAppConfigAsync
     *
     * Updates the specified SMIL File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\SMILFileAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSMILFileAppConfigAsync($server_name, $vhost_name, $smilfile_name, $app_name, $body)
    {
        return $this->putSMILFileAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $smilfile_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSMILFileAppConfigAsyncWithHttpInfo
     *
     * Updates the specified SMIL File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\SMILFileAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSMILFileAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $smilfile_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putSMILFileAppConfigRequest($server_name, $vhost_name, $smilfile_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSMILFileAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $smilfile_name The SMIL file name without the extension (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\SMILFileAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putSMILFileAppConfigRequest($server_name, $vhost_name, $smilfile_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putSMILFileAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putSMILFileAppConfig'
            );
        }
        // verify the required parameter 'smilfile_name' is set
        if ($smilfile_name === null || (is_array($smilfile_name) && count($smilfile_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $smilfile_name when calling putSMILFileAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putSMILFileAppConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putSMILFileAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/smilfiles/{smilfileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($smilfile_name !== null) {
            $resourcePath = str_replace(
                '{' . 'smilfileName' . '}',
                ObjectSerializer::toPathValue($smilfile_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSecurityConfig
     *
     * Updates the Security configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\SecurityConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putSecurityConfig($server_name, $vhost_name, $app_name, $body)
    {
        $this->putSecurityConfigWithHttpInfo($server_name, $vhost_name, $app_name, $body);
    }

    /**
     * Operation putSecurityConfigWithHttpInfo
     *
     * Updates the Security configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\SecurityConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSecurityConfigWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putSecurityConfigRequest($server_name, $vhost_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putSecurityConfigAsync
     *
     * Updates the Security configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\SecurityConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSecurityConfigAsync($server_name, $vhost_name, $app_name, $body)
    {
        return $this->putSecurityConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSecurityConfigAsyncWithHttpInfo
     *
     * Updates the Security configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\SecurityConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSecurityConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putSecurityConfigRequest($server_name, $vhost_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSecurityConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\SecurityConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putSecurityConfigRequest($server_name, $vhost_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putSecurityConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putSecurityConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putSecurityConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putSecurityConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/security';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSourceControlAction
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The VHost name (required)
     * @param  string $app_name The Application name (required)
     * @param  string $instance_name The Application Instance name (required)
     * @param  string $stream_name The Stream name (required)
     * @param  string $direction No query params available for captureImage. Optional query params for zoom and panTilt:   ZoomIn, ZoomOut,   PanTiltUp, PanTiltRight, PanTiltDown, PanTiltLeft, PanTiltHome, PanTiltUpRight, PanTiltDownRight, PanTiltDownLeft, PanTiltUpLeft (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putSourceControlAction($server_name, $action, $vhost_name, $app_name, $instance_name, $stream_name, $direction = null)
    {
        $this->putSourceControlActionWithHttpInfo($server_name, $action, $vhost_name, $app_name, $instance_name, $stream_name, $direction);
    }

    /**
     * Operation putSourceControlActionWithHttpInfo
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The VHost name (required)
     * @param  string $app_name The Application name (required)
     * @param  string $instance_name The Application Instance name (required)
     * @param  string $stream_name The Stream name (required)
     * @param  string $direction No query params available for captureImage. Optional query params for zoom and panTilt:   ZoomIn, ZoomOut,   PanTiltUp, PanTiltRight, PanTiltDown, PanTiltLeft, PanTiltHome, PanTiltUpRight, PanTiltDownRight, PanTiltDownLeft, PanTiltUpLeft (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSourceControlActionWithHttpInfo($server_name, $action, $vhost_name, $app_name, $instance_name, $stream_name, $direction = null)
    {
        $returnType = '';
        $request = $this->putSourceControlActionRequest($server_name, $action, $vhost_name, $app_name, $instance_name, $stream_name, $direction);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putSourceControlActionAsync
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The VHost name (required)
     * @param  string $app_name The Application name (required)
     * @param  string $instance_name The Application Instance name (required)
     * @param  string $stream_name The Stream name (required)
     * @param  string $direction No query params available for captureImage. Optional query params for zoom and panTilt:   ZoomIn, ZoomOut,   PanTiltUp, PanTiltRight, PanTiltDown, PanTiltLeft, PanTiltHome, PanTiltUpRight, PanTiltDownRight, PanTiltDownLeft, PanTiltUpLeft (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSourceControlActionAsync($server_name, $action, $vhost_name, $app_name, $instance_name, $stream_name, $direction = null)
    {
        return $this->putSourceControlActionAsyncWithHttpInfo($server_name, $action, $vhost_name, $app_name, $instance_name, $stream_name, $direction)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSourceControlActionAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The VHost name (required)
     * @param  string $app_name The Application name (required)
     * @param  string $instance_name The Application Instance name (required)
     * @param  string $stream_name The Stream name (required)
     * @param  string $direction No query params available for captureImage. Optional query params for zoom and panTilt:   ZoomIn, ZoomOut,   PanTiltUp, PanTiltRight, PanTiltDown, PanTiltLeft, PanTiltHome, PanTiltUpRight, PanTiltDownRight, PanTiltDownLeft, PanTiltUpLeft (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSourceControlActionAsyncWithHttpInfo($server_name, $action, $vhost_name, $app_name, $instance_name, $stream_name, $direction = null)
    {
        $returnType = '';
        $request = $this->putSourceControlActionRequest($server_name, $action, $vhost_name, $app_name, $instance_name, $stream_name, $direction);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSourceControlAction'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The VHost name (required)
     * @param  string $app_name The Application name (required)
     * @param  string $instance_name The Application Instance name (required)
     * @param  string $stream_name The Stream name (required)
     * @param  string $direction No query params available for captureImage. Optional query params for zoom and panTilt:   ZoomIn, ZoomOut,   PanTiltUp, PanTiltRight, PanTiltDown, PanTiltLeft, PanTiltHome, PanTiltUpRight, PanTiltDownRight, PanTiltDownLeft, PanTiltUpLeft (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putSourceControlActionRequest($server_name, $action, $vhost_name, $app_name, $instance_name, $stream_name, $direction = null)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putSourceControlAction'
            );
        }
        // verify the required parameter 'action' is set
        if ($action === null || (is_array($action) && count($action) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $action when calling putSourceControlAction'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putSourceControlAction'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putSourceControlAction'
            );
        }
        // verify the required parameter 'instance_name' is set
        if ($instance_name === null || (is_array($instance_name) && count($instance_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_name when calling putSourceControlAction'
            );
        }
        // verify the required parameter 'stream_name' is set
        if ($stream_name === null || (is_array($stream_name) && count($stream_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stream_name when calling putSourceControlAction'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/instances/{instanceName}/incomingstreams/{streamName}/sourcecontrol/actions/{action}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($direction !== null) {
            $queryParams['direction'] = ObjectSerializer::toQueryValue($direction);
        }

        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($action !== null) {
            $resourcePath = str_replace(
                '{' . 'action' . '}',
                ObjectSerializer::toPathValue($action),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($instance_name !== null) {
            $resourcePath = str_replace(
                '{' . 'instanceName' . '}',
                ObjectSerializer::toPathValue($instance_name),
                $resourcePath
            );
        }
        // path params
        if ($stream_name !== null) {
            $resourcePath = str_replace(
                '{' . 'streamName' . '}',
                ObjectSerializer::toPathValue($stream_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putStreamConfigurationConfig
     *
     * Updates the Stream configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\StreamConfigurationConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putStreamConfigurationConfig($server_name, $vhost_name, $app_name, $body)
    {
        $this->putStreamConfigurationConfigWithHttpInfo($server_name, $vhost_name, $app_name, $body);
    }

    /**
     * Operation putStreamConfigurationConfigWithHttpInfo
     *
     * Updates the Stream configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\StreamConfigurationConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putStreamConfigurationConfigWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putStreamConfigurationConfigRequest($server_name, $vhost_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putStreamConfigurationConfigAsync
     *
     * Updates the Stream configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\StreamConfigurationConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putStreamConfigurationConfigAsync($server_name, $vhost_name, $app_name, $body)
    {
        return $this->putStreamConfigurationConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putStreamConfigurationConfigAsyncWithHttpInfo
     *
     * Updates the Stream configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\StreamConfigurationConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putStreamConfigurationConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putStreamConfigurationConfigRequest($server_name, $vhost_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putStreamConfigurationConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\StreamConfigurationConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putStreamConfigurationConfigRequest($server_name, $vhost_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putStreamConfigurationConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putStreamConfigurationConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putStreamConfigurationConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putStreamConfigurationConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/streamconfiguration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putStreamFileAppAction
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $media_caster_type The MediaCasterType to use for the connection (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $streamfile_name The stream file, file name needed for this REST call (required)
     * @param  string $connect_app_name The name of the application to connect to (optional)
     * @param  string $app_nstance The name of the application instance to connect to (optional)
     * @param  string $dst_entry_name The destination stream file name when copying (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putStreamFileAppAction($server_name, $action, $media_caster_type, $vhost_name, $app_name, $streamfile_name, $connect_app_name = null, $app_nstance = null, $dst_entry_name = null)
    {
        $this->putStreamFileAppActionWithHttpInfo($server_name, $action, $media_caster_type, $vhost_name, $app_name, $streamfile_name, $connect_app_name, $app_nstance, $dst_entry_name);
    }

    /**
     * Operation putStreamFileAppActionWithHttpInfo
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $media_caster_type The MediaCasterType to use for the connection (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $streamfile_name The stream file, file name needed for this REST call (required)
     * @param  string $connect_app_name The name of the application to connect to (optional)
     * @param  string $app_nstance The name of the application instance to connect to (optional)
     * @param  string $dst_entry_name The destination stream file name when copying (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putStreamFileAppActionWithHttpInfo($server_name, $action, $media_caster_type, $vhost_name, $app_name, $streamfile_name, $connect_app_name = null, $app_nstance = null, $dst_entry_name = null)
    {
        $returnType = '';
        $request = $this->putStreamFileAppActionRequest($server_name, $action, $media_caster_type, $vhost_name, $app_name, $streamfile_name, $connect_app_name, $app_nstance, $dst_entry_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putStreamFileAppActionAsync
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $media_caster_type The MediaCasterType to use for the connection (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $streamfile_name The stream file, file name needed for this REST call (required)
     * @param  string $connect_app_name The name of the application to connect to (optional)
     * @param  string $app_nstance The name of the application instance to connect to (optional)
     * @param  string $dst_entry_name The destination stream file name when copying (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putStreamFileAppActionAsync($server_name, $action, $media_caster_type, $vhost_name, $app_name, $streamfile_name, $connect_app_name = null, $app_nstance = null, $dst_entry_name = null)
    {
        return $this->putStreamFileAppActionAsyncWithHttpInfo($server_name, $action, $media_caster_type, $vhost_name, $app_name, $streamfile_name, $connect_app_name, $app_nstance, $dst_entry_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putStreamFileAppActionAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $media_caster_type The MediaCasterType to use for the connection (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $streamfile_name The stream file, file name needed for this REST call (required)
     * @param  string $connect_app_name The name of the application to connect to (optional)
     * @param  string $app_nstance The name of the application instance to connect to (optional)
     * @param  string $dst_entry_name The destination stream file name when copying (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putStreamFileAppActionAsyncWithHttpInfo($server_name, $action, $media_caster_type, $vhost_name, $app_name, $streamfile_name, $connect_app_name = null, $app_nstance = null, $dst_entry_name = null)
    {
        $returnType = '';
        $request = $this->putStreamFileAppActionRequest($server_name, $action, $media_caster_type, $vhost_name, $app_name, $streamfile_name, $connect_app_name, $app_nstance, $dst_entry_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putStreamFileAppAction'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $media_caster_type The MediaCasterType to use for the connection (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $streamfile_name The stream file, file name needed for this REST call (required)
     * @param  string $connect_app_name The name of the application to connect to (optional)
     * @param  string $app_nstance The name of the application instance to connect to (optional)
     * @param  string $dst_entry_name The destination stream file name when copying (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putStreamFileAppActionRequest($server_name, $action, $media_caster_type, $vhost_name, $app_name, $streamfile_name, $connect_app_name = null, $app_nstance = null, $dst_entry_name = null)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putStreamFileAppAction'
            );
        }
        // verify the required parameter 'action' is set
        if ($action === null || (is_array($action) && count($action) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $action when calling putStreamFileAppAction'
            );
        }
        // verify the required parameter 'media_caster_type' is set
        if ($media_caster_type === null || (is_array($media_caster_type) && count($media_caster_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $media_caster_type when calling putStreamFileAppAction'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putStreamFileAppAction'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putStreamFileAppAction'
            );
        }
        // verify the required parameter 'streamfile_name' is set
        if ($streamfile_name === null || (is_array($streamfile_name) && count($streamfile_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $streamfile_name when calling putStreamFileAppAction'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/streamfiles/{streamfileName}/actions/{action}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($connect_app_name !== null) {
            $queryParams['connectAppName'] = ObjectSerializer::toQueryValue($connect_app_name);
        }
        // query params
        if ($app_nstance !== null) {
            $queryParams['appInstance'] = ObjectSerializer::toQueryValue($app_nstance);
        }
        // query params
        if ($media_caster_type !== null) {
            $queryParams['mediaCasterType'] = ObjectSerializer::toQueryValue($media_caster_type);
        }
        // query params
        if ($dst_entry_name !== null) {
            $queryParams['dstEntryName'] = ObjectSerializer::toQueryValue($dst_entry_name);
        }

        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($action !== null) {
            $resourcePath = str_replace(
                '{' . 'action' . '}',
                ObjectSerializer::toPathValue($action),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($streamfile_name !== null) {
            $resourcePath = str_replace(
                '{' . 'streamfileName' . '}',
                ObjectSerializer::toPathValue($streamfile_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putStreamFileAppConfig
     *
     * Updates the specified Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\StreamFileAppConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putStreamFileAppConfig($server_name, $vhost_name, $streamfile_name, $app_name, $body)
    {
        $this->putStreamFileAppConfigWithHttpInfo($server_name, $vhost_name, $streamfile_name, $app_name, $body);
    }

    /**
     * Operation putStreamFileAppConfigWithHttpInfo
     *
     * Updates the specified Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\StreamFileAppConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putStreamFileAppConfigWithHttpInfo($server_name, $vhost_name, $streamfile_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putStreamFileAppConfigRequest($server_name, $vhost_name, $streamfile_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putStreamFileAppConfigAsync
     *
     * Updates the specified Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\StreamFileAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putStreamFileAppConfigAsync($server_name, $vhost_name, $streamfile_name, $app_name, $body)
    {
        return $this->putStreamFileAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $streamfile_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putStreamFileAppConfigAsyncWithHttpInfo
     *
     * Updates the specified Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\StreamFileAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putStreamFileAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $streamfile_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putStreamFileAppConfigRequest($server_name, $vhost_name, $streamfile_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putStreamFileAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the extension (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\StreamFileAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putStreamFileAppConfigRequest($server_name, $vhost_name, $streamfile_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putStreamFileAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putStreamFileAppConfig'
            );
        }
        // verify the required parameter 'streamfile_name' is set
        if ($streamfile_name === null || (is_array($streamfile_name) && count($streamfile_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $streamfile_name when calling putStreamFileAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putStreamFileAppConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putStreamFileAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/streamfiles/{streamfileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($streamfile_name !== null) {
            $resourcePath = str_replace(
                '{' . 'streamfileName' . '}',
                ObjectSerializer::toPathValue($streamfile_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putStreamFileAppConfigAdv
     *
     * Updates the Advanced Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $streamfile_name The stream file name without the .stream extension (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\StreamFileAppConfigAdv $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putStreamFileAppConfigAdv($server_name, $vhost_name, $streamfile_name, $app_name, $body)
    {
        $this->putStreamFileAppConfigAdvWithHttpInfo($server_name, $vhost_name, $streamfile_name, $app_name, $body);
    }

    /**
     * Operation putStreamFileAppConfigAdvWithHttpInfo
     *
     * Updates the Advanced Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the .stream extension (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\StreamFileAppConfigAdv $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putStreamFileAppConfigAdvWithHttpInfo($server_name, $vhost_name, $streamfile_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putStreamFileAppConfigAdvRequest($server_name, $vhost_name, $streamfile_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putStreamFileAppConfigAdvAsync
     *
     * Updates the Advanced Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the .stream extension (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\StreamFileAppConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putStreamFileAppConfigAdvAsync($server_name, $vhost_name, $streamfile_name, $app_name, $body)
    {
        return $this->putStreamFileAppConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $streamfile_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putStreamFileAppConfigAdvAsyncWithHttpInfo
     *
     * Updates the Advanced Stream File configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the .stream extension (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\StreamFileAppConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putStreamFileAppConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $streamfile_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putStreamFileAppConfigAdvRequest($server_name, $vhost_name, $streamfile_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putStreamFileAppConfigAdv'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $streamfile_name The stream file name without the .stream extension (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\StreamFileAppConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putStreamFileAppConfigAdvRequest($server_name, $vhost_name, $streamfile_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putStreamFileAppConfigAdv'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putStreamFileAppConfigAdv'
            );
        }
        // verify the required parameter 'streamfile_name' is set
        if ($streamfile_name === null || (is_array($streamfile_name) && count($streamfile_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $streamfile_name when calling putStreamFileAppConfigAdv'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putStreamFileAppConfigAdv'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putStreamFileAppConfigAdv'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/streamfiles/{streamfileName}/adv';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($streamfile_name !== null) {
            $resourcePath = str_replace(
                '{' . 'streamfileName' . '}',
                ObjectSerializer::toPathValue($streamfile_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putStreamGroupAction
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $instance_name The application instance name needed for this REST call (required)
     * @param  string $group_name The group name needed for this REST call (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putStreamGroupAction($server_name, $action, $vhost_name, $app_name, $instance_name, $group_name)
    {
        $this->putStreamGroupActionWithHttpInfo($server_name, $action, $vhost_name, $app_name, $instance_name, $group_name);
    }

    /**
     * Operation putStreamGroupActionWithHttpInfo
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $instance_name The application instance name needed for this REST call (required)
     * @param  string $group_name The group name needed for this REST call (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putStreamGroupActionWithHttpInfo($server_name, $action, $vhost_name, $app_name, $instance_name, $group_name)
    {
        $returnType = '';
        $request = $this->putStreamGroupActionRequest($server_name, $action, $vhost_name, $app_name, $instance_name, $group_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putStreamGroupActionAsync
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $instance_name The application instance name needed for this REST call (required)
     * @param  string $group_name The group name needed for this REST call (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putStreamGroupActionAsync($server_name, $action, $vhost_name, $app_name, $instance_name, $group_name)
    {
        return $this->putStreamGroupActionAsyncWithHttpInfo($server_name, $action, $vhost_name, $app_name, $instance_name, $group_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putStreamGroupActionAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $instance_name The application instance name needed for this REST call (required)
     * @param  string $group_name The group name needed for this REST call (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putStreamGroupActionAsyncWithHttpInfo($server_name, $action, $vhost_name, $app_name, $instance_name, $group_name)
    {
        $returnType = '';
        $request = $this->putStreamGroupActionRequest($server_name, $action, $vhost_name, $app_name, $instance_name, $group_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putStreamGroupAction'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $instance_name The application instance name needed for this REST call (required)
     * @param  string $group_name The group name needed for this REST call (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putStreamGroupActionRequest($server_name, $action, $vhost_name, $app_name, $instance_name, $group_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putStreamGroupAction'
            );
        }
        // verify the required parameter 'action' is set
        if ($action === null || (is_array($action) && count($action) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $action when calling putStreamGroupAction'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putStreamGroupAction'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putStreamGroupAction'
            );
        }
        // verify the required parameter 'instance_name' is set
        if ($instance_name === null || (is_array($instance_name) && count($instance_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_name when calling putStreamGroupAction'
            );
        }
        // verify the required parameter 'group_name' is set
        if ($group_name === null || (is_array($group_name) && count($group_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_name when calling putStreamGroupAction'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/instances/{instanceName}/streamgroups/{groupName}/actions/{action}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($action !== null) {
            $resourcePath = str_replace(
                '{' . 'action' . '}',
                ObjectSerializer::toPathValue($action),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($instance_name !== null) {
            $resourcePath = str_replace(
                '{' . 'instanceName' . '}',
                ObjectSerializer::toPathValue($instance_name),
                $resourcePath
            );
        }
        // path params
        if ($group_name !== null) {
            $resourcePath = str_replace(
                '{' . 'groupName' . '}',
                ObjectSerializer::toPathValue($group_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putStreamRecorderAction
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $instance_name The application instance name needed for this REST call (required)
     * @param  string $recorder_name The recorder name (stream name) needed for this REST call (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putStreamRecorderAction($server_name, $action, $vhost_name, $app_name, $instance_name, $recorder_name)
    {
        $this->putStreamRecorderActionWithHttpInfo($server_name, $action, $vhost_name, $app_name, $instance_name, $recorder_name);
    }

    /**
     * Operation putStreamRecorderActionWithHttpInfo
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $instance_name The application instance name needed for this REST call (required)
     * @param  string $recorder_name The recorder name (stream name) needed for this REST call (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putStreamRecorderActionWithHttpInfo($server_name, $action, $vhost_name, $app_name, $instance_name, $recorder_name)
    {
        $returnType = '';
        $request = $this->putStreamRecorderActionRequest($server_name, $action, $vhost_name, $app_name, $instance_name, $recorder_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putStreamRecorderActionAsync
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $instance_name The application instance name needed for this REST call (required)
     * @param  string $recorder_name The recorder name (stream name) needed for this REST call (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putStreamRecorderActionAsync($server_name, $action, $vhost_name, $app_name, $instance_name, $recorder_name)
    {
        return $this->putStreamRecorderActionAsyncWithHttpInfo($server_name, $action, $vhost_name, $app_name, $instance_name, $recorder_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putStreamRecorderActionAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $instance_name The application instance name needed for this REST call (required)
     * @param  string $recorder_name The recorder name (stream name) needed for this REST call (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putStreamRecorderActionAsyncWithHttpInfo($server_name, $action, $vhost_name, $app_name, $instance_name, $recorder_name)
    {
        $returnType = '';
        $request = $this->putStreamRecorderActionRequest($server_name, $action, $vhost_name, $app_name, $instance_name, $recorder_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putStreamRecorderAction'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $instance_name The application instance name needed for this REST call (required)
     * @param  string $recorder_name The recorder name (stream name) needed for this REST call (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putStreamRecorderActionRequest($server_name, $action, $vhost_name, $app_name, $instance_name, $recorder_name)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putStreamRecorderAction'
            );
        }
        // verify the required parameter 'action' is set
        if ($action === null || (is_array($action) && count($action) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $action when calling putStreamRecorderAction'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putStreamRecorderAction'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putStreamRecorderAction'
            );
        }
        // verify the required parameter 'instance_name' is set
        if ($instance_name === null || (is_array($instance_name) && count($instance_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $instance_name when calling putStreamRecorderAction'
            );
        }
        // verify the required parameter 'recorder_name' is set
        if ($recorder_name === null || (is_array($recorder_name) && count($recorder_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recorder_name when calling putStreamRecorderAction'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/instances/{instanceName}/streamrecorders/{recorderName}/actions/{action}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($action !== null) {
            $resourcePath = str_replace(
                '{' . 'action' . '}',
                ObjectSerializer::toPathValue($action),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($instance_name !== null) {
            $resourcePath = str_replace(
                '{' . 'instanceName' . '}',
                ObjectSerializer::toPathValue($instance_name),
                $resourcePath
            );
        }
        // path params
        if ($recorder_name !== null) {
            $resourcePath = str_replace(
                '{' . 'recorderName' . '}',
                ObjectSerializer::toPathValue($recorder_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putTranscoderAppConfig
     *
     * Updates the Transcoder configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\TranscoderAppConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putTranscoderAppConfig($server_name, $vhost_name, $app_name, $body)
    {
        $this->putTranscoderAppConfigWithHttpInfo($server_name, $vhost_name, $app_name, $body);
    }

    /**
     * Operation putTranscoderAppConfigWithHttpInfo
     *
     * Updates the Transcoder configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderAppConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putTranscoderAppConfigWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putTranscoderAppConfigRequest($server_name, $vhost_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putTranscoderAppConfigAsync
     *
     * Updates the Transcoder configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderAppConfigAsync($server_name, $vhost_name, $app_name, $body)
    {
        return $this->putTranscoderAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putTranscoderAppConfigAsyncWithHttpInfo
     *
     * Updates the Transcoder configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putTranscoderAppConfigRequest($server_name, $vhost_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putTranscoderAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putTranscoderAppConfigRequest($server_name, $vhost_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putTranscoderAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putTranscoderAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putTranscoderAppConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putTranscoderAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/transcoder';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putTranscoderAppConfigAdv
     *
     * Updates the Advanced Transcoder configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\TranscoderAppConfigAdv $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putTranscoderAppConfigAdv($server_name, $vhost_name, $app_name, $body)
    {
        $this->putTranscoderAppConfigAdvWithHttpInfo($server_name, $vhost_name, $app_name, $body);
    }

    /**
     * Operation putTranscoderAppConfigAdvWithHttpInfo
     *
     * Updates the Advanced Transcoder configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderAppConfigAdv $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putTranscoderAppConfigAdvWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putTranscoderAppConfigAdvRequest($server_name, $vhost_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putTranscoderAppConfigAdvAsync
     *
     * Updates the Advanced Transcoder configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderAppConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderAppConfigAdvAsync($server_name, $vhost_name, $app_name, $body)
    {
        return $this->putTranscoderAppConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putTranscoderAppConfigAdvAsyncWithHttpInfo
     *
     * Updates the Advanced Transcoder configuration for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderAppConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderAppConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putTranscoderAppConfigAdvRequest($server_name, $vhost_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putTranscoderAppConfigAdv'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderAppConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putTranscoderAppConfigAdvRequest($server_name, $vhost_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putTranscoderAppConfigAdv'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putTranscoderAppConfigAdv'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putTranscoderAppConfigAdv'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putTranscoderAppConfigAdv'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/transcoder/adv';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putTranscoderEncodeAppConfig
     *
     * Updates the specified Trancoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $encode_name encode_name (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeAppConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putTranscoderEncodeAppConfig($server_name, $vhost_name, $template_name, $encode_name, $app_name, $body)
    {
        $this->putTranscoderEncodeAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $app_name, $body);
    }

    /**
     * Operation putTranscoderEncodeAppConfigWithHttpInfo
     *
     * Updates the specified Trancoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeAppConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putTranscoderEncodeAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putTranscoderEncodeAppConfigRequest($server_name, $vhost_name, $template_name, $encode_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putTranscoderEncodeAppConfigAsync
     *
     * Updates the specified Trancoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderEncodeAppConfigAsync($server_name, $vhost_name, $template_name, $encode_name, $app_name, $body)
    {
        return $this->putTranscoderEncodeAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putTranscoderEncodeAppConfigAsyncWithHttpInfo
     *
     * Updates the specified Trancoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderEncodeAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putTranscoderEncodeAppConfigRequest($server_name, $vhost_name, $template_name, $encode_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putTranscoderEncodeAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putTranscoderEncodeAppConfigRequest($server_name, $vhost_name, $template_name, $encode_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putTranscoderEncodeAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putTranscoderEncodeAppConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling putTranscoderEncodeAppConfig'
            );
        }
        // verify the required parameter 'encode_name' is set
        if ($encode_name === null || (is_array($encode_name) && count($encode_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $encode_name when calling putTranscoderEncodeAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putTranscoderEncodeAppConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putTranscoderEncodeAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/transcoder/templates/{templateName}/encodes/{encodeName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($encode_name !== null) {
            $resourcePath = str_replace(
                '{' . 'encodeName' . '}',
                ObjectSerializer::toPathValue($encode_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putTranscoderEncodeAppConfigAdv
     *
     * Updates the Advanced Transcoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $encode_name encode_name (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeAppConfigAdv $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putTranscoderEncodeAppConfigAdv($server_name, $vhost_name, $template_name, $encode_name, $app_name, $body)
    {
        $this->putTranscoderEncodeAppConfigAdvWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $app_name, $body);
    }

    /**
     * Operation putTranscoderEncodeAppConfigAdvWithHttpInfo
     *
     * Updates the Advanced Transcoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeAppConfigAdv $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putTranscoderEncodeAppConfigAdvWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putTranscoderEncodeAppConfigAdvRequest($server_name, $vhost_name, $template_name, $encode_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putTranscoderEncodeAppConfigAdvAsync
     *
     * Updates the Advanced Transcoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeAppConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderEncodeAppConfigAdvAsync($server_name, $vhost_name, $template_name, $encode_name, $app_name, $body)
    {
        return $this->putTranscoderEncodeAppConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putTranscoderEncodeAppConfigAdvAsyncWithHttpInfo
     *
     * Updates the Advanced Transcoder Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeAppConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderEncodeAppConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $encode_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putTranscoderEncodeAppConfigAdvRequest($server_name, $vhost_name, $template_name, $encode_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putTranscoderEncodeAppConfigAdv'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderEncodeAppConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putTranscoderEncodeAppConfigAdvRequest($server_name, $vhost_name, $template_name, $encode_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putTranscoderEncodeAppConfigAdv'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putTranscoderEncodeAppConfigAdv'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling putTranscoderEncodeAppConfigAdv'
            );
        }
        // verify the required parameter 'encode_name' is set
        if ($encode_name === null || (is_array($encode_name) && count($encode_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $encode_name when calling putTranscoderEncodeAppConfigAdv'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putTranscoderEncodeAppConfigAdv'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putTranscoderEncodeAppConfigAdv'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/transcoder/templates/{templateName}/encodes/{encodeName}/adv';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($encode_name !== null) {
            $resourcePath = str_replace(
                '{' . 'encodeName' . '}',
                ObjectSerializer::toPathValue($encode_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putTranscoderOverlayDecodeAppConfig
     *
     * Updates the specified Trancoder Overlay Decode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $overlay_name overlay_name (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\TranscoderOverlayDecodeAppConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putTranscoderOverlayDecodeAppConfig($server_name, $vhost_name, $template_name, $overlay_name, $app_name, $body)
    {
        $this->putTranscoderOverlayDecodeAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $app_name, $body);
    }

    /**
     * Operation putTranscoderOverlayDecodeAppConfigWithHttpInfo
     *
     * Updates the specified Trancoder Overlay Decode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderOverlayDecodeAppConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putTranscoderOverlayDecodeAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putTranscoderOverlayDecodeAppConfigRequest($server_name, $vhost_name, $template_name, $overlay_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putTranscoderOverlayDecodeAppConfigAsync
     *
     * Updates the specified Trancoder Overlay Decode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderOverlayDecodeAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderOverlayDecodeAppConfigAsync($server_name, $vhost_name, $template_name, $overlay_name, $app_name, $body)
    {
        return $this->putTranscoderOverlayDecodeAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putTranscoderOverlayDecodeAppConfigAsyncWithHttpInfo
     *
     * Updates the specified Trancoder Overlay Decode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderOverlayDecodeAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderOverlayDecodeAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putTranscoderOverlayDecodeAppConfigRequest($server_name, $vhost_name, $template_name, $overlay_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putTranscoderOverlayDecodeAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderOverlayDecodeAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putTranscoderOverlayDecodeAppConfigRequest($server_name, $vhost_name, $template_name, $overlay_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putTranscoderOverlayDecodeAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putTranscoderOverlayDecodeAppConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling putTranscoderOverlayDecodeAppConfig'
            );
        }
        // verify the required parameter 'overlay_name' is set
        if ($overlay_name === null || (is_array($overlay_name) && count($overlay_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $overlay_name when calling putTranscoderOverlayDecodeAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putTranscoderOverlayDecodeAppConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putTranscoderOverlayDecodeAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/transcoder/templates/{templateName}/decode/overlays/{overlayName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($overlay_name !== null) {
            $resourcePath = str_replace(
                '{' . 'overlayName' . '}',
                ObjectSerializer::toPathValue($overlay_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putTranscoderOverlayEncodeAppConfig
     *
     * Updates the specified Trancoder Overlay Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $overlay_name overlay_name (required)
     * @param  string $encode_name encode_name (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\TranscoderOverlayEncodeAppConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putTranscoderOverlayEncodeAppConfig($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $app_name, $body)
    {
        $this->putTranscoderOverlayEncodeAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $app_name, $body);
    }

    /**
     * Operation putTranscoderOverlayEncodeAppConfigWithHttpInfo
     *
     * Updates the specified Trancoder Overlay Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderOverlayEncodeAppConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putTranscoderOverlayEncodeAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putTranscoderOverlayEncodeAppConfigRequest($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putTranscoderOverlayEncodeAppConfigAsync
     *
     * Updates the specified Trancoder Overlay Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderOverlayEncodeAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderOverlayEncodeAppConfigAsync($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $app_name, $body)
    {
        return $this->putTranscoderOverlayEncodeAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putTranscoderOverlayEncodeAppConfigAsyncWithHttpInfo
     *
     * Updates the specified Trancoder Overlay Encode configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderOverlayEncodeAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderOverlayEncodeAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putTranscoderOverlayEncodeAppConfigRequest($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putTranscoderOverlayEncodeAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $overlay_name (required)
     * @param  string $encode_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderOverlayEncodeAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putTranscoderOverlayEncodeAppConfigRequest($server_name, $vhost_name, $template_name, $overlay_name, $encode_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putTranscoderOverlayEncodeAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putTranscoderOverlayEncodeAppConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling putTranscoderOverlayEncodeAppConfig'
            );
        }
        // verify the required parameter 'overlay_name' is set
        if ($overlay_name === null || (is_array($overlay_name) && count($overlay_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $overlay_name when calling putTranscoderOverlayEncodeAppConfig'
            );
        }
        // verify the required parameter 'encode_name' is set
        if ($encode_name === null || (is_array($encode_name) && count($encode_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $encode_name when calling putTranscoderOverlayEncodeAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putTranscoderOverlayEncodeAppConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putTranscoderOverlayEncodeAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/transcoder/templates/{templateName}/encodes/{encodeName}/overlays/{overlayName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($overlay_name !== null) {
            $resourcePath = str_replace(
                '{' . 'overlayName' . '}',
                ObjectSerializer::toPathValue($overlay_name),
                $resourcePath
            );
        }
        // path params
        if ($encode_name !== null) {
            $resourcePath = str_replace(
                '{' . 'encodeName' . '}',
                ObjectSerializer::toPathValue($encode_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putTranscoderStreamNameGroupAppConfig
     *
     * Updates the specified Trancoder StreamNameGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $group_name group_name (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\TranscoderStreamNameGroupAppConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putTranscoderStreamNameGroupAppConfig($server_name, $vhost_name, $template_name, $group_name, $app_name, $body)
    {
        $this->putTranscoderStreamNameGroupAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $group_name, $app_name, $body);
    }

    /**
     * Operation putTranscoderStreamNameGroupAppConfigWithHttpInfo
     *
     * Updates the specified Trancoder StreamNameGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $group_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderStreamNameGroupAppConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putTranscoderStreamNameGroupAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $group_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putTranscoderStreamNameGroupAppConfigRequest($server_name, $vhost_name, $template_name, $group_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putTranscoderStreamNameGroupAppConfigAsync
     *
     * Updates the specified Trancoder StreamNameGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $group_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderStreamNameGroupAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderStreamNameGroupAppConfigAsync($server_name, $vhost_name, $template_name, $group_name, $app_name, $body)
    {
        return $this->putTranscoderStreamNameGroupAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $group_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putTranscoderStreamNameGroupAppConfigAsyncWithHttpInfo
     *
     * Updates the specified Trancoder StreamNameGroup configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $group_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderStreamNameGroupAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderStreamNameGroupAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $group_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putTranscoderStreamNameGroupAppConfigRequest($server_name, $vhost_name, $template_name, $group_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putTranscoderStreamNameGroupAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $group_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderStreamNameGroupAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putTranscoderStreamNameGroupAppConfigRequest($server_name, $vhost_name, $template_name, $group_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putTranscoderStreamNameGroupAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putTranscoderStreamNameGroupAppConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling putTranscoderStreamNameGroupAppConfig'
            );
        }
        // verify the required parameter 'group_name' is set
        if ($group_name === null || (is_array($group_name) && count($group_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_name when calling putTranscoderStreamNameGroupAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putTranscoderStreamNameGroupAppConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putTranscoderStreamNameGroupAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/transcoder/templates/{templateName}/streamnamegroups/{groupName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($group_name !== null) {
            $resourcePath = str_replace(
                '{' . 'groupName' . '}',
                ObjectSerializer::toPathValue($group_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putTranscoderTemplateAppAction
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $template_name The template name needed for this REST call (required)
     * @param  string $dst_entry_name The destination transcode template file name when copying (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putTranscoderTemplateAppAction($server_name, $action, $vhost_name, $app_name, $template_name, $dst_entry_name = null)
    {
        $this->putTranscoderTemplateAppActionWithHttpInfo($server_name, $action, $vhost_name, $app_name, $template_name, $dst_entry_name);
    }

    /**
     * Operation putTranscoderTemplateAppActionWithHttpInfo
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $template_name The template name needed for this REST call (required)
     * @param  string $dst_entry_name The destination transcode template file name when copying (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putTranscoderTemplateAppActionWithHttpInfo($server_name, $action, $vhost_name, $app_name, $template_name, $dst_entry_name = null)
    {
        $returnType = '';
        $request = $this->putTranscoderTemplateAppActionRequest($server_name, $action, $vhost_name, $app_name, $template_name, $dst_entry_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putTranscoderTemplateAppActionAsync
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $template_name The template name needed for this REST call (required)
     * @param  string $dst_entry_name The destination transcode template file name when copying (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderTemplateAppActionAsync($server_name, $action, $vhost_name, $app_name, $template_name, $dst_entry_name = null)
    {
        return $this->putTranscoderTemplateAppActionAsyncWithHttpInfo($server_name, $action, $vhost_name, $app_name, $template_name, $dst_entry_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putTranscoderTemplateAppActionAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $template_name The template name needed for this REST call (required)
     * @param  string $dst_entry_name The destination transcode template file name when copying (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderTemplateAppActionAsyncWithHttpInfo($server_name, $action, $vhost_name, $app_name, $template_name, $dst_entry_name = null)
    {
        $returnType = '';
        $request = $this->putTranscoderTemplateAppActionRequest($server_name, $action, $vhost_name, $app_name, $template_name, $dst_entry_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putTranscoderTemplateAppAction'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $action The action which should be performed by the server (required)
     * @param  string $vhost_name The name of the current VHost the action will be performed on (required)
     * @param  string $app_name The application name needed for this REST call (required)
     * @param  string $template_name The template name needed for this REST call (required)
     * @param  string $dst_entry_name The destination transcode template file name when copying (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putTranscoderTemplateAppActionRequest($server_name, $action, $vhost_name, $app_name, $template_name, $dst_entry_name = null)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putTranscoderTemplateAppAction'
            );
        }
        // verify the required parameter 'action' is set
        if ($action === null || (is_array($action) && count($action) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $action when calling putTranscoderTemplateAppAction'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putTranscoderTemplateAppAction'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putTranscoderTemplateAppAction'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling putTranscoderTemplateAppAction'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/transcoder/templates/{templateName}/actions/{action}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($dst_entry_name !== null) {
            $queryParams['dstEntryName'] = ObjectSerializer::toQueryValue($dst_entry_name);
        }

        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($action !== null) {
            $resourcePath = str_replace(
                '{' . 'action' . '}',
                ObjectSerializer::toPathValue($action),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putTranscoderTemplateAppConfig
     *
     * Updates the specified Trancoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateAppConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putTranscoderTemplateAppConfig($server_name, $vhost_name, $template_name, $app_name, $body)
    {
        $this->putTranscoderTemplateAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $app_name, $body);
    }

    /**
     * Operation putTranscoderTemplateAppConfigWithHttpInfo
     *
     * Updates the specified Trancoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateAppConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putTranscoderTemplateAppConfigWithHttpInfo($server_name, $vhost_name, $template_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putTranscoderTemplateAppConfigRequest($server_name, $vhost_name, $template_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putTranscoderTemplateAppConfigAsync
     *
     * Updates the specified Trancoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderTemplateAppConfigAsync($server_name, $vhost_name, $template_name, $app_name, $body)
    {
        return $this->putTranscoderTemplateAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putTranscoderTemplateAppConfigAsyncWithHttpInfo
     *
     * Updates the specified Trancoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderTemplateAppConfigAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putTranscoderTemplateAppConfigRequest($server_name, $vhost_name, $template_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putTranscoderTemplateAppConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateAppConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putTranscoderTemplateAppConfigRequest($server_name, $vhost_name, $template_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putTranscoderTemplateAppConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putTranscoderTemplateAppConfig'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling putTranscoderTemplateAppConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putTranscoderTemplateAppConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putTranscoderTemplateAppConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/transcoder/templates/{templateName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putTranscoderTemplateAppConfigAdv
     *
     * Updates the Advanced Transcoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $template_name template_name (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateAppConfigAdv $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putTranscoderTemplateAppConfigAdv($server_name, $vhost_name, $template_name, $app_name, $body)
    {
        $this->putTranscoderTemplateAppConfigAdvWithHttpInfo($server_name, $vhost_name, $template_name, $app_name, $body);
    }

    /**
     * Operation putTranscoderTemplateAppConfigAdvWithHttpInfo
     *
     * Updates the Advanced Transcoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateAppConfigAdv $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putTranscoderTemplateAppConfigAdvWithHttpInfo($server_name, $vhost_name, $template_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putTranscoderTemplateAppConfigAdvRequest($server_name, $vhost_name, $template_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putTranscoderTemplateAppConfigAdvAsync
     *
     * Updates the Advanced Transcoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateAppConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderTemplateAppConfigAdvAsync($server_name, $vhost_name, $template_name, $app_name, $body)
    {
        return $this->putTranscoderTemplateAppConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putTranscoderTemplateAppConfigAdvAsyncWithHttpInfo
     *
     * Updates the Advanced Transcoder Template configuration
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateAppConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putTranscoderTemplateAppConfigAdvAsyncWithHttpInfo($server_name, $vhost_name, $template_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putTranscoderTemplateAppConfigAdvRequest($server_name, $vhost_name, $template_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putTranscoderTemplateAppConfigAdv'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $template_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\TranscoderTemplateAppConfigAdv $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putTranscoderTemplateAppConfigAdvRequest($server_name, $vhost_name, $template_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putTranscoderTemplateAppConfigAdv'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putTranscoderTemplateAppConfigAdv'
            );
        }
        // verify the required parameter 'template_name' is set
        if ($template_name === null || (is_array($template_name) && count($template_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_name when calling putTranscoderTemplateAppConfigAdv'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putTranscoderTemplateAppConfigAdv'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putTranscoderTemplateAppConfigAdv'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/transcoder/templates/{templateName}/adv';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($template_name !== null) {
            $resourcePath = str_replace(
                '{' . 'templateName' . '}',
                ObjectSerializer::toPathValue($template_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putVerimatrixStreamMapsConfig
     *
     * Updates the Verimatrix stream mapfile for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name vhost_name (required)
     * @param  string $app_name app_name (required)
     * @param  \Swagger\Client\Model\VerimatrixStreamMapsConfig $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putVerimatrixStreamMapsConfig($server_name, $vhost_name, $app_name, $body)
    {
        $this->putVerimatrixStreamMapsConfigWithHttpInfo($server_name, $vhost_name, $app_name, $body);
    }

    /**
     * Operation putVerimatrixStreamMapsConfigWithHttpInfo
     *
     * Updates the Verimatrix stream mapfile for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\VerimatrixStreamMapsConfig $body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putVerimatrixStreamMapsConfigWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putVerimatrixStreamMapsConfigRequest($server_name, $vhost_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation putVerimatrixStreamMapsConfigAsync
     *
     * Updates the Verimatrix stream mapfile for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\VerimatrixStreamMapsConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putVerimatrixStreamMapsConfigAsync($server_name, $vhost_name, $app_name, $body)
    {
        return $this->putVerimatrixStreamMapsConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putVerimatrixStreamMapsConfigAsyncWithHttpInfo
     *
     * Updates the Verimatrix stream mapfile for the specified Application
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\VerimatrixStreamMapsConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putVerimatrixStreamMapsConfigAsyncWithHttpInfo($server_name, $vhost_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->putVerimatrixStreamMapsConfigRequest($server_name, $vhost_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putVerimatrixStreamMapsConfig'
     *
     * @param  string $server_name Reserved for future use (required)
     * @param  string $vhost_name (required)
     * @param  string $app_name (required)
     * @param  \Swagger\Client\Model\VerimatrixStreamMapsConfig $body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putVerimatrixStreamMapsConfigRequest($server_name, $vhost_name, $app_name, $body)
    {
        // verify the required parameter 'server_name' is set
        if ($server_name === null || (is_array($server_name) && count($server_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_name when calling putVerimatrixStreamMapsConfig'
            );
        }
        // verify the required parameter 'vhost_name' is set
        if ($vhost_name === null || (is_array($vhost_name) && count($vhost_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vhost_name when calling putVerimatrixStreamMapsConfig'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling putVerimatrixStreamMapsConfig'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putVerimatrixStreamMapsConfig'
            );
        }

        $resourcePath = '/v2/servers/{serverName}/vhosts/{vhostName}/applications/{appName}/drm/verimatrixmapfile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($server_name !== null) {
            $resourcePath = str_replace(
                '{' . 'serverName' . '}',
                ObjectSerializer::toPathValue($server_name),
                $resourcePath
            );
        }
        // path params
        if ($vhost_name !== null) {
            $resourcePath = str_replace(
                '{' . 'vhostName' . '}',
                ObjectSerializer::toPathValue($vhost_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'appName' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'text/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'text/xml', 'application/json'],
                ['application/xml', 'text/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
